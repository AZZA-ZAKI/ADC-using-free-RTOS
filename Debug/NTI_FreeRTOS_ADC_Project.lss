
NTI_FreeRTOS_ADC_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000050ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00800060  000050ba  0000514e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000048f  00800084  00800084  00005172  2**0
                  ALLOC
  3 .stab         00006960  00000000  00000000  00005174  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003aa2  00000000  00000000  0000bad4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000f576  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000f6b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000f826  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0001146f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001235a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00013108  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00013268  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000134f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013cc3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 f0 1a 	jmp	0x35e0	; 0x35e0 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 58 0a 	jmp	0x14b0	; 0x14b0 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea eb       	ldi	r30, 0xBA	; 186
      68:	f0 e5       	ldi	r31, 0x50	; 80
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 31       	cpi	r26, 0x13	; 19
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <main>
      8a:	0c 94 5b 28 	jmp	0x50b6	; 0x50b6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 05 28 	jmp	0x500a	; 0x500a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a9 e7       	ldi	r26, 0x79	; 121
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 21 28 	jmp	0x5042	; 0x5042 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 2d 28 	jmp	0x505a	; 0x505a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 2d 28 	jmp	0x505a	; 0x505a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 05 28 	jmp	0x500a	; 0x500a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	89 e7       	ldi	r24, 0x79	; 121
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 21 28 	jmp	0x5042	; 0x5042 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 2d 28 	jmp	0x505a	; 0x505a <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 2d 28 	jmp	0x505a	; 0x505a <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 2d 28 	jmp	0x505a	; 0x505a <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 15 28 	jmp	0x502a	; 0x502a <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 31 28 	jmp	0x5062	; 0x5062 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__pack_f+0x178>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__pack_f+0x172>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__pack_f+0x17c>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__pack_f+0x114>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__pack_f+0x76>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__pack_f+0xca>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__pack_f+0x86>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__pack_f+0x7e>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__pack_f+0x9c>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__pack_f+0x94>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__pack_f+0xbe>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__pack_f+0xee>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__pack_f+0xf6>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__pack_f+0xf6>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__pack_f+0x10e>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__pack_f+0x162>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__pack_f+0x172>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__pack_f+0x144>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__pack_f+0x154>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__pack_f+0x14c>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__pack_f+0x162>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__pack_f+0x164>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__pack_f+0x17c>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <MGIE_VidEnable>:

#include"MGIE_Private.h"

/*GIE Enable Function*/
void MGIE_VidEnable(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
     b4e:	af e5       	ldi	r26, 0x5F	; 95
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	ef e5       	ldi	r30, 0x5F	; 95
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	80 68       	ori	r24, 0x80	; 128
     b5a:	8c 93       	st	X, r24
}
     b5c:	cf 91       	pop	r28
     b5e:	df 91       	pop	r29
     b60:	08 95       	ret

00000b62 <MGIE_VidDisable>:
/*GIE Disable Function*/
void MGIE_VidDisable(void)
{
     b62:	df 93       	push	r29
     b64:	cf 93       	push	r28
     b66:	cd b7       	in	r28, 0x3d	; 61
     b68:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
     b6a:	af e5       	ldi	r26, 0x5F	; 95
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	ef e5       	ldi	r30, 0x5F	; 95
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	8f 77       	andi	r24, 0x7F	; 127
     b76:	8c 93       	st	X, r24
}
     b78:	cf 91       	pop	r28
     b7a:	df 91       	pop	r29
     b7c:	08 95       	ret

00000b7e <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
     b7e:	df 93       	push	r29
     b80:	cf 93       	push	r28
     b82:	00 d0       	rcall	.+0      	; 0xb84 <MDIO_Error_State_SetPinDirection+0x6>
     b84:	00 d0       	rcall	.+0      	; 0xb86 <MDIO_Error_State_SetPinDirection+0x8>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <MDIO_Error_State_SetPinDirection+0xa>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	8a 83       	std	Y+2, r24	; 0x02
     b8e:	6b 83       	std	Y+3, r22	; 0x03
     b90:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
     b92:	81 e0       	ldi	r24, 0x01	; 1
     b94:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	88 30       	cpi	r24, 0x08	; 8
     b9a:	08 f0       	brcs	.+2      	; 0xb9e <MDIO_Error_State_SetPinDirection+0x20>
     b9c:	e8 c0       	rjmp	.+464    	; 0xd6e <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
     b9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ba0:	28 2f       	mov	r18, r24
     ba2:	30 e0       	ldi	r19, 0x00	; 0
     ba4:	3e 83       	std	Y+6, r19	; 0x06
     ba6:	2d 83       	std	Y+5, r18	; 0x05
     ba8:	8d 81       	ldd	r24, Y+5	; 0x05
     baa:	9e 81       	ldd	r25, Y+6	; 0x06
     bac:	81 30       	cpi	r24, 0x01	; 1
     bae:	91 05       	cpc	r25, r1
     bb0:	09 f4       	brne	.+2      	; 0xbb4 <MDIO_Error_State_SetPinDirection+0x36>
     bb2:	48 c0       	rjmp	.+144    	; 0xc44 <MDIO_Error_State_SetPinDirection+0xc6>
     bb4:	2d 81       	ldd	r18, Y+5	; 0x05
     bb6:	3e 81       	ldd	r19, Y+6	; 0x06
     bb8:	22 30       	cpi	r18, 0x02	; 2
     bba:	31 05       	cpc	r19, r1
     bbc:	2c f4       	brge	.+10     	; 0xbc8 <MDIO_Error_State_SetPinDirection+0x4a>
     bbe:	8d 81       	ldd	r24, Y+5	; 0x05
     bc0:	9e 81       	ldd	r25, Y+6	; 0x06
     bc2:	00 97       	sbiw	r24, 0x00	; 0
     bc4:	71 f0       	breq	.+28     	; 0xbe2 <MDIO_Error_State_SetPinDirection+0x64>
     bc6:	d1 c0       	rjmp	.+418    	; 0xd6a <MDIO_Error_State_SetPinDirection+0x1ec>
     bc8:	2d 81       	ldd	r18, Y+5	; 0x05
     bca:	3e 81       	ldd	r19, Y+6	; 0x06
     bcc:	22 30       	cpi	r18, 0x02	; 2
     bce:	31 05       	cpc	r19, r1
     bd0:	09 f4       	brne	.+2      	; 0xbd4 <MDIO_Error_State_SetPinDirection+0x56>
     bd2:	69 c0       	rjmp	.+210    	; 0xca6 <MDIO_Error_State_SetPinDirection+0x128>
     bd4:	8d 81       	ldd	r24, Y+5	; 0x05
     bd6:	9e 81       	ldd	r25, Y+6	; 0x06
     bd8:	83 30       	cpi	r24, 0x03	; 3
     bda:	91 05       	cpc	r25, r1
     bdc:	09 f4       	brne	.+2      	; 0xbe0 <MDIO_Error_State_SetPinDirection+0x62>
     bde:	94 c0       	rjmp	.+296    	; 0xd08 <MDIO_Error_State_SetPinDirection+0x18a>
     be0:	c4 c0       	rjmp	.+392    	; 0xd6a <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     be2:	8c 81       	ldd	r24, Y+4	; 0x04
     be4:	81 30       	cpi	r24, 0x01	; 1
     be6:	a1 f4       	brne	.+40     	; 0xc10 <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
     be8:	aa e3       	ldi	r26, 0x3A	; 58
     bea:	b0 e0       	ldi	r27, 0x00	; 0
     bec:	ea e3       	ldi	r30, 0x3A	; 58
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	80 81       	ld	r24, Z
     bf2:	48 2f       	mov	r20, r24
     bf4:	8a 81       	ldd	r24, Y+2	; 0x02
     bf6:	28 2f       	mov	r18, r24
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	81 e0       	ldi	r24, 0x01	; 1
     bfc:	90 e0       	ldi	r25, 0x00	; 0
     bfe:	02 2e       	mov	r0, r18
     c00:	02 c0       	rjmp	.+4      	; 0xc06 <MDIO_Error_State_SetPinDirection+0x88>
     c02:	88 0f       	add	r24, r24
     c04:	99 1f       	adc	r25, r25
     c06:	0a 94       	dec	r0
     c08:	e2 f7       	brpl	.-8      	; 0xc02 <MDIO_Error_State_SetPinDirection+0x84>
     c0a:	84 2b       	or	r24, r20
     c0c:	8c 93       	st	X, r24
     c0e:	b0 c0       	rjmp	.+352    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     c10:	8c 81       	ldd	r24, Y+4	; 0x04
     c12:	88 23       	and	r24, r24
     c14:	a9 f4       	brne	.+42     	; 0xc40 <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
     c16:	aa e3       	ldi	r26, 0x3A	; 58
     c18:	b0 e0       	ldi	r27, 0x00	; 0
     c1a:	ea e3       	ldi	r30, 0x3A	; 58
     c1c:	f0 e0       	ldi	r31, 0x00	; 0
     c1e:	80 81       	ld	r24, Z
     c20:	48 2f       	mov	r20, r24
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	28 2f       	mov	r18, r24
     c26:	30 e0       	ldi	r19, 0x00	; 0
     c28:	81 e0       	ldi	r24, 0x01	; 1
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	02 2e       	mov	r0, r18
     c2e:	02 c0       	rjmp	.+4      	; 0xc34 <MDIO_Error_State_SetPinDirection+0xb6>
     c30:	88 0f       	add	r24, r24
     c32:	99 1f       	adc	r25, r25
     c34:	0a 94       	dec	r0
     c36:	e2 f7       	brpl	.-8      	; 0xc30 <MDIO_Error_State_SetPinDirection+0xb2>
     c38:	80 95       	com	r24
     c3a:	84 23       	and	r24, r20
     c3c:	8c 93       	st	X, r24
     c3e:	98 c0       	rjmp	.+304    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     c40:	19 82       	std	Y+1, r1	; 0x01
     c42:	96 c0       	rjmp	.+300    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     c44:	8c 81       	ldd	r24, Y+4	; 0x04
     c46:	81 30       	cpi	r24, 0x01	; 1
     c48:	a1 f4       	brne	.+40     	; 0xc72 <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
     c4a:	a7 e3       	ldi	r26, 0x37	; 55
     c4c:	b0 e0       	ldi	r27, 0x00	; 0
     c4e:	e7 e3       	ldi	r30, 0x37	; 55
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	48 2f       	mov	r20, r24
     c56:	8a 81       	ldd	r24, Y+2	; 0x02
     c58:	28 2f       	mov	r18, r24
     c5a:	30 e0       	ldi	r19, 0x00	; 0
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	02 2e       	mov	r0, r18
     c62:	02 c0       	rjmp	.+4      	; 0xc68 <MDIO_Error_State_SetPinDirection+0xea>
     c64:	88 0f       	add	r24, r24
     c66:	99 1f       	adc	r25, r25
     c68:	0a 94       	dec	r0
     c6a:	e2 f7       	brpl	.-8      	; 0xc64 <MDIO_Error_State_SetPinDirection+0xe6>
     c6c:	84 2b       	or	r24, r20
     c6e:	8c 93       	st	X, r24
     c70:	7f c0       	rjmp	.+254    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     c72:	8c 81       	ldd	r24, Y+4	; 0x04
     c74:	88 23       	and	r24, r24
     c76:	a9 f4       	brne	.+42     	; 0xca2 <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
     c78:	a7 e3       	ldi	r26, 0x37	; 55
     c7a:	b0 e0       	ldi	r27, 0x00	; 0
     c7c:	e7 e3       	ldi	r30, 0x37	; 55
     c7e:	f0 e0       	ldi	r31, 0x00	; 0
     c80:	80 81       	ld	r24, Z
     c82:	48 2f       	mov	r20, r24
     c84:	8a 81       	ldd	r24, Y+2	; 0x02
     c86:	28 2f       	mov	r18, r24
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	02 2e       	mov	r0, r18
     c90:	02 c0       	rjmp	.+4      	; 0xc96 <MDIO_Error_State_SetPinDirection+0x118>
     c92:	88 0f       	add	r24, r24
     c94:	99 1f       	adc	r25, r25
     c96:	0a 94       	dec	r0
     c98:	e2 f7       	brpl	.-8      	; 0xc92 <MDIO_Error_State_SetPinDirection+0x114>
     c9a:	80 95       	com	r24
     c9c:	84 23       	and	r24, r20
     c9e:	8c 93       	st	X, r24
     ca0:	67 c0       	rjmp	.+206    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     ca2:	19 82       	std	Y+1, r1	; 0x01
     ca4:	65 c0       	rjmp	.+202    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     ca6:	8c 81       	ldd	r24, Y+4	; 0x04
     ca8:	81 30       	cpi	r24, 0x01	; 1
     caa:	a1 f4       	brne	.+40     	; 0xcd4 <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
     cac:	a4 e3       	ldi	r26, 0x34	; 52
     cae:	b0 e0       	ldi	r27, 0x00	; 0
     cb0:	e4 e3       	ldi	r30, 0x34	; 52
     cb2:	f0 e0       	ldi	r31, 0x00	; 0
     cb4:	80 81       	ld	r24, Z
     cb6:	48 2f       	mov	r20, r24
     cb8:	8a 81       	ldd	r24, Y+2	; 0x02
     cba:	28 2f       	mov	r18, r24
     cbc:	30 e0       	ldi	r19, 0x00	; 0
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	02 2e       	mov	r0, r18
     cc4:	02 c0       	rjmp	.+4      	; 0xcca <MDIO_Error_State_SetPinDirection+0x14c>
     cc6:	88 0f       	add	r24, r24
     cc8:	99 1f       	adc	r25, r25
     cca:	0a 94       	dec	r0
     ccc:	e2 f7       	brpl	.-8      	; 0xcc6 <MDIO_Error_State_SetPinDirection+0x148>
     cce:	84 2b       	or	r24, r20
     cd0:	8c 93       	st	X, r24
     cd2:	4e c0       	rjmp	.+156    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     cd4:	8c 81       	ldd	r24, Y+4	; 0x04
     cd6:	88 23       	and	r24, r24
     cd8:	a9 f4       	brne	.+42     	; 0xd04 <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
     cda:	a4 e3       	ldi	r26, 0x34	; 52
     cdc:	b0 e0       	ldi	r27, 0x00	; 0
     cde:	e4 e3       	ldi	r30, 0x34	; 52
     ce0:	f0 e0       	ldi	r31, 0x00	; 0
     ce2:	80 81       	ld	r24, Z
     ce4:	48 2f       	mov	r20, r24
     ce6:	8a 81       	ldd	r24, Y+2	; 0x02
     ce8:	28 2f       	mov	r18, r24
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	81 e0       	ldi	r24, 0x01	; 1
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	02 2e       	mov	r0, r18
     cf2:	02 c0       	rjmp	.+4      	; 0xcf8 <MDIO_Error_State_SetPinDirection+0x17a>
     cf4:	88 0f       	add	r24, r24
     cf6:	99 1f       	adc	r25, r25
     cf8:	0a 94       	dec	r0
     cfa:	e2 f7       	brpl	.-8      	; 0xcf4 <MDIO_Error_State_SetPinDirection+0x176>
     cfc:	80 95       	com	r24
     cfe:	84 23       	and	r24, r20
     d00:	8c 93       	st	X, r24
     d02:	36 c0       	rjmp	.+108    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     d04:	19 82       	std	Y+1, r1	; 0x01
     d06:	34 c0       	rjmp	.+104    	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     d08:	8c 81       	ldd	r24, Y+4	; 0x04
     d0a:	81 30       	cpi	r24, 0x01	; 1
     d0c:	a1 f4       	brne	.+40     	; 0xd36 <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
     d0e:	a1 e3       	ldi	r26, 0x31	; 49
     d10:	b0 e0       	ldi	r27, 0x00	; 0
     d12:	e1 e3       	ldi	r30, 0x31	; 49
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	80 81       	ld	r24, Z
     d18:	48 2f       	mov	r20, r24
     d1a:	8a 81       	ldd	r24, Y+2	; 0x02
     d1c:	28 2f       	mov	r18, r24
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	02 2e       	mov	r0, r18
     d26:	02 c0       	rjmp	.+4      	; 0xd2c <MDIO_Error_State_SetPinDirection+0x1ae>
     d28:	88 0f       	add	r24, r24
     d2a:	99 1f       	adc	r25, r25
     d2c:	0a 94       	dec	r0
     d2e:	e2 f7       	brpl	.-8      	; 0xd28 <MDIO_Error_State_SetPinDirection+0x1aa>
     d30:	84 2b       	or	r24, r20
     d32:	8c 93       	st	X, r24
     d34:	1d c0       	rjmp	.+58     	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     d36:	8c 81       	ldd	r24, Y+4	; 0x04
     d38:	88 23       	and	r24, r24
     d3a:	a9 f4       	brne	.+42     	; 0xd66 <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
     d3c:	a1 e3       	ldi	r26, 0x31	; 49
     d3e:	b0 e0       	ldi	r27, 0x00	; 0
     d40:	e1 e3       	ldi	r30, 0x31	; 49
     d42:	f0 e0       	ldi	r31, 0x00	; 0
     d44:	80 81       	ld	r24, Z
     d46:	48 2f       	mov	r20, r24
     d48:	8a 81       	ldd	r24, Y+2	; 0x02
     d4a:	28 2f       	mov	r18, r24
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	02 2e       	mov	r0, r18
     d54:	02 c0       	rjmp	.+4      	; 0xd5a <MDIO_Error_State_SetPinDirection+0x1dc>
     d56:	88 0f       	add	r24, r24
     d58:	99 1f       	adc	r25, r25
     d5a:	0a 94       	dec	r0
     d5c:	e2 f7       	brpl	.-8      	; 0xd56 <MDIO_Error_State_SetPinDirection+0x1d8>
     d5e:	80 95       	com	r24
     d60:	84 23       	and	r24, r20
     d62:	8c 93       	st	X, r24
     d64:	05 c0       	rjmp	.+10     	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     d66:	19 82       	std	Y+1, r1	; 0x01
     d68:	03 c0       	rjmp	.+6      	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
     d6a:	19 82       	std	Y+1, r1	; 0x01
     d6c:	01 c0       	rjmp	.+2      	; 0xd70 <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
     d6e:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
     d70:	89 81       	ldd	r24, Y+1	; 0x01
}
     d72:	26 96       	adiw	r28, 0x06	; 6
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	de bf       	out	0x3e, r29	; 62
     d7a:	0f be       	out	0x3f, r0	; 63
     d7c:	cd bf       	out	0x3d, r28	; 61
     d7e:	cf 91       	pop	r28
     d80:	df 91       	pop	r29
     d82:	08 95       	ret

00000d84 <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
     d84:	df 93       	push	r29
     d86:	cf 93       	push	r28
     d88:	00 d0       	rcall	.+0      	; 0xd8a <MDIO_Error_State_SetPortDirection+0x6>
     d8a:	00 d0       	rcall	.+0      	; 0xd8c <MDIO_Error_State_SetPortDirection+0x8>
     d8c:	0f 92       	push	r0
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
     d92:	8a 83       	std	Y+2, r24	; 0x02
     d94:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
     d9a:	8b 81       	ldd	r24, Y+3	; 0x03
     d9c:	8f 3f       	cpi	r24, 0xFF	; 255
     d9e:	19 f0       	breq	.+6      	; 0xda6 <MDIO_Error_State_SetPortDirection+0x22>
     da0:	8b 81       	ldd	r24, Y+3	; 0x03
     da2:	88 23       	and	r24, r24
     da4:	a9 f5       	brne	.+106    	; 0xe10 <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
     da6:	8a 81       	ldd	r24, Y+2	; 0x02
     da8:	28 2f       	mov	r18, r24
     daa:	30 e0       	ldi	r19, 0x00	; 0
     dac:	3d 83       	std	Y+5, r19	; 0x05
     dae:	2c 83       	std	Y+4, r18	; 0x04
     db0:	8c 81       	ldd	r24, Y+4	; 0x04
     db2:	9d 81       	ldd	r25, Y+5	; 0x05
     db4:	81 30       	cpi	r24, 0x01	; 1
     db6:	91 05       	cpc	r25, r1
     db8:	d1 f0       	breq	.+52     	; 0xdee <MDIO_Error_State_SetPortDirection+0x6a>
     dba:	2c 81       	ldd	r18, Y+4	; 0x04
     dbc:	3d 81       	ldd	r19, Y+5	; 0x05
     dbe:	22 30       	cpi	r18, 0x02	; 2
     dc0:	31 05       	cpc	r19, r1
     dc2:	2c f4       	brge	.+10     	; 0xdce <MDIO_Error_State_SetPortDirection+0x4a>
     dc4:	8c 81       	ldd	r24, Y+4	; 0x04
     dc6:	9d 81       	ldd	r25, Y+5	; 0x05
     dc8:	00 97       	sbiw	r24, 0x00	; 0
     dca:	61 f0       	breq	.+24     	; 0xde4 <MDIO_Error_State_SetPortDirection+0x60>
     dcc:	1f c0       	rjmp	.+62     	; 0xe0c <MDIO_Error_State_SetPortDirection+0x88>
     dce:	2c 81       	ldd	r18, Y+4	; 0x04
     dd0:	3d 81       	ldd	r19, Y+5	; 0x05
     dd2:	22 30       	cpi	r18, 0x02	; 2
     dd4:	31 05       	cpc	r19, r1
     dd6:	81 f0       	breq	.+32     	; 0xdf8 <MDIO_Error_State_SetPortDirection+0x74>
     dd8:	8c 81       	ldd	r24, Y+4	; 0x04
     dda:	9d 81       	ldd	r25, Y+5	; 0x05
     ddc:	83 30       	cpi	r24, 0x03	; 3
     dde:	91 05       	cpc	r25, r1
     de0:	81 f0       	breq	.+32     	; 0xe02 <MDIO_Error_State_SetPortDirection+0x7e>
     de2:	14 c0       	rjmp	.+40     	; 0xe0c <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
     de4:	ea e3       	ldi	r30, 0x3A	; 58
     de6:	f0 e0       	ldi	r31, 0x00	; 0
     de8:	8b 81       	ldd	r24, Y+3	; 0x03
     dea:	80 83       	st	Z, r24
     dec:	12 c0       	rjmp	.+36     	; 0xe12 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
     dee:	e7 e3       	ldi	r30, 0x37	; 55
     df0:	f0 e0       	ldi	r31, 0x00	; 0
     df2:	8b 81       	ldd	r24, Y+3	; 0x03
     df4:	80 83       	st	Z, r24
     df6:	0d c0       	rjmp	.+26     	; 0xe12 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
     df8:	e4 e3       	ldi	r30, 0x34	; 52
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	8b 81       	ldd	r24, Y+3	; 0x03
     dfe:	80 83       	st	Z, r24
     e00:	08 c0       	rjmp	.+16     	; 0xe12 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
     e02:	e1 e3       	ldi	r30, 0x31	; 49
     e04:	f0 e0       	ldi	r31, 0x00	; 0
     e06:	8b 81       	ldd	r24, Y+3	; 0x03
     e08:	80 83       	st	Z, r24
     e0a:	03 c0       	rjmp	.+6      	; 0xe12 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
     e0c:	19 82       	std	Y+1, r1	; 0x01
     e0e:	01 c0       	rjmp	.+2      	; 0xe12 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
     e10:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
     e12:	89 81       	ldd	r24, Y+1	; 0x01
}
     e14:	0f 90       	pop	r0
     e16:	0f 90       	pop	r0
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	0f 90       	pop	r0
     e1e:	cf 91       	pop	r28
     e20:	df 91       	pop	r29
     e22:	08 95       	ret

00000e24 <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
     e24:	df 93       	push	r29
     e26:	cf 93       	push	r28
     e28:	00 d0       	rcall	.+0      	; 0xe2a <MDIO_Error_State_SetPinValue+0x6>
     e2a:	00 d0       	rcall	.+0      	; 0xe2c <MDIO_Error_State_SetPinValue+0x8>
     e2c:	00 d0       	rcall	.+0      	; 0xe2e <MDIO_Error_State_SetPinValue+0xa>
     e2e:	cd b7       	in	r28, 0x3d	; 61
     e30:	de b7       	in	r29, 0x3e	; 62
     e32:	8a 83       	std	Y+2, r24	; 0x02
     e34:	6b 83       	std	Y+3, r22	; 0x03
     e36:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
     e38:	81 e0       	ldi	r24, 0x01	; 1
     e3a:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     e3c:	8a 81       	ldd	r24, Y+2	; 0x02
     e3e:	88 30       	cpi	r24, 0x08	; 8
     e40:	08 f0       	brcs	.+2      	; 0xe44 <MDIO_Error_State_SetPinValue+0x20>
     e42:	e8 c0       	rjmp	.+464    	; 0x1014 <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
     e44:	8b 81       	ldd	r24, Y+3	; 0x03
     e46:	28 2f       	mov	r18, r24
     e48:	30 e0       	ldi	r19, 0x00	; 0
     e4a:	3e 83       	std	Y+6, r19	; 0x06
     e4c:	2d 83       	std	Y+5, r18	; 0x05
     e4e:	8d 81       	ldd	r24, Y+5	; 0x05
     e50:	9e 81       	ldd	r25, Y+6	; 0x06
     e52:	81 30       	cpi	r24, 0x01	; 1
     e54:	91 05       	cpc	r25, r1
     e56:	09 f4       	brne	.+2      	; 0xe5a <MDIO_Error_State_SetPinValue+0x36>
     e58:	48 c0       	rjmp	.+144    	; 0xeea <MDIO_Error_State_SetPinValue+0xc6>
     e5a:	2d 81       	ldd	r18, Y+5	; 0x05
     e5c:	3e 81       	ldd	r19, Y+6	; 0x06
     e5e:	22 30       	cpi	r18, 0x02	; 2
     e60:	31 05       	cpc	r19, r1
     e62:	2c f4       	brge	.+10     	; 0xe6e <MDIO_Error_State_SetPinValue+0x4a>
     e64:	8d 81       	ldd	r24, Y+5	; 0x05
     e66:	9e 81       	ldd	r25, Y+6	; 0x06
     e68:	00 97       	sbiw	r24, 0x00	; 0
     e6a:	71 f0       	breq	.+28     	; 0xe88 <MDIO_Error_State_SetPinValue+0x64>
     e6c:	d1 c0       	rjmp	.+418    	; 0x1010 <MDIO_Error_State_SetPinValue+0x1ec>
     e6e:	2d 81       	ldd	r18, Y+5	; 0x05
     e70:	3e 81       	ldd	r19, Y+6	; 0x06
     e72:	22 30       	cpi	r18, 0x02	; 2
     e74:	31 05       	cpc	r19, r1
     e76:	09 f4       	brne	.+2      	; 0xe7a <MDIO_Error_State_SetPinValue+0x56>
     e78:	69 c0       	rjmp	.+210    	; 0xf4c <MDIO_Error_State_SetPinValue+0x128>
     e7a:	8d 81       	ldd	r24, Y+5	; 0x05
     e7c:	9e 81       	ldd	r25, Y+6	; 0x06
     e7e:	83 30       	cpi	r24, 0x03	; 3
     e80:	91 05       	cpc	r25, r1
     e82:	09 f4       	brne	.+2      	; 0xe86 <MDIO_Error_State_SetPinValue+0x62>
     e84:	94 c0       	rjmp	.+296    	; 0xfae <MDIO_Error_State_SetPinValue+0x18a>
     e86:	c4 c0       	rjmp	.+392    	; 0x1010 <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
     e88:	8c 81       	ldd	r24, Y+4	; 0x04
     e8a:	81 30       	cpi	r24, 0x01	; 1
     e8c:	a1 f4       	brne	.+40     	; 0xeb6 <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
     e8e:	ab e3       	ldi	r26, 0x3B	; 59
     e90:	b0 e0       	ldi	r27, 0x00	; 0
     e92:	eb e3       	ldi	r30, 0x3B	; 59
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	80 81       	ld	r24, Z
     e98:	48 2f       	mov	r20, r24
     e9a:	8a 81       	ldd	r24, Y+2	; 0x02
     e9c:	28 2f       	mov	r18, r24
     e9e:	30 e0       	ldi	r19, 0x00	; 0
     ea0:	81 e0       	ldi	r24, 0x01	; 1
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	02 2e       	mov	r0, r18
     ea6:	02 c0       	rjmp	.+4      	; 0xeac <MDIO_Error_State_SetPinValue+0x88>
     ea8:	88 0f       	add	r24, r24
     eaa:	99 1f       	adc	r25, r25
     eac:	0a 94       	dec	r0
     eae:	e2 f7       	brpl	.-8      	; 0xea8 <MDIO_Error_State_SetPinValue+0x84>
     eb0:	84 2b       	or	r24, r20
     eb2:	8c 93       	st	X, r24
     eb4:	b0 c0       	rjmp	.+352    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
     eb6:	8c 81       	ldd	r24, Y+4	; 0x04
     eb8:	88 23       	and	r24, r24
     eba:	a9 f4       	brne	.+42     	; 0xee6 <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
     ebc:	ab e3       	ldi	r26, 0x3B	; 59
     ebe:	b0 e0       	ldi	r27, 0x00	; 0
     ec0:	eb e3       	ldi	r30, 0x3B	; 59
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	80 81       	ld	r24, Z
     ec6:	48 2f       	mov	r20, r24
     ec8:	8a 81       	ldd	r24, Y+2	; 0x02
     eca:	28 2f       	mov	r18, r24
     ecc:	30 e0       	ldi	r19, 0x00	; 0
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	02 2e       	mov	r0, r18
     ed4:	02 c0       	rjmp	.+4      	; 0xeda <MDIO_Error_State_SetPinValue+0xb6>
     ed6:	88 0f       	add	r24, r24
     ed8:	99 1f       	adc	r25, r25
     eda:	0a 94       	dec	r0
     edc:	e2 f7       	brpl	.-8      	; 0xed6 <MDIO_Error_State_SetPinValue+0xb2>
     ede:	80 95       	com	r24
     ee0:	84 23       	and	r24, r20
     ee2:	8c 93       	st	X, r24
     ee4:	98 c0       	rjmp	.+304    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     ee6:	19 82       	std	Y+1, r1	; 0x01
     ee8:	96 c0       	rjmp	.+300    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
     eea:	8c 81       	ldd	r24, Y+4	; 0x04
     eec:	81 30       	cpi	r24, 0x01	; 1
     eee:	a1 f4       	brne	.+40     	; 0xf18 <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
     ef0:	a8 e3       	ldi	r26, 0x38	; 56
     ef2:	b0 e0       	ldi	r27, 0x00	; 0
     ef4:	e8 e3       	ldi	r30, 0x38	; 56
     ef6:	f0 e0       	ldi	r31, 0x00	; 0
     ef8:	80 81       	ld	r24, Z
     efa:	48 2f       	mov	r20, r24
     efc:	8a 81       	ldd	r24, Y+2	; 0x02
     efe:	28 2f       	mov	r18, r24
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	02 2e       	mov	r0, r18
     f08:	02 c0       	rjmp	.+4      	; 0xf0e <MDIO_Error_State_SetPinValue+0xea>
     f0a:	88 0f       	add	r24, r24
     f0c:	99 1f       	adc	r25, r25
     f0e:	0a 94       	dec	r0
     f10:	e2 f7       	brpl	.-8      	; 0xf0a <MDIO_Error_State_SetPinValue+0xe6>
     f12:	84 2b       	or	r24, r20
     f14:	8c 93       	st	X, r24
     f16:	7f c0       	rjmp	.+254    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
     f18:	8c 81       	ldd	r24, Y+4	; 0x04
     f1a:	88 23       	and	r24, r24
     f1c:	a9 f4       	brne	.+42     	; 0xf48 <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
     f1e:	a8 e3       	ldi	r26, 0x38	; 56
     f20:	b0 e0       	ldi	r27, 0x00	; 0
     f22:	e8 e3       	ldi	r30, 0x38	; 56
     f24:	f0 e0       	ldi	r31, 0x00	; 0
     f26:	80 81       	ld	r24, Z
     f28:	48 2f       	mov	r20, r24
     f2a:	8a 81       	ldd	r24, Y+2	; 0x02
     f2c:	28 2f       	mov	r18, r24
     f2e:	30 e0       	ldi	r19, 0x00	; 0
     f30:	81 e0       	ldi	r24, 0x01	; 1
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	02 2e       	mov	r0, r18
     f36:	02 c0       	rjmp	.+4      	; 0xf3c <MDIO_Error_State_SetPinValue+0x118>
     f38:	88 0f       	add	r24, r24
     f3a:	99 1f       	adc	r25, r25
     f3c:	0a 94       	dec	r0
     f3e:	e2 f7       	brpl	.-8      	; 0xf38 <MDIO_Error_State_SetPinValue+0x114>
     f40:	80 95       	com	r24
     f42:	84 23       	and	r24, r20
     f44:	8c 93       	st	X, r24
     f46:	67 c0       	rjmp	.+206    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     f48:	19 82       	std	Y+1, r1	; 0x01
     f4a:	65 c0       	rjmp	.+202    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
     f4c:	8c 81       	ldd	r24, Y+4	; 0x04
     f4e:	81 30       	cpi	r24, 0x01	; 1
     f50:	a1 f4       	brne	.+40     	; 0xf7a <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
     f52:	a5 e3       	ldi	r26, 0x35	; 53
     f54:	b0 e0       	ldi	r27, 0x00	; 0
     f56:	e5 e3       	ldi	r30, 0x35	; 53
     f58:	f0 e0       	ldi	r31, 0x00	; 0
     f5a:	80 81       	ld	r24, Z
     f5c:	48 2f       	mov	r20, r24
     f5e:	8a 81       	ldd	r24, Y+2	; 0x02
     f60:	28 2f       	mov	r18, r24
     f62:	30 e0       	ldi	r19, 0x00	; 0
     f64:	81 e0       	ldi	r24, 0x01	; 1
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	02 2e       	mov	r0, r18
     f6a:	02 c0       	rjmp	.+4      	; 0xf70 <MDIO_Error_State_SetPinValue+0x14c>
     f6c:	88 0f       	add	r24, r24
     f6e:	99 1f       	adc	r25, r25
     f70:	0a 94       	dec	r0
     f72:	e2 f7       	brpl	.-8      	; 0xf6c <MDIO_Error_State_SetPinValue+0x148>
     f74:	84 2b       	or	r24, r20
     f76:	8c 93       	st	X, r24
     f78:	4e c0       	rjmp	.+156    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
     f7a:	8c 81       	ldd	r24, Y+4	; 0x04
     f7c:	88 23       	and	r24, r24
     f7e:	a9 f4       	brne	.+42     	; 0xfaa <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
     f80:	a5 e3       	ldi	r26, 0x35	; 53
     f82:	b0 e0       	ldi	r27, 0x00	; 0
     f84:	e5 e3       	ldi	r30, 0x35	; 53
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	80 81       	ld	r24, Z
     f8a:	48 2f       	mov	r20, r24
     f8c:	8a 81       	ldd	r24, Y+2	; 0x02
     f8e:	28 2f       	mov	r18, r24
     f90:	30 e0       	ldi	r19, 0x00	; 0
     f92:	81 e0       	ldi	r24, 0x01	; 1
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	02 2e       	mov	r0, r18
     f98:	02 c0       	rjmp	.+4      	; 0xf9e <MDIO_Error_State_SetPinValue+0x17a>
     f9a:	88 0f       	add	r24, r24
     f9c:	99 1f       	adc	r25, r25
     f9e:	0a 94       	dec	r0
     fa0:	e2 f7       	brpl	.-8      	; 0xf9a <MDIO_Error_State_SetPinValue+0x176>
     fa2:	80 95       	com	r24
     fa4:	84 23       	and	r24, r20
     fa6:	8c 93       	st	X, r24
     fa8:	36 c0       	rjmp	.+108    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     faa:	19 82       	std	Y+1, r1	; 0x01
     fac:	34 c0       	rjmp	.+104    	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
     fae:	8c 81       	ldd	r24, Y+4	; 0x04
     fb0:	81 30       	cpi	r24, 0x01	; 1
     fb2:	a1 f4       	brne	.+40     	; 0xfdc <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
     fb4:	a2 e3       	ldi	r26, 0x32	; 50
     fb6:	b0 e0       	ldi	r27, 0x00	; 0
     fb8:	e2 e3       	ldi	r30, 0x32	; 50
     fba:	f0 e0       	ldi	r31, 0x00	; 0
     fbc:	80 81       	ld	r24, Z
     fbe:	48 2f       	mov	r20, r24
     fc0:	8a 81       	ldd	r24, Y+2	; 0x02
     fc2:	28 2f       	mov	r18, r24
     fc4:	30 e0       	ldi	r19, 0x00	; 0
     fc6:	81 e0       	ldi	r24, 0x01	; 1
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	02 2e       	mov	r0, r18
     fcc:	02 c0       	rjmp	.+4      	; 0xfd2 <MDIO_Error_State_SetPinValue+0x1ae>
     fce:	88 0f       	add	r24, r24
     fd0:	99 1f       	adc	r25, r25
     fd2:	0a 94       	dec	r0
     fd4:	e2 f7       	brpl	.-8      	; 0xfce <MDIO_Error_State_SetPinValue+0x1aa>
     fd6:	84 2b       	or	r24, r20
     fd8:	8c 93       	st	X, r24
     fda:	1d c0       	rjmp	.+58     	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
     fdc:	8c 81       	ldd	r24, Y+4	; 0x04
     fde:	88 23       	and	r24, r24
     fe0:	a9 f4       	brne	.+42     	; 0x100c <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
     fe2:	a2 e3       	ldi	r26, 0x32	; 50
     fe4:	b0 e0       	ldi	r27, 0x00	; 0
     fe6:	e2 e3       	ldi	r30, 0x32	; 50
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	80 81       	ld	r24, Z
     fec:	48 2f       	mov	r20, r24
     fee:	8a 81       	ldd	r24, Y+2	; 0x02
     ff0:	28 2f       	mov	r18, r24
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	81 e0       	ldi	r24, 0x01	; 1
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	02 2e       	mov	r0, r18
     ffa:	02 c0       	rjmp	.+4      	; 0x1000 <MDIO_Error_State_SetPinValue+0x1dc>
     ffc:	88 0f       	add	r24, r24
     ffe:	99 1f       	adc	r25, r25
    1000:	0a 94       	dec	r0
    1002:	e2 f7       	brpl	.-8      	; 0xffc <MDIO_Error_State_SetPinValue+0x1d8>
    1004:	80 95       	com	r24
    1006:	84 23       	and	r24, r20
    1008:	8c 93       	st	X, r24
    100a:	05 c0       	rjmp	.+10     	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    100c:	19 82       	std	Y+1, r1	; 0x01
    100e:	03 c0       	rjmp	.+6      	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1010:	19 82       	std	Y+1, r1	; 0x01
    1012:	01 c0       	rjmp	.+2      	; 0x1016 <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1014:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1016:	89 81       	ldd	r24, Y+1	; 0x01
}
    1018:	26 96       	adiw	r28, 0x06	; 6
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	cf 91       	pop	r28
    1026:	df 91       	pop	r29
    1028:	08 95       	ret

0000102a <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    102a:	df 93       	push	r29
    102c:	cf 93       	push	r28
    102e:	00 d0       	rcall	.+0      	; 0x1030 <MDIO_Error_State_SetPortValue+0x6>
    1030:	00 d0       	rcall	.+0      	; 0x1032 <MDIO_Error_State_SetPortValue+0x8>
    1032:	0f 92       	push	r0
    1034:	cd b7       	in	r28, 0x3d	; 61
    1036:	de b7       	in	r29, 0x3e	; 62
    1038:	8a 83       	std	Y+2, r24	; 0x02
    103a:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    1040:	8a 81       	ldd	r24, Y+2	; 0x02
    1042:	28 2f       	mov	r18, r24
    1044:	30 e0       	ldi	r19, 0x00	; 0
    1046:	3d 83       	std	Y+5, r19	; 0x05
    1048:	2c 83       	std	Y+4, r18	; 0x04
    104a:	8c 81       	ldd	r24, Y+4	; 0x04
    104c:	9d 81       	ldd	r25, Y+5	; 0x05
    104e:	81 30       	cpi	r24, 0x01	; 1
    1050:	91 05       	cpc	r25, r1
    1052:	d1 f0       	breq	.+52     	; 0x1088 <MDIO_Error_State_SetPortValue+0x5e>
    1054:	2c 81       	ldd	r18, Y+4	; 0x04
    1056:	3d 81       	ldd	r19, Y+5	; 0x05
    1058:	22 30       	cpi	r18, 0x02	; 2
    105a:	31 05       	cpc	r19, r1
    105c:	2c f4       	brge	.+10     	; 0x1068 <MDIO_Error_State_SetPortValue+0x3e>
    105e:	8c 81       	ldd	r24, Y+4	; 0x04
    1060:	9d 81       	ldd	r25, Y+5	; 0x05
    1062:	00 97       	sbiw	r24, 0x00	; 0
    1064:	61 f0       	breq	.+24     	; 0x107e <MDIO_Error_State_SetPortValue+0x54>
    1066:	1f c0       	rjmp	.+62     	; 0x10a6 <MDIO_Error_State_SetPortValue+0x7c>
    1068:	2c 81       	ldd	r18, Y+4	; 0x04
    106a:	3d 81       	ldd	r19, Y+5	; 0x05
    106c:	22 30       	cpi	r18, 0x02	; 2
    106e:	31 05       	cpc	r19, r1
    1070:	81 f0       	breq	.+32     	; 0x1092 <MDIO_Error_State_SetPortValue+0x68>
    1072:	8c 81       	ldd	r24, Y+4	; 0x04
    1074:	9d 81       	ldd	r25, Y+5	; 0x05
    1076:	83 30       	cpi	r24, 0x03	; 3
    1078:	91 05       	cpc	r25, r1
    107a:	81 f0       	breq	.+32     	; 0x109c <MDIO_Error_State_SetPortValue+0x72>
    107c:	14 c0       	rjmp	.+40     	; 0x10a6 <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    107e:	eb e3       	ldi	r30, 0x3B	; 59
    1080:	f0 e0       	ldi	r31, 0x00	; 0
    1082:	8b 81       	ldd	r24, Y+3	; 0x03
    1084:	80 83       	st	Z, r24
    1086:	10 c0       	rjmp	.+32     	; 0x10a8 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    1088:	e8 e3       	ldi	r30, 0x38	; 56
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	8b 81       	ldd	r24, Y+3	; 0x03
    108e:	80 83       	st	Z, r24
    1090:	0b c0       	rjmp	.+22     	; 0x10a8 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    1092:	e5 e3       	ldi	r30, 0x35	; 53
    1094:	f0 e0       	ldi	r31, 0x00	; 0
    1096:	8b 81       	ldd	r24, Y+3	; 0x03
    1098:	80 83       	st	Z, r24
    109a:	06 c0       	rjmp	.+12     	; 0x10a8 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    109c:	e2 e3       	ldi	r30, 0x32	; 50
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	8b 81       	ldd	r24, Y+3	; 0x03
    10a2:	80 83       	st	Z, r24
    10a4:	01 c0       	rjmp	.+2      	; 0x10a8 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    10a6:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    10aa:	0f 90       	pop	r0
    10ac:	0f 90       	pop	r0
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	cf 91       	pop	r28
    10b6:	df 91       	pop	r29
    10b8:	08 95       	ret

000010ba <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    10ba:	df 93       	push	r29
    10bc:	cf 93       	push	r28
    10be:	cd b7       	in	r28, 0x3d	; 61
    10c0:	de b7       	in	r29, 0x3e	; 62
    10c2:	27 97       	sbiw	r28, 0x07	; 7
    10c4:	0f b6       	in	r0, 0x3f	; 63
    10c6:	f8 94       	cli
    10c8:	de bf       	out	0x3e, r29	; 62
    10ca:	0f be       	out	0x3f, r0	; 63
    10cc:	cd bf       	out	0x3d, r28	; 61
    10ce:	8a 83       	std	Y+2, r24	; 0x02
    10d0:	6b 83       	std	Y+3, r22	; 0x03
    10d2:	5d 83       	std	Y+5, r21	; 0x05
    10d4:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    10d6:	81 e0       	ldi	r24, 0x01	; 1
    10d8:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    10da:	8a 81       	ldd	r24, Y+2	; 0x02
    10dc:	88 30       	cpi	r24, 0x08	; 8
    10de:	08 f0       	brcs	.+2      	; 0x10e2 <MDIO_Error_State_GetPinValue+0x28>
    10e0:	79 c0       	rjmp	.+242    	; 0x11d4 <MDIO_Error_State_GetPinValue+0x11a>
    10e2:	8c 81       	ldd	r24, Y+4	; 0x04
    10e4:	9d 81       	ldd	r25, Y+5	; 0x05
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	91 05       	cpc	r25, r1
    10ea:	09 f4       	brne	.+2      	; 0x10ee <MDIO_Error_State_GetPinValue+0x34>
    10ec:	73 c0       	rjmp	.+230    	; 0x11d4 <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    10ee:	8b 81       	ldd	r24, Y+3	; 0x03
    10f0:	28 2f       	mov	r18, r24
    10f2:	30 e0       	ldi	r19, 0x00	; 0
    10f4:	3f 83       	std	Y+7, r19	; 0x07
    10f6:	2e 83       	std	Y+6, r18	; 0x06
    10f8:	4e 81       	ldd	r20, Y+6	; 0x06
    10fa:	5f 81       	ldd	r21, Y+7	; 0x07
    10fc:	41 30       	cpi	r20, 0x01	; 1
    10fe:	51 05       	cpc	r21, r1
    1100:	59 f1       	breq	.+86     	; 0x1158 <MDIO_Error_State_GetPinValue+0x9e>
    1102:	8e 81       	ldd	r24, Y+6	; 0x06
    1104:	9f 81       	ldd	r25, Y+7	; 0x07
    1106:	82 30       	cpi	r24, 0x02	; 2
    1108:	91 05       	cpc	r25, r1
    110a:	34 f4       	brge	.+12     	; 0x1118 <MDIO_Error_State_GetPinValue+0x5e>
    110c:	2e 81       	ldd	r18, Y+6	; 0x06
    110e:	3f 81       	ldd	r19, Y+7	; 0x07
    1110:	21 15       	cp	r18, r1
    1112:	31 05       	cpc	r19, r1
    1114:	69 f0       	breq	.+26     	; 0x1130 <MDIO_Error_State_GetPinValue+0x76>
    1116:	5c c0       	rjmp	.+184    	; 0x11d0 <MDIO_Error_State_GetPinValue+0x116>
    1118:	4e 81       	ldd	r20, Y+6	; 0x06
    111a:	5f 81       	ldd	r21, Y+7	; 0x07
    111c:	42 30       	cpi	r20, 0x02	; 2
    111e:	51 05       	cpc	r21, r1
    1120:	79 f1       	breq	.+94     	; 0x1180 <MDIO_Error_State_GetPinValue+0xc6>
    1122:	8e 81       	ldd	r24, Y+6	; 0x06
    1124:	9f 81       	ldd	r25, Y+7	; 0x07
    1126:	83 30       	cpi	r24, 0x03	; 3
    1128:	91 05       	cpc	r25, r1
    112a:	09 f4       	brne	.+2      	; 0x112e <MDIO_Error_State_GetPinValue+0x74>
    112c:	3d c0       	rjmp	.+122    	; 0x11a8 <MDIO_Error_State_GetPinValue+0xee>
    112e:	50 c0       	rjmp	.+160    	; 0x11d0 <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    1130:	e9 e3       	ldi	r30, 0x39	; 57
    1132:	f0 e0       	ldi	r31, 0x00	; 0
    1134:	80 81       	ld	r24, Z
    1136:	28 2f       	mov	r18, r24
    1138:	30 e0       	ldi	r19, 0x00	; 0
    113a:	8a 81       	ldd	r24, Y+2	; 0x02
    113c:	88 2f       	mov	r24, r24
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	a9 01       	movw	r20, r18
    1142:	02 c0       	rjmp	.+4      	; 0x1148 <MDIO_Error_State_GetPinValue+0x8e>
    1144:	55 95       	asr	r21
    1146:	47 95       	ror	r20
    1148:	8a 95       	dec	r24
    114a:	e2 f7       	brpl	.-8      	; 0x1144 <MDIO_Error_State_GetPinValue+0x8a>
    114c:	ca 01       	movw	r24, r20
    114e:	81 70       	andi	r24, 0x01	; 1
    1150:	ec 81       	ldd	r30, Y+4	; 0x04
    1152:	fd 81       	ldd	r31, Y+5	; 0x05
    1154:	80 83       	st	Z, r24
    1156:	3f c0       	rjmp	.+126    	; 0x11d6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    1158:	e6 e3       	ldi	r30, 0x36	; 54
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	80 81       	ld	r24, Z
    115e:	28 2f       	mov	r18, r24
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	8a 81       	ldd	r24, Y+2	; 0x02
    1164:	88 2f       	mov	r24, r24
    1166:	90 e0       	ldi	r25, 0x00	; 0
    1168:	a9 01       	movw	r20, r18
    116a:	02 c0       	rjmp	.+4      	; 0x1170 <MDIO_Error_State_GetPinValue+0xb6>
    116c:	55 95       	asr	r21
    116e:	47 95       	ror	r20
    1170:	8a 95       	dec	r24
    1172:	e2 f7       	brpl	.-8      	; 0x116c <MDIO_Error_State_GetPinValue+0xb2>
    1174:	ca 01       	movw	r24, r20
    1176:	81 70       	andi	r24, 0x01	; 1
    1178:	ec 81       	ldd	r30, Y+4	; 0x04
    117a:	fd 81       	ldd	r31, Y+5	; 0x05
    117c:	80 83       	st	Z, r24
    117e:	2b c0       	rjmp	.+86     	; 0x11d6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    1180:	e3 e3       	ldi	r30, 0x33	; 51
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	80 81       	ld	r24, Z
    1186:	28 2f       	mov	r18, r24
    1188:	30 e0       	ldi	r19, 0x00	; 0
    118a:	8a 81       	ldd	r24, Y+2	; 0x02
    118c:	88 2f       	mov	r24, r24
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	a9 01       	movw	r20, r18
    1192:	02 c0       	rjmp	.+4      	; 0x1198 <MDIO_Error_State_GetPinValue+0xde>
    1194:	55 95       	asr	r21
    1196:	47 95       	ror	r20
    1198:	8a 95       	dec	r24
    119a:	e2 f7       	brpl	.-8      	; 0x1194 <MDIO_Error_State_GetPinValue+0xda>
    119c:	ca 01       	movw	r24, r20
    119e:	81 70       	andi	r24, 0x01	; 1
    11a0:	ec 81       	ldd	r30, Y+4	; 0x04
    11a2:	fd 81       	ldd	r31, Y+5	; 0x05
    11a4:	80 83       	st	Z, r24
    11a6:	17 c0       	rjmp	.+46     	; 0x11d6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    11a8:	e0 e3       	ldi	r30, 0x30	; 48
    11aa:	f0 e0       	ldi	r31, 0x00	; 0
    11ac:	80 81       	ld	r24, Z
    11ae:	28 2f       	mov	r18, r24
    11b0:	30 e0       	ldi	r19, 0x00	; 0
    11b2:	8a 81       	ldd	r24, Y+2	; 0x02
    11b4:	88 2f       	mov	r24, r24
    11b6:	90 e0       	ldi	r25, 0x00	; 0
    11b8:	a9 01       	movw	r20, r18
    11ba:	02 c0       	rjmp	.+4      	; 0x11c0 <MDIO_Error_State_GetPinValue+0x106>
    11bc:	55 95       	asr	r21
    11be:	47 95       	ror	r20
    11c0:	8a 95       	dec	r24
    11c2:	e2 f7       	brpl	.-8      	; 0x11bc <MDIO_Error_State_GetPinValue+0x102>
    11c4:	ca 01       	movw	r24, r20
    11c6:	81 70       	andi	r24, 0x01	; 1
    11c8:	ec 81       	ldd	r30, Y+4	; 0x04
    11ca:	fd 81       	ldd	r31, Y+5	; 0x05
    11cc:	80 83       	st	Z, r24
    11ce:	03 c0       	rjmp	.+6      	; 0x11d6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    11d0:	19 82       	std	Y+1, r1	; 0x01
    11d2:	01 c0       	rjmp	.+2      	; 0x11d6 <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    11d4:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    11d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    11d8:	27 96       	adiw	r28, 0x07	; 7
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	de bf       	out	0x3e, r29	; 62
    11e0:	0f be       	out	0x3f, r0	; 63
    11e2:	cd bf       	out	0x3d, r28	; 61
    11e4:	cf 91       	pop	r28
    11e6:	df 91       	pop	r29
    11e8:	08 95       	ret

000011ea <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    11ea:	df 93       	push	r29
    11ec:	cf 93       	push	r28
    11ee:	00 d0       	rcall	.+0      	; 0x11f0 <MDIO_Error_State_SetNippleValue+0x6>
    11f0:	00 d0       	rcall	.+0      	; 0x11f2 <MDIO_Error_State_SetNippleValue+0x8>
    11f2:	00 d0       	rcall	.+0      	; 0x11f4 <MDIO_Error_State_SetNippleValue+0xa>
    11f4:	cd b7       	in	r28, 0x3d	; 61
    11f6:	de b7       	in	r29, 0x3e	; 62
    11f8:	8a 83       	std	Y+2, r24	; 0x02
    11fa:	6b 83       	std	Y+3, r22	; 0x03
    11fc:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    1202:	8a 81       	ldd	r24, Y+2	; 0x02
    1204:	85 30       	cpi	r24, 0x05	; 5
    1206:	08 f0       	brcs	.+2      	; 0x120a <MDIO_Error_State_SetNippleValue+0x20>
    1208:	97 c0       	rjmp	.+302    	; 0x1338 <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    120a:	8b 81       	ldd	r24, Y+3	; 0x03
    120c:	28 2f       	mov	r18, r24
    120e:	30 e0       	ldi	r19, 0x00	; 0
    1210:	3e 83       	std	Y+6, r19	; 0x06
    1212:	2d 83       	std	Y+5, r18	; 0x05
    1214:	8d 81       	ldd	r24, Y+5	; 0x05
    1216:	9e 81       	ldd	r25, Y+6	; 0x06
    1218:	81 30       	cpi	r24, 0x01	; 1
    121a:	91 05       	cpc	r25, r1
    121c:	a1 f1       	breq	.+104    	; 0x1286 <MDIO_Error_State_SetNippleValue+0x9c>
    121e:	2d 81       	ldd	r18, Y+5	; 0x05
    1220:	3e 81       	ldd	r19, Y+6	; 0x06
    1222:	22 30       	cpi	r18, 0x02	; 2
    1224:	31 05       	cpc	r19, r1
    1226:	2c f4       	brge	.+10     	; 0x1232 <MDIO_Error_State_SetNippleValue+0x48>
    1228:	8d 81       	ldd	r24, Y+5	; 0x05
    122a:	9e 81       	ldd	r25, Y+6	; 0x06
    122c:	00 97       	sbiw	r24, 0x00	; 0
    122e:	71 f0       	breq	.+28     	; 0x124c <MDIO_Error_State_SetNippleValue+0x62>
    1230:	81 c0       	rjmp	.+258    	; 0x1334 <MDIO_Error_State_SetNippleValue+0x14a>
    1232:	2d 81       	ldd	r18, Y+5	; 0x05
    1234:	3e 81       	ldd	r19, Y+6	; 0x06
    1236:	22 30       	cpi	r18, 0x02	; 2
    1238:	31 05       	cpc	r19, r1
    123a:	09 f4       	brne	.+2      	; 0x123e <MDIO_Error_State_SetNippleValue+0x54>
    123c:	41 c0       	rjmp	.+130    	; 0x12c0 <MDIO_Error_State_SetNippleValue+0xd6>
    123e:	8d 81       	ldd	r24, Y+5	; 0x05
    1240:	9e 81       	ldd	r25, Y+6	; 0x06
    1242:	83 30       	cpi	r24, 0x03	; 3
    1244:	91 05       	cpc	r25, r1
    1246:	09 f4       	brne	.+2      	; 0x124a <MDIO_Error_State_SetNippleValue+0x60>
    1248:	58 c0       	rjmp	.+176    	; 0x12fa <MDIO_Error_State_SetNippleValue+0x110>
    124a:	74 c0       	rjmp	.+232    	; 0x1334 <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    124c:	ab e3       	ldi	r26, 0x3B	; 59
    124e:	b0 e0       	ldi	r27, 0x00	; 0
    1250:	eb e3       	ldi	r30, 0x3B	; 59
    1252:	f0 e0       	ldi	r31, 0x00	; 0
    1254:	80 81       	ld	r24, Z
    1256:	48 2f       	mov	r20, r24
    1258:	8a 81       	ldd	r24, Y+2	; 0x02
    125a:	28 2f       	mov	r18, r24
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	8f e0       	ldi	r24, 0x0F	; 15
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	02 2e       	mov	r0, r18
    1264:	02 c0       	rjmp	.+4      	; 0x126a <MDIO_Error_State_SetNippleValue+0x80>
    1266:	88 0f       	add	r24, r24
    1268:	99 1f       	adc	r25, r25
    126a:	0a 94       	dec	r0
    126c:	e2 f7       	brpl	.-8      	; 0x1266 <MDIO_Error_State_SetNippleValue+0x7c>
    126e:	80 95       	com	r24
    1270:	84 23       	and	r24, r20
    1272:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    1274:	ab e3       	ldi	r26, 0x3B	; 59
    1276:	b0 e0       	ldi	r27, 0x00	; 0
    1278:	eb e3       	ldi	r30, 0x3B	; 59
    127a:	f0 e0       	ldi	r31, 0x00	; 0
    127c:	90 81       	ld	r25, Z
    127e:	8c 81       	ldd	r24, Y+4	; 0x04
    1280:	89 2b       	or	r24, r25
    1282:	8c 93       	st	X, r24
    1284:	5a c0       	rjmp	.+180    	; 0x133a <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    1286:	a8 e3       	ldi	r26, 0x38	; 56
    1288:	b0 e0       	ldi	r27, 0x00	; 0
    128a:	e8 e3       	ldi	r30, 0x38	; 56
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	80 81       	ld	r24, Z
    1290:	48 2f       	mov	r20, r24
    1292:	8a 81       	ldd	r24, Y+2	; 0x02
    1294:	28 2f       	mov	r18, r24
    1296:	30 e0       	ldi	r19, 0x00	; 0
    1298:	8f e0       	ldi	r24, 0x0F	; 15
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	02 2e       	mov	r0, r18
    129e:	02 c0       	rjmp	.+4      	; 0x12a4 <MDIO_Error_State_SetNippleValue+0xba>
    12a0:	88 0f       	add	r24, r24
    12a2:	99 1f       	adc	r25, r25
    12a4:	0a 94       	dec	r0
    12a6:	e2 f7       	brpl	.-8      	; 0x12a0 <MDIO_Error_State_SetNippleValue+0xb6>
    12a8:	80 95       	com	r24
    12aa:	84 23       	and	r24, r20
    12ac:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    12ae:	a8 e3       	ldi	r26, 0x38	; 56
    12b0:	b0 e0       	ldi	r27, 0x00	; 0
    12b2:	e8 e3       	ldi	r30, 0x38	; 56
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	90 81       	ld	r25, Z
    12b8:	8c 81       	ldd	r24, Y+4	; 0x04
    12ba:	89 2b       	or	r24, r25
    12bc:	8c 93       	st	X, r24
    12be:	3d c0       	rjmp	.+122    	; 0x133a <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    12c0:	a5 e3       	ldi	r26, 0x35	; 53
    12c2:	b0 e0       	ldi	r27, 0x00	; 0
    12c4:	e5 e3       	ldi	r30, 0x35	; 53
    12c6:	f0 e0       	ldi	r31, 0x00	; 0
    12c8:	80 81       	ld	r24, Z
    12ca:	48 2f       	mov	r20, r24
    12cc:	8a 81       	ldd	r24, Y+2	; 0x02
    12ce:	28 2f       	mov	r18, r24
    12d0:	30 e0       	ldi	r19, 0x00	; 0
    12d2:	8f e0       	ldi	r24, 0x0F	; 15
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	02 2e       	mov	r0, r18
    12d8:	02 c0       	rjmp	.+4      	; 0x12de <MDIO_Error_State_SetNippleValue+0xf4>
    12da:	88 0f       	add	r24, r24
    12dc:	99 1f       	adc	r25, r25
    12de:	0a 94       	dec	r0
    12e0:	e2 f7       	brpl	.-8      	; 0x12da <MDIO_Error_State_SetNippleValue+0xf0>
    12e2:	80 95       	com	r24
    12e4:	84 23       	and	r24, r20
    12e6:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    12e8:	a5 e3       	ldi	r26, 0x35	; 53
    12ea:	b0 e0       	ldi	r27, 0x00	; 0
    12ec:	e5 e3       	ldi	r30, 0x35	; 53
    12ee:	f0 e0       	ldi	r31, 0x00	; 0
    12f0:	90 81       	ld	r25, Z
    12f2:	8c 81       	ldd	r24, Y+4	; 0x04
    12f4:	89 2b       	or	r24, r25
    12f6:	8c 93       	st	X, r24
    12f8:	20 c0       	rjmp	.+64     	; 0x133a <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    12fa:	a2 e3       	ldi	r26, 0x32	; 50
    12fc:	b0 e0       	ldi	r27, 0x00	; 0
    12fe:	e2 e3       	ldi	r30, 0x32	; 50
    1300:	f0 e0       	ldi	r31, 0x00	; 0
    1302:	80 81       	ld	r24, Z
    1304:	48 2f       	mov	r20, r24
    1306:	8a 81       	ldd	r24, Y+2	; 0x02
    1308:	28 2f       	mov	r18, r24
    130a:	30 e0       	ldi	r19, 0x00	; 0
    130c:	8f e0       	ldi	r24, 0x0F	; 15
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	02 2e       	mov	r0, r18
    1312:	02 c0       	rjmp	.+4      	; 0x1318 <MDIO_Error_State_SetNippleValue+0x12e>
    1314:	88 0f       	add	r24, r24
    1316:	99 1f       	adc	r25, r25
    1318:	0a 94       	dec	r0
    131a:	e2 f7       	brpl	.-8      	; 0x1314 <MDIO_Error_State_SetNippleValue+0x12a>
    131c:	80 95       	com	r24
    131e:	84 23       	and	r24, r20
    1320:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    1322:	a2 e3       	ldi	r26, 0x32	; 50
    1324:	b0 e0       	ldi	r27, 0x00	; 0
    1326:	e2 e3       	ldi	r30, 0x32	; 50
    1328:	f0 e0       	ldi	r31, 0x00	; 0
    132a:	90 81       	ld	r25, Z
    132c:	8c 81       	ldd	r24, Y+4	; 0x04
    132e:	89 2b       	or	r24, r25
    1330:	8c 93       	st	X, r24
    1332:	03 c0       	rjmp	.+6      	; 0x133a <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1334:	19 82       	std	Y+1, r1	; 0x01
    1336:	01 c0       	rjmp	.+2      	; 0x133a <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1338:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    133a:	89 81       	ldd	r24, Y+1	; 0x01
}
    133c:	26 96       	adiw	r28, 0x06	; 6
    133e:	0f b6       	in	r0, 0x3f	; 63
    1340:	f8 94       	cli
    1342:	de bf       	out	0x3e, r29	; 62
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	cd bf       	out	0x3d, r28	; 61
    1348:	cf 91       	pop	r28
    134a:	df 91       	pop	r29
    134c:	08 95       	ret

0000134e <MADC_VidInit>:

void (*MADC_CallBack)(void);

/*ADC Initialization*/
void MADC_VidInit(void)
{
    134e:	df 93       	push	r29
    1350:	cf 93       	push	r28
    1352:	cd b7       	in	r28, 0x3d	; 61
    1354:	de b7       	in	r29, 0x3e	; 62
	/*Select Reference Voltage*/
#if MADC_SET_REFERENCEVOLATGE == MADC_AVCC_REFERENCEVOLATGE
	SET_BIT(ADMUX,6);
    1356:	a7 e2       	ldi	r26, 0x27	; 39
    1358:	b0 e0       	ldi	r27, 0x00	; 0
    135a:	e7 e2       	ldi	r30, 0x27	; 39
    135c:	f0 e0       	ldi	r31, 0x00	; 0
    135e:	80 81       	ld	r24, Z
    1360:	80 64       	ori	r24, 0x40	; 64
    1362:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,7);
    1364:	a7 e2       	ldi	r26, 0x27	; 39
    1366:	b0 e0       	ldi	r27, 0x00	; 0
    1368:	e7 e2       	ldi	r30, 0x27	; 39
    136a:	f0 e0       	ldi	r31, 0x00	; 0
    136c:	80 81       	ld	r24, Z
    136e:	8f 77       	andi	r24, 0x7F	; 127
    1370:	8c 93       	st	X, r24
	SET_BIT(ADMUX,7);
#else
#error"ADC Reference Voltage Option I s not valid.... "
#endif
/*Set Prescaler*/
ADCSRA&=MADC_BIT_MASKING_PRESCALER;
    1372:	a6 e2       	ldi	r26, 0x26	; 38
    1374:	b0 e0       	ldi	r27, 0x00	; 0
    1376:	e6 e2       	ldi	r30, 0x26	; 38
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	80 81       	ld	r24, Z
    137c:	88 7f       	andi	r24, 0xF8	; 248
    137e:	8c 93       	st	X, r24
ADCSRA|=MADC_SET_PRESCALER;
    1380:	a6 e2       	ldi	r26, 0x26	; 38
    1382:	b0 e0       	ldi	r27, 0x00	; 0
    1384:	e6 e2       	ldi	r30, 0x26	; 38
    1386:	f0 e0       	ldi	r31, 0x00	; 0
    1388:	80 81       	ld	r24, Z
    138a:	87 60       	ori	r24, 0x07	; 7
    138c:	8c 93       	st	X, r24

#if MADC_SET_ADJUST == MADC_LEFT_ADJUST
	SET_BIT(ADMUX,5);
#elif MADC_SET_ADJUST == MADC_RIGHT_ADJUST
	CLR_BIT(ADMUX,5);
    138e:	a7 e2       	ldi	r26, 0x27	; 39
    1390:	b0 e0       	ldi	r27, 0x00	; 0
    1392:	e7 e2       	ldi	r30, 0x27	; 39
    1394:	f0 e0       	ldi	r31, 0x00	; 0
    1396:	80 81       	ld	r24, Z
    1398:	8f 7d       	andi	r24, 0xDF	; 223
    139a:	8c 93       	st	X, r24
#else
#error"ADC Left adjust option is not valid...."
#endif
/*Enable To ADC*/
SET_BIT(ADCSRA,7);
    139c:	a6 e2       	ldi	r26, 0x26	; 38
    139e:	b0 e0       	ldi	r27, 0x00	; 0
    13a0:	e6 e2       	ldi	r30, 0x26	; 38
    13a2:	f0 e0       	ldi	r31, 0x00	; 0
    13a4:	80 81       	ld	r24, Z
    13a6:	80 68       	ori	r24, 0x80	; 128
    13a8:	8c 93       	st	X, r24
}
    13aa:	cf 91       	pop	r28
    13ac:	df 91       	pop	r29
    13ae:	08 95       	ret

000013b0 <MADC_VidADCInterruptEnable>:
void MADC_VidADCInterruptEnable(void)
{
    13b0:	df 93       	push	r29
    13b2:	cf 93       	push	r28
    13b4:	cd b7       	in	r28, 0x3d	; 61
    13b6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,3);
    13b8:	a6 e2       	ldi	r26, 0x26	; 38
    13ba:	b0 e0       	ldi	r27, 0x00	; 0
    13bc:	e6 e2       	ldi	r30, 0x26	; 38
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	80 81       	ld	r24, Z
    13c2:	88 60       	ori	r24, 0x08	; 8
    13c4:	8c 93       	st	X, r24
}
    13c6:	cf 91       	pop	r28
    13c8:	df 91       	pop	r29
    13ca:	08 95       	ret

000013cc <MADC_u16ADC_StartConversion>:
/*ADC Start Conversion-->Polling , Return ADC Value*/
u16 MADC_u16ADC_StartConversion(u8 Copy_u8Channel)
{
    13cc:	df 93       	push	r29
    13ce:	cf 93       	push	r28
    13d0:	0f 92       	push	r0
    13d2:	cd b7       	in	r28, 0x3d	; 61
    13d4:	de b7       	in	r29, 0x3e	; 62
    13d6:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
    13da:	87 70       	andi	r24, 0x07	; 7
    13dc:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    13de:	a7 e2       	ldi	r26, 0x27	; 39
    13e0:	b0 e0       	ldi	r27, 0x00	; 0
    13e2:	e7 e2       	ldi	r30, 0x27	; 39
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	80 81       	ld	r24, Z
    13e8:	80 7e       	andi	r24, 0xE0	; 224
    13ea:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    13ec:	a7 e2       	ldi	r26, 0x27	; 39
    13ee:	b0 e0       	ldi	r27, 0x00	; 0
    13f0:	e7 e2       	ldi	r30, 0x27	; 39
    13f2:	f0 e0       	ldi	r31, 0x00	; 0
    13f4:	90 81       	ld	r25, Z
    13f6:	89 81       	ldd	r24, Y+1	; 0x01
    13f8:	89 2b       	or	r24, r25
    13fa:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    13fc:	a6 e2       	ldi	r26, 0x26	; 38
    13fe:	b0 e0       	ldi	r27, 0x00	; 0
    1400:	e6 e2       	ldi	r30, 0x26	; 38
    1402:	f0 e0       	ldi	r31, 0x00	; 0
    1404:	80 81       	ld	r24, Z
    1406:	80 64       	ori	r24, 0x40	; 64
    1408:	8c 93       	st	X, r24
	/*Wait On ADC Conversion Completed Flag is set to one */
	while(GET_BIT(ADCSRA,4)==0);
    140a:	e6 e2       	ldi	r30, 0x26	; 38
    140c:	f0 e0       	ldi	r31, 0x00	; 0
    140e:	80 81       	ld	r24, Z
    1410:	82 95       	swap	r24
    1412:	8f 70       	andi	r24, 0x0F	; 15
    1414:	88 2f       	mov	r24, r24
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	81 70       	andi	r24, 0x01	; 1
    141a:	90 70       	andi	r25, 0x00	; 0
    141c:	00 97       	sbiw	r24, 0x00	; 0
    141e:	a9 f3       	breq	.-22     	; 0x140a <MADC_u16ADC_StartConversion+0x3e>

	return ADC;
    1420:	e4 e2       	ldi	r30, 0x24	; 36
    1422:	f0 e0       	ldi	r31, 0x00	; 0
    1424:	80 81       	ld	r24, Z
    1426:	91 81       	ldd	r25, Z+1	; 0x01
}
    1428:	0f 90       	pop	r0
    142a:	cf 91       	pop	r28
    142c:	df 91       	pop	r29
    142e:	08 95       	ret

00001430 <MADC_u16ADC_StartConversion_With_Interrupt>:
void MADC_u16ADC_StartConversion_With_Interrupt(u8 Copy_u8Channel)
{
    1430:	df 93       	push	r29
    1432:	cf 93       	push	r28
    1434:	0f 92       	push	r0
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    143c:	89 81       	ldd	r24, Y+1	; 0x01
    143e:	87 70       	andi	r24, 0x07	; 7
    1440:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    1442:	a7 e2       	ldi	r26, 0x27	; 39
    1444:	b0 e0       	ldi	r27, 0x00	; 0
    1446:	e7 e2       	ldi	r30, 0x27	; 39
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	80 81       	ld	r24, Z
    144c:	80 7e       	andi	r24, 0xE0	; 224
    144e:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    1450:	a7 e2       	ldi	r26, 0x27	; 39
    1452:	b0 e0       	ldi	r27, 0x00	; 0
    1454:	e7 e2       	ldi	r30, 0x27	; 39
    1456:	f0 e0       	ldi	r31, 0x00	; 0
    1458:	90 81       	ld	r25, Z
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	89 2b       	or	r24, r25
    145e:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    1460:	a6 e2       	ldi	r26, 0x26	; 38
    1462:	b0 e0       	ldi	r27, 0x00	; 0
    1464:	e6 e2       	ldi	r30, 0x26	; 38
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	80 81       	ld	r24, Z
    146a:	80 64       	ori	r24, 0x40	; 64
    146c:	8c 93       	st	X, r24
}
    146e:	0f 90       	pop	r0
    1470:	cf 91       	pop	r28
    1472:	df 91       	pop	r29
    1474:	08 95       	ret

00001476 <MADC_u16ADCRead>:
u16 MADC_u16ADCRead(void)
{
    1476:	df 93       	push	r29
    1478:	cf 93       	push	r28
    147a:	cd b7       	in	r28, 0x3d	; 61
    147c:	de b7       	in	r29, 0x3e	; 62
	return ADC;
    147e:	e4 e2       	ldi	r30, 0x24	; 36
    1480:	f0 e0       	ldi	r31, 0x00	; 0
    1482:	80 81       	ld	r24, Z
    1484:	91 81       	ldd	r25, Z+1	; 0x01
}
    1486:	cf 91       	pop	r28
    1488:	df 91       	pop	r29
    148a:	08 95       	ret

0000148c <MADC_VidSetCallBack>:
void MADC_VidSetCallBack(void (*Copy_pFun)(void))
{
    148c:	df 93       	push	r29
    148e:	cf 93       	push	r28
    1490:	00 d0       	rcall	.+0      	; 0x1492 <MADC_VidSetCallBack+0x6>
    1492:	cd b7       	in	r28, 0x3d	; 61
    1494:	de b7       	in	r29, 0x3e	; 62
    1496:	9a 83       	std	Y+2, r25	; 0x02
    1498:	89 83       	std	Y+1, r24	; 0x01
	MADC_CallBack=Copy_pFun;
    149a:	89 81       	ldd	r24, Y+1	; 0x01
    149c:	9a 81       	ldd	r25, Y+2	; 0x02
    149e:	90 93 10 05 	sts	0x0510, r25
    14a2:	80 93 0f 05 	sts	0x050F, r24
}
    14a6:	0f 90       	pop	r0
    14a8:	0f 90       	pop	r0
    14aa:	cf 91       	pop	r28
    14ac:	df 91       	pop	r29
    14ae:	08 95       	ret

000014b0 <__vector_16>:

void __vector_16(void)
{
    14b0:	1f 92       	push	r1
    14b2:	0f 92       	push	r0
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	0f 92       	push	r0
    14b8:	11 24       	eor	r1, r1
    14ba:	2f 93       	push	r18
    14bc:	3f 93       	push	r19
    14be:	4f 93       	push	r20
    14c0:	5f 93       	push	r21
    14c2:	6f 93       	push	r22
    14c4:	7f 93       	push	r23
    14c6:	8f 93       	push	r24
    14c8:	9f 93       	push	r25
    14ca:	af 93       	push	r26
    14cc:	bf 93       	push	r27
    14ce:	ef 93       	push	r30
    14d0:	ff 93       	push	r31
    14d2:	df 93       	push	r29
    14d4:	cf 93       	push	r28
    14d6:	cd b7       	in	r28, 0x3d	; 61
    14d8:	de b7       	in	r29, 0x3e	; 62
	MADC_CallBack();
    14da:	e0 91 0f 05 	lds	r30, 0x050F
    14de:	f0 91 10 05 	lds	r31, 0x0510
    14e2:	09 95       	icall
}
    14e4:	cf 91       	pop	r28
    14e6:	df 91       	pop	r29
    14e8:	ff 91       	pop	r31
    14ea:	ef 91       	pop	r30
    14ec:	bf 91       	pop	r27
    14ee:	af 91       	pop	r26
    14f0:	9f 91       	pop	r25
    14f2:	8f 91       	pop	r24
    14f4:	7f 91       	pop	r23
    14f6:	6f 91       	pop	r22
    14f8:	5f 91       	pop	r21
    14fa:	4f 91       	pop	r20
    14fc:	3f 91       	pop	r19
    14fe:	2f 91       	pop	r18
    1500:	0f 90       	pop	r0
    1502:	0f be       	out	0x3f, r0	; 63
    1504:	0f 90       	pop	r0
    1506:	1f 90       	pop	r1
    1508:	18 95       	reti

0000150a <HCLCD_VidWriteCommand_8Bits>:
#include"HCLCD_Interface.h"

#include"util/delay.h"

void HCLCD_VidWriteCommand_8Bits(u8 Copy_u8Command)
{
    150a:	df 93       	push	r29
    150c:	cf 93       	push	r28
    150e:	cd b7       	in	r28, 0x3d	; 61
    1510:	de b7       	in	r29, 0x3e	; 62
    1512:	6d 97       	sbiw	r28, 0x1d	; 29
    1514:	0f b6       	in	r0, 0x3f	; 63
    1516:	f8 94       	cli
    1518:	de bf       	out	0x3e, r29	; 62
    151a:	0f be       	out	0x3f, r0	; 63
    151c:	cd bf       	out	0x3d, r28	; 61
    151e:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    1520:	81 e0       	ldi	r24, 0x01	; 1
    1522:	61 e0       	ldi	r22, 0x01	; 1
    1524:	40 e0       	ldi	r20, 0x00	; 0
    1526:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Command);
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    152e:	0e 94 15 08 	call	0x102a	; 0x102a <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1532:	83 e0       	ldi	r24, 0x03	; 3
    1534:	61 e0       	ldi	r22, 0x01	; 1
    1536:	41 e0       	ldi	r20, 0x01	; 1
    1538:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	a0 e0       	ldi	r26, 0x00	; 0
    1542:	b0 e4       	ldi	r27, 0x40	; 64
    1544:	89 8f       	std	Y+25, r24	; 0x19
    1546:	9a 8f       	std	Y+26, r25	; 0x1a
    1548:	ab 8f       	std	Y+27, r26	; 0x1b
    154a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    154c:	69 8d       	ldd	r22, Y+25	; 0x19
    154e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1550:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1552:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1554:	20 e0       	ldi	r18, 0x00	; 0
    1556:	30 e0       	ldi	r19, 0x00	; 0
    1558:	4a e7       	ldi	r20, 0x7A	; 122
    155a:	53 e4       	ldi	r21, 0x43	; 67
    155c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1560:	dc 01       	movw	r26, r24
    1562:	cb 01       	movw	r24, r22
    1564:	8d 8b       	std	Y+21, r24	; 0x15
    1566:	9e 8b       	std	Y+22, r25	; 0x16
    1568:	af 8b       	std	Y+23, r26	; 0x17
    156a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    156c:	6d 89       	ldd	r22, Y+21	; 0x15
    156e:	7e 89       	ldd	r23, Y+22	; 0x16
    1570:	8f 89       	ldd	r24, Y+23	; 0x17
    1572:	98 8d       	ldd	r25, Y+24	; 0x18
    1574:	20 e0       	ldi	r18, 0x00	; 0
    1576:	30 e0       	ldi	r19, 0x00	; 0
    1578:	40 e8       	ldi	r20, 0x80	; 128
    157a:	5f e3       	ldi	r21, 0x3F	; 63
    157c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1580:	88 23       	and	r24, r24
    1582:	2c f4       	brge	.+10     	; 0x158e <HCLCD_VidWriteCommand_8Bits+0x84>
		__ticks = 1;
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	9c 8b       	std	Y+20, r25	; 0x14
    158a:	8b 8b       	std	Y+19, r24	; 0x13
    158c:	3f c0       	rjmp	.+126    	; 0x160c <HCLCD_VidWriteCommand_8Bits+0x102>
	else if (__tmp > 65535)
    158e:	6d 89       	ldd	r22, Y+21	; 0x15
    1590:	7e 89       	ldd	r23, Y+22	; 0x16
    1592:	8f 89       	ldd	r24, Y+23	; 0x17
    1594:	98 8d       	ldd	r25, Y+24	; 0x18
    1596:	20 e0       	ldi	r18, 0x00	; 0
    1598:	3f ef       	ldi	r19, 0xFF	; 255
    159a:	4f e7       	ldi	r20, 0x7F	; 127
    159c:	57 e4       	ldi	r21, 0x47	; 71
    159e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    15a2:	18 16       	cp	r1, r24
    15a4:	4c f5       	brge	.+82     	; 0x15f8 <HCLCD_VidWriteCommand_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    15a6:	69 8d       	ldd	r22, Y+25	; 0x19
    15a8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    15aa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    15ac:	9c 8d       	ldd	r25, Y+28	; 0x1c
    15ae:	20 e0       	ldi	r18, 0x00	; 0
    15b0:	30 e0       	ldi	r19, 0x00	; 0
    15b2:	40 e2       	ldi	r20, 0x20	; 32
    15b4:	51 e4       	ldi	r21, 0x41	; 65
    15b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15ba:	dc 01       	movw	r26, r24
    15bc:	cb 01       	movw	r24, r22
    15be:	bc 01       	movw	r22, r24
    15c0:	cd 01       	movw	r24, r26
    15c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15c6:	dc 01       	movw	r26, r24
    15c8:	cb 01       	movw	r24, r22
    15ca:	9c 8b       	std	Y+20, r25	; 0x14
    15cc:	8b 8b       	std	Y+19, r24	; 0x13
    15ce:	0f c0       	rjmp	.+30     	; 0x15ee <HCLCD_VidWriteCommand_8Bits+0xe4>
    15d0:	89 e1       	ldi	r24, 0x19	; 25
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	9a 8b       	std	Y+18, r25	; 0x12
    15d6:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    15d8:	89 89       	ldd	r24, Y+17	; 0x11
    15da:	9a 89       	ldd	r25, Y+18	; 0x12
    15dc:	01 97       	sbiw	r24, 0x01	; 1
    15de:	f1 f7       	brne	.-4      	; 0x15dc <HCLCD_VidWriteCommand_8Bits+0xd2>
    15e0:	9a 8b       	std	Y+18, r25	; 0x12
    15e2:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15e4:	8b 89       	ldd	r24, Y+19	; 0x13
    15e6:	9c 89       	ldd	r25, Y+20	; 0x14
    15e8:	01 97       	sbiw	r24, 0x01	; 1
    15ea:	9c 8b       	std	Y+20, r25	; 0x14
    15ec:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15ee:	8b 89       	ldd	r24, Y+19	; 0x13
    15f0:	9c 89       	ldd	r25, Y+20	; 0x14
    15f2:	00 97       	sbiw	r24, 0x00	; 0
    15f4:	69 f7       	brne	.-38     	; 0x15d0 <HCLCD_VidWriteCommand_8Bits+0xc6>
    15f6:	14 c0       	rjmp	.+40     	; 0x1620 <HCLCD_VidWriteCommand_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15f8:	6d 89       	ldd	r22, Y+21	; 0x15
    15fa:	7e 89       	ldd	r23, Y+22	; 0x16
    15fc:	8f 89       	ldd	r24, Y+23	; 0x17
    15fe:	98 8d       	ldd	r25, Y+24	; 0x18
    1600:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1604:	dc 01       	movw	r26, r24
    1606:	cb 01       	movw	r24, r22
    1608:	9c 8b       	std	Y+20, r25	; 0x14
    160a:	8b 8b       	std	Y+19, r24	; 0x13
    160c:	8b 89       	ldd	r24, Y+19	; 0x13
    160e:	9c 89       	ldd	r25, Y+20	; 0x14
    1610:	98 8b       	std	Y+16, r25	; 0x10
    1612:	8f 87       	std	Y+15, r24	; 0x0f
    1614:	8f 85       	ldd	r24, Y+15	; 0x0f
    1616:	98 89       	ldd	r25, Y+16	; 0x10
    1618:	01 97       	sbiw	r24, 0x01	; 1
    161a:	f1 f7       	brne	.-4      	; 0x1618 <HCLCD_VidWriteCommand_8Bits+0x10e>
    161c:	98 8b       	std	Y+16, r25	; 0x10
    161e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    1620:	83 e0       	ldi	r24, 0x03	; 3
    1622:	61 e0       	ldi	r22, 0x01	; 1
    1624:	40 e0       	ldi	r20, 0x00	; 0
    1626:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	a0 e0       	ldi	r26, 0x00	; 0
    1630:	b0 e4       	ldi	r27, 0x40	; 64
    1632:	8b 87       	std	Y+11, r24	; 0x0b
    1634:	9c 87       	std	Y+12, r25	; 0x0c
    1636:	ad 87       	std	Y+13, r26	; 0x0d
    1638:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    163a:	6b 85       	ldd	r22, Y+11	; 0x0b
    163c:	7c 85       	ldd	r23, Y+12	; 0x0c
    163e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1640:	9e 85       	ldd	r25, Y+14	; 0x0e
    1642:	20 e0       	ldi	r18, 0x00	; 0
    1644:	30 e0       	ldi	r19, 0x00	; 0
    1646:	4a e7       	ldi	r20, 0x7A	; 122
    1648:	53 e4       	ldi	r21, 0x43	; 67
    164a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    164e:	dc 01       	movw	r26, r24
    1650:	cb 01       	movw	r24, r22
    1652:	8f 83       	std	Y+7, r24	; 0x07
    1654:	98 87       	std	Y+8, r25	; 0x08
    1656:	a9 87       	std	Y+9, r26	; 0x09
    1658:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    165a:	6f 81       	ldd	r22, Y+7	; 0x07
    165c:	78 85       	ldd	r23, Y+8	; 0x08
    165e:	89 85       	ldd	r24, Y+9	; 0x09
    1660:	9a 85       	ldd	r25, Y+10	; 0x0a
    1662:	20 e0       	ldi	r18, 0x00	; 0
    1664:	30 e0       	ldi	r19, 0x00	; 0
    1666:	40 e8       	ldi	r20, 0x80	; 128
    1668:	5f e3       	ldi	r21, 0x3F	; 63
    166a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    166e:	88 23       	and	r24, r24
    1670:	2c f4       	brge	.+10     	; 0x167c <HCLCD_VidWriteCommand_8Bits+0x172>
		__ticks = 1;
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	9e 83       	std	Y+6, r25	; 0x06
    1678:	8d 83       	std	Y+5, r24	; 0x05
    167a:	3f c0       	rjmp	.+126    	; 0x16fa <HCLCD_VidWriteCommand_8Bits+0x1f0>
	else if (__tmp > 65535)
    167c:	6f 81       	ldd	r22, Y+7	; 0x07
    167e:	78 85       	ldd	r23, Y+8	; 0x08
    1680:	89 85       	ldd	r24, Y+9	; 0x09
    1682:	9a 85       	ldd	r25, Y+10	; 0x0a
    1684:	20 e0       	ldi	r18, 0x00	; 0
    1686:	3f ef       	ldi	r19, 0xFF	; 255
    1688:	4f e7       	ldi	r20, 0x7F	; 127
    168a:	57 e4       	ldi	r21, 0x47	; 71
    168c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1690:	18 16       	cp	r1, r24
    1692:	4c f5       	brge	.+82     	; 0x16e6 <HCLCD_VidWriteCommand_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1694:	6b 85       	ldd	r22, Y+11	; 0x0b
    1696:	7c 85       	ldd	r23, Y+12	; 0x0c
    1698:	8d 85       	ldd	r24, Y+13	; 0x0d
    169a:	9e 85       	ldd	r25, Y+14	; 0x0e
    169c:	20 e0       	ldi	r18, 0x00	; 0
    169e:	30 e0       	ldi	r19, 0x00	; 0
    16a0:	40 e2       	ldi	r20, 0x20	; 32
    16a2:	51 e4       	ldi	r21, 0x41	; 65
    16a4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16a8:	dc 01       	movw	r26, r24
    16aa:	cb 01       	movw	r24, r22
    16ac:	bc 01       	movw	r22, r24
    16ae:	cd 01       	movw	r24, r26
    16b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16b4:	dc 01       	movw	r26, r24
    16b6:	cb 01       	movw	r24, r22
    16b8:	9e 83       	std	Y+6, r25	; 0x06
    16ba:	8d 83       	std	Y+5, r24	; 0x05
    16bc:	0f c0       	rjmp	.+30     	; 0x16dc <HCLCD_VidWriteCommand_8Bits+0x1d2>
    16be:	89 e1       	ldi	r24, 0x19	; 25
    16c0:	90 e0       	ldi	r25, 0x00	; 0
    16c2:	9c 83       	std	Y+4, r25	; 0x04
    16c4:	8b 83       	std	Y+3, r24	; 0x03
    16c6:	8b 81       	ldd	r24, Y+3	; 0x03
    16c8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ca:	01 97       	sbiw	r24, 0x01	; 1
    16cc:	f1 f7       	brne	.-4      	; 0x16ca <HCLCD_VidWriteCommand_8Bits+0x1c0>
    16ce:	9c 83       	std	Y+4, r25	; 0x04
    16d0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16d2:	8d 81       	ldd	r24, Y+5	; 0x05
    16d4:	9e 81       	ldd	r25, Y+6	; 0x06
    16d6:	01 97       	sbiw	r24, 0x01	; 1
    16d8:	9e 83       	std	Y+6, r25	; 0x06
    16da:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16dc:	8d 81       	ldd	r24, Y+5	; 0x05
    16de:	9e 81       	ldd	r25, Y+6	; 0x06
    16e0:	00 97       	sbiw	r24, 0x00	; 0
    16e2:	69 f7       	brne	.-38     	; 0x16be <HCLCD_VidWriteCommand_8Bits+0x1b4>
    16e4:	14 c0       	rjmp	.+40     	; 0x170e <HCLCD_VidWriteCommand_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16e6:	6f 81       	ldd	r22, Y+7	; 0x07
    16e8:	78 85       	ldd	r23, Y+8	; 0x08
    16ea:	89 85       	ldd	r24, Y+9	; 0x09
    16ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    16ee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16f2:	dc 01       	movw	r26, r24
    16f4:	cb 01       	movw	r24, r22
    16f6:	9e 83       	std	Y+6, r25	; 0x06
    16f8:	8d 83       	std	Y+5, r24	; 0x05
    16fa:	8d 81       	ldd	r24, Y+5	; 0x05
    16fc:	9e 81       	ldd	r25, Y+6	; 0x06
    16fe:	9a 83       	std	Y+2, r25	; 0x02
    1700:	89 83       	std	Y+1, r24	; 0x01
    1702:	89 81       	ldd	r24, Y+1	; 0x01
    1704:	9a 81       	ldd	r25, Y+2	; 0x02
    1706:	01 97       	sbiw	r24, 0x01	; 1
    1708:	f1 f7       	brne	.-4      	; 0x1706 <HCLCD_VidWriteCommand_8Bits+0x1fc>
    170a:	9a 83       	std	Y+2, r25	; 0x02
    170c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    170e:	83 e0       	ldi	r24, 0x03	; 3
    1710:	61 e0       	ldi	r22, 0x01	; 1
    1712:	41 e0       	ldi	r20, 0x01	; 1
    1714:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
}
    1718:	6d 96       	adiw	r28, 0x1d	; 29
    171a:	0f b6       	in	r0, 0x3f	; 63
    171c:	f8 94       	cli
    171e:	de bf       	out	0x3e, r29	; 62
    1720:	0f be       	out	0x3f, r0	; 63
    1722:	cd bf       	out	0x3d, r28	; 61
    1724:	cf 91       	pop	r28
    1726:	df 91       	pop	r29
    1728:	08 95       	ret

0000172a <HCLCD_Vid8Bits_Init>:

void HCLCD_Vid8Bits_Init(void)
{
    172a:	df 93       	push	r29
    172c:	cf 93       	push	r28
    172e:	cd b7       	in	r28, 0x3d	; 61
    1730:	de b7       	in	r29, 0x3e	; 62
    1732:	e8 97       	sbiw	r28, 0x38	; 56
    1734:	0f b6       	in	r0, 0x3f	; 63
    1736:	f8 94       	cli
    1738:	de bf       	out	0x3e, r29	; 62
    173a:	0f be       	out	0x3f, r0	; 63
    173c:	cd bf       	out	0x3d, r28	; 61
	/*LCD Data and control port intialization*/
	MDIO_Error_State_SetPortDirection(DATA_PORT,PORT_OUTPUT);
    173e:	80 e0       	ldi	r24, 0x00	; 0
    1740:	6f ef       	ldi	r22, 0xFF	; 255
    1742:	0e 94 c2 06 	call	0xd84	; 0xd84 <MDIO_Error_State_SetPortDirection>
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    1746:	81 e0       	ldi	r24, 0x01	; 1
    1748:	61 e0       	ldi	r22, 0x01	; 1
    174a:	41 e0       	ldi	r20, 0x01	; 1
    174c:	0e 94 bf 05 	call	0xb7e	; 0xb7e <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    1750:	83 e0       	ldi	r24, 0x03	; 3
    1752:	61 e0       	ldi	r22, 0x01	; 1
    1754:	41 e0       	ldi	r20, 0x01	; 1
    1756:	0e 94 bf 05 	call	0xb7e	; 0xb7e <MDIO_Error_State_SetPinDirection>
    175a:	80 e0       	ldi	r24, 0x00	; 0
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	a0 ef       	ldi	r26, 0xF0	; 240
    1760:	b1 e4       	ldi	r27, 0x41	; 65
    1762:	8d ab       	std	Y+53, r24	; 0x35
    1764:	9e ab       	std	Y+54, r25	; 0x36
    1766:	af ab       	std	Y+55, r26	; 0x37
    1768:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    176a:	6d a9       	ldd	r22, Y+53	; 0x35
    176c:	7e a9       	ldd	r23, Y+54	; 0x36
    176e:	8f a9       	ldd	r24, Y+55	; 0x37
    1770:	98 ad       	ldd	r25, Y+56	; 0x38
    1772:	20 e0       	ldi	r18, 0x00	; 0
    1774:	30 e0       	ldi	r19, 0x00	; 0
    1776:	4a e7       	ldi	r20, 0x7A	; 122
    1778:	53 e4       	ldi	r21, 0x43	; 67
    177a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    177e:	dc 01       	movw	r26, r24
    1780:	cb 01       	movw	r24, r22
    1782:	89 ab       	std	Y+49, r24	; 0x31
    1784:	9a ab       	std	Y+50, r25	; 0x32
    1786:	ab ab       	std	Y+51, r26	; 0x33
    1788:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    178a:	69 a9       	ldd	r22, Y+49	; 0x31
    178c:	7a a9       	ldd	r23, Y+50	; 0x32
    178e:	8b a9       	ldd	r24, Y+51	; 0x33
    1790:	9c a9       	ldd	r25, Y+52	; 0x34
    1792:	20 e0       	ldi	r18, 0x00	; 0
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	40 e8       	ldi	r20, 0x80	; 128
    1798:	5f e3       	ldi	r21, 0x3F	; 63
    179a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    179e:	88 23       	and	r24, r24
    17a0:	2c f4       	brge	.+10     	; 0x17ac <HCLCD_Vid8Bits_Init+0x82>
		__ticks = 1;
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	98 ab       	std	Y+48, r25	; 0x30
    17a8:	8f a7       	std	Y+47, r24	; 0x2f
    17aa:	3f c0       	rjmp	.+126    	; 0x182a <HCLCD_Vid8Bits_Init+0x100>
	else if (__tmp > 65535)
    17ac:	69 a9       	ldd	r22, Y+49	; 0x31
    17ae:	7a a9       	ldd	r23, Y+50	; 0x32
    17b0:	8b a9       	ldd	r24, Y+51	; 0x33
    17b2:	9c a9       	ldd	r25, Y+52	; 0x34
    17b4:	20 e0       	ldi	r18, 0x00	; 0
    17b6:	3f ef       	ldi	r19, 0xFF	; 255
    17b8:	4f e7       	ldi	r20, 0x7F	; 127
    17ba:	57 e4       	ldi	r21, 0x47	; 71
    17bc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    17c0:	18 16       	cp	r1, r24
    17c2:	4c f5       	brge	.+82     	; 0x1816 <HCLCD_Vid8Bits_Init+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    17c4:	6d a9       	ldd	r22, Y+53	; 0x35
    17c6:	7e a9       	ldd	r23, Y+54	; 0x36
    17c8:	8f a9       	ldd	r24, Y+55	; 0x37
    17ca:	98 ad       	ldd	r25, Y+56	; 0x38
    17cc:	20 e0       	ldi	r18, 0x00	; 0
    17ce:	30 e0       	ldi	r19, 0x00	; 0
    17d0:	40 e2       	ldi	r20, 0x20	; 32
    17d2:	51 e4       	ldi	r21, 0x41	; 65
    17d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17d8:	dc 01       	movw	r26, r24
    17da:	cb 01       	movw	r24, r22
    17dc:	bc 01       	movw	r22, r24
    17de:	cd 01       	movw	r24, r26
    17e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17e4:	dc 01       	movw	r26, r24
    17e6:	cb 01       	movw	r24, r22
    17e8:	98 ab       	std	Y+48, r25	; 0x30
    17ea:	8f a7       	std	Y+47, r24	; 0x2f
    17ec:	0f c0       	rjmp	.+30     	; 0x180c <HCLCD_Vid8Bits_Init+0xe2>
    17ee:	89 e1       	ldi	r24, 0x19	; 25
    17f0:	90 e0       	ldi	r25, 0x00	; 0
    17f2:	9e a7       	std	Y+46, r25	; 0x2e
    17f4:	8d a7       	std	Y+45, r24	; 0x2d
    17f6:	8d a5       	ldd	r24, Y+45	; 0x2d
    17f8:	9e a5       	ldd	r25, Y+46	; 0x2e
    17fa:	01 97       	sbiw	r24, 0x01	; 1
    17fc:	f1 f7       	brne	.-4      	; 0x17fa <HCLCD_Vid8Bits_Init+0xd0>
    17fe:	9e a7       	std	Y+46, r25	; 0x2e
    1800:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1802:	8f a5       	ldd	r24, Y+47	; 0x2f
    1804:	98 a9       	ldd	r25, Y+48	; 0x30
    1806:	01 97       	sbiw	r24, 0x01	; 1
    1808:	98 ab       	std	Y+48, r25	; 0x30
    180a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    180c:	8f a5       	ldd	r24, Y+47	; 0x2f
    180e:	98 a9       	ldd	r25, Y+48	; 0x30
    1810:	00 97       	sbiw	r24, 0x00	; 0
    1812:	69 f7       	brne	.-38     	; 0x17ee <HCLCD_Vid8Bits_Init+0xc4>
    1814:	14 c0       	rjmp	.+40     	; 0x183e <HCLCD_Vid8Bits_Init+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1816:	69 a9       	ldd	r22, Y+49	; 0x31
    1818:	7a a9       	ldd	r23, Y+50	; 0x32
    181a:	8b a9       	ldd	r24, Y+51	; 0x33
    181c:	9c a9       	ldd	r25, Y+52	; 0x34
    181e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1822:	dc 01       	movw	r26, r24
    1824:	cb 01       	movw	r24, r22
    1826:	98 ab       	std	Y+48, r25	; 0x30
    1828:	8f a7       	std	Y+47, r24	; 0x2f
    182a:	8f a5       	ldd	r24, Y+47	; 0x2f
    182c:	98 a9       	ldd	r25, Y+48	; 0x30
    182e:	9c a7       	std	Y+44, r25	; 0x2c
    1830:	8b a7       	std	Y+43, r24	; 0x2b
    1832:	8b a5       	ldd	r24, Y+43	; 0x2b
    1834:	9c a5       	ldd	r25, Y+44	; 0x2c
    1836:	01 97       	sbiw	r24, 0x01	; 1
    1838:	f1 f7       	brne	.-4      	; 0x1836 <HCLCD_Vid8Bits_Init+0x10c>
    183a:	9c a7       	std	Y+44, r25	; 0x2c
    183c:	8b a7       	std	Y+43, r24	; 0x2b

	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_FUNCTION_SET);
    183e:	88 e2       	ldi	r24, 0x28	; 40
    1840:	0e 94 85 0a 	call	0x150a	; 0x150a <HCLCD_VidWriteCommand_8Bits>
    1844:	80 e0       	ldi	r24, 0x00	; 0
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	a0 e8       	ldi	r26, 0x80	; 128
    184a:	bf e3       	ldi	r27, 0x3F	; 63
    184c:	8f a3       	std	Y+39, r24	; 0x27
    184e:	98 a7       	std	Y+40, r25	; 0x28
    1850:	a9 a7       	std	Y+41, r26	; 0x29
    1852:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1854:	6f a1       	ldd	r22, Y+39	; 0x27
    1856:	78 a5       	ldd	r23, Y+40	; 0x28
    1858:	89 a5       	ldd	r24, Y+41	; 0x29
    185a:	9a a5       	ldd	r25, Y+42	; 0x2a
    185c:	20 e0       	ldi	r18, 0x00	; 0
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	4a e7       	ldi	r20, 0x7A	; 122
    1862:	53 e4       	ldi	r21, 0x43	; 67
    1864:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1868:	dc 01       	movw	r26, r24
    186a:	cb 01       	movw	r24, r22
    186c:	8b a3       	std	Y+35, r24	; 0x23
    186e:	9c a3       	std	Y+36, r25	; 0x24
    1870:	ad a3       	std	Y+37, r26	; 0x25
    1872:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1874:	6b a1       	ldd	r22, Y+35	; 0x23
    1876:	7c a1       	ldd	r23, Y+36	; 0x24
    1878:	8d a1       	ldd	r24, Y+37	; 0x25
    187a:	9e a1       	ldd	r25, Y+38	; 0x26
    187c:	20 e0       	ldi	r18, 0x00	; 0
    187e:	30 e0       	ldi	r19, 0x00	; 0
    1880:	40 e8       	ldi	r20, 0x80	; 128
    1882:	5f e3       	ldi	r21, 0x3F	; 63
    1884:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1888:	88 23       	and	r24, r24
    188a:	2c f4       	brge	.+10     	; 0x1896 <HCLCD_Vid8Bits_Init+0x16c>
		__ticks = 1;
    188c:	81 e0       	ldi	r24, 0x01	; 1
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	9a a3       	std	Y+34, r25	; 0x22
    1892:	89 a3       	std	Y+33, r24	; 0x21
    1894:	3f c0       	rjmp	.+126    	; 0x1914 <HCLCD_Vid8Bits_Init+0x1ea>
	else if (__tmp > 65535)
    1896:	6b a1       	ldd	r22, Y+35	; 0x23
    1898:	7c a1       	ldd	r23, Y+36	; 0x24
    189a:	8d a1       	ldd	r24, Y+37	; 0x25
    189c:	9e a1       	ldd	r25, Y+38	; 0x26
    189e:	20 e0       	ldi	r18, 0x00	; 0
    18a0:	3f ef       	ldi	r19, 0xFF	; 255
    18a2:	4f e7       	ldi	r20, 0x7F	; 127
    18a4:	57 e4       	ldi	r21, 0x47	; 71
    18a6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    18aa:	18 16       	cp	r1, r24
    18ac:	4c f5       	brge	.+82     	; 0x1900 <HCLCD_Vid8Bits_Init+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    18ae:	6f a1       	ldd	r22, Y+39	; 0x27
    18b0:	78 a5       	ldd	r23, Y+40	; 0x28
    18b2:	89 a5       	ldd	r24, Y+41	; 0x29
    18b4:	9a a5       	ldd	r25, Y+42	; 0x2a
    18b6:	20 e0       	ldi	r18, 0x00	; 0
    18b8:	30 e0       	ldi	r19, 0x00	; 0
    18ba:	40 e2       	ldi	r20, 0x20	; 32
    18bc:	51 e4       	ldi	r21, 0x41	; 65
    18be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18c2:	dc 01       	movw	r26, r24
    18c4:	cb 01       	movw	r24, r22
    18c6:	bc 01       	movw	r22, r24
    18c8:	cd 01       	movw	r24, r26
    18ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18ce:	dc 01       	movw	r26, r24
    18d0:	cb 01       	movw	r24, r22
    18d2:	9a a3       	std	Y+34, r25	; 0x22
    18d4:	89 a3       	std	Y+33, r24	; 0x21
    18d6:	0f c0       	rjmp	.+30     	; 0x18f6 <HCLCD_Vid8Bits_Init+0x1cc>
    18d8:	89 e1       	ldi	r24, 0x19	; 25
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	98 a3       	std	Y+32, r25	; 0x20
    18de:	8f 8f       	std	Y+31, r24	; 0x1f
    18e0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    18e2:	98 a1       	ldd	r25, Y+32	; 0x20
    18e4:	01 97       	sbiw	r24, 0x01	; 1
    18e6:	f1 f7       	brne	.-4      	; 0x18e4 <HCLCD_Vid8Bits_Init+0x1ba>
    18e8:	98 a3       	std	Y+32, r25	; 0x20
    18ea:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18ec:	89 a1       	ldd	r24, Y+33	; 0x21
    18ee:	9a a1       	ldd	r25, Y+34	; 0x22
    18f0:	01 97       	sbiw	r24, 0x01	; 1
    18f2:	9a a3       	std	Y+34, r25	; 0x22
    18f4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18f6:	89 a1       	ldd	r24, Y+33	; 0x21
    18f8:	9a a1       	ldd	r25, Y+34	; 0x22
    18fa:	00 97       	sbiw	r24, 0x00	; 0
    18fc:	69 f7       	brne	.-38     	; 0x18d8 <HCLCD_Vid8Bits_Init+0x1ae>
    18fe:	14 c0       	rjmp	.+40     	; 0x1928 <HCLCD_Vid8Bits_Init+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1900:	6b a1       	ldd	r22, Y+35	; 0x23
    1902:	7c a1       	ldd	r23, Y+36	; 0x24
    1904:	8d a1       	ldd	r24, Y+37	; 0x25
    1906:	9e a1       	ldd	r25, Y+38	; 0x26
    1908:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    190c:	dc 01       	movw	r26, r24
    190e:	cb 01       	movw	r24, r22
    1910:	9a a3       	std	Y+34, r25	; 0x22
    1912:	89 a3       	std	Y+33, r24	; 0x21
    1914:	89 a1       	ldd	r24, Y+33	; 0x21
    1916:	9a a1       	ldd	r25, Y+34	; 0x22
    1918:	9e 8f       	std	Y+30, r25	; 0x1e
    191a:	8d 8f       	std	Y+29, r24	; 0x1d
    191c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    191e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1920:	01 97       	sbiw	r24, 0x01	; 1
    1922:	f1 f7       	brne	.-4      	; 0x1920 <HCLCD_Vid8Bits_Init+0x1f6>
    1924:	9e 8f       	std	Y+30, r25	; 0x1e
    1926:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_DISPLAY_ON_OFF);
    1928:	8f e0       	ldi	r24, 0x0F	; 15
    192a:	0e 94 85 0a 	call	0x150a	; 0x150a <HCLCD_VidWriteCommand_8Bits>
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	a0 e8       	ldi	r26, 0x80	; 128
    1934:	bf e3       	ldi	r27, 0x3F	; 63
    1936:	89 8f       	std	Y+25, r24	; 0x19
    1938:	9a 8f       	std	Y+26, r25	; 0x1a
    193a:	ab 8f       	std	Y+27, r26	; 0x1b
    193c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    193e:	69 8d       	ldd	r22, Y+25	; 0x19
    1940:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1942:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1944:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1946:	20 e0       	ldi	r18, 0x00	; 0
    1948:	30 e0       	ldi	r19, 0x00	; 0
    194a:	4a e7       	ldi	r20, 0x7A	; 122
    194c:	53 e4       	ldi	r21, 0x43	; 67
    194e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1952:	dc 01       	movw	r26, r24
    1954:	cb 01       	movw	r24, r22
    1956:	8d 8b       	std	Y+21, r24	; 0x15
    1958:	9e 8b       	std	Y+22, r25	; 0x16
    195a:	af 8b       	std	Y+23, r26	; 0x17
    195c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    195e:	6d 89       	ldd	r22, Y+21	; 0x15
    1960:	7e 89       	ldd	r23, Y+22	; 0x16
    1962:	8f 89       	ldd	r24, Y+23	; 0x17
    1964:	98 8d       	ldd	r25, Y+24	; 0x18
    1966:	20 e0       	ldi	r18, 0x00	; 0
    1968:	30 e0       	ldi	r19, 0x00	; 0
    196a:	40 e8       	ldi	r20, 0x80	; 128
    196c:	5f e3       	ldi	r21, 0x3F	; 63
    196e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1972:	88 23       	and	r24, r24
    1974:	2c f4       	brge	.+10     	; 0x1980 <HCLCD_Vid8Bits_Init+0x256>
		__ticks = 1;
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	9c 8b       	std	Y+20, r25	; 0x14
    197c:	8b 8b       	std	Y+19, r24	; 0x13
    197e:	3f c0       	rjmp	.+126    	; 0x19fe <HCLCD_Vid8Bits_Init+0x2d4>
	else if (__tmp > 65535)
    1980:	6d 89       	ldd	r22, Y+21	; 0x15
    1982:	7e 89       	ldd	r23, Y+22	; 0x16
    1984:	8f 89       	ldd	r24, Y+23	; 0x17
    1986:	98 8d       	ldd	r25, Y+24	; 0x18
    1988:	20 e0       	ldi	r18, 0x00	; 0
    198a:	3f ef       	ldi	r19, 0xFF	; 255
    198c:	4f e7       	ldi	r20, 0x7F	; 127
    198e:	57 e4       	ldi	r21, 0x47	; 71
    1990:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1994:	18 16       	cp	r1, r24
    1996:	4c f5       	brge	.+82     	; 0x19ea <HCLCD_Vid8Bits_Init+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1998:	69 8d       	ldd	r22, Y+25	; 0x19
    199a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    199c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    199e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    19a0:	20 e0       	ldi	r18, 0x00	; 0
    19a2:	30 e0       	ldi	r19, 0x00	; 0
    19a4:	40 e2       	ldi	r20, 0x20	; 32
    19a6:	51 e4       	ldi	r21, 0x41	; 65
    19a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19ac:	dc 01       	movw	r26, r24
    19ae:	cb 01       	movw	r24, r22
    19b0:	bc 01       	movw	r22, r24
    19b2:	cd 01       	movw	r24, r26
    19b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19b8:	dc 01       	movw	r26, r24
    19ba:	cb 01       	movw	r24, r22
    19bc:	9c 8b       	std	Y+20, r25	; 0x14
    19be:	8b 8b       	std	Y+19, r24	; 0x13
    19c0:	0f c0       	rjmp	.+30     	; 0x19e0 <HCLCD_Vid8Bits_Init+0x2b6>
    19c2:	89 e1       	ldi	r24, 0x19	; 25
    19c4:	90 e0       	ldi	r25, 0x00	; 0
    19c6:	9a 8b       	std	Y+18, r25	; 0x12
    19c8:	89 8b       	std	Y+17, r24	; 0x11
    19ca:	89 89       	ldd	r24, Y+17	; 0x11
    19cc:	9a 89       	ldd	r25, Y+18	; 0x12
    19ce:	01 97       	sbiw	r24, 0x01	; 1
    19d0:	f1 f7       	brne	.-4      	; 0x19ce <HCLCD_Vid8Bits_Init+0x2a4>
    19d2:	9a 8b       	std	Y+18, r25	; 0x12
    19d4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19d6:	8b 89       	ldd	r24, Y+19	; 0x13
    19d8:	9c 89       	ldd	r25, Y+20	; 0x14
    19da:	01 97       	sbiw	r24, 0x01	; 1
    19dc:	9c 8b       	std	Y+20, r25	; 0x14
    19de:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19e0:	8b 89       	ldd	r24, Y+19	; 0x13
    19e2:	9c 89       	ldd	r25, Y+20	; 0x14
    19e4:	00 97       	sbiw	r24, 0x00	; 0
    19e6:	69 f7       	brne	.-38     	; 0x19c2 <HCLCD_Vid8Bits_Init+0x298>
    19e8:	14 c0       	rjmp	.+40     	; 0x1a12 <HCLCD_Vid8Bits_Init+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19ea:	6d 89       	ldd	r22, Y+21	; 0x15
    19ec:	7e 89       	ldd	r23, Y+22	; 0x16
    19ee:	8f 89       	ldd	r24, Y+23	; 0x17
    19f0:	98 8d       	ldd	r25, Y+24	; 0x18
    19f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19f6:	dc 01       	movw	r26, r24
    19f8:	cb 01       	movw	r24, r22
    19fa:	9c 8b       	std	Y+20, r25	; 0x14
    19fc:	8b 8b       	std	Y+19, r24	; 0x13
    19fe:	8b 89       	ldd	r24, Y+19	; 0x13
    1a00:	9c 89       	ldd	r25, Y+20	; 0x14
    1a02:	98 8b       	std	Y+16, r25	; 0x10
    1a04:	8f 87       	std	Y+15, r24	; 0x0f
    1a06:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a08:	98 89       	ldd	r25, Y+16	; 0x10
    1a0a:	01 97       	sbiw	r24, 0x01	; 1
    1a0c:	f1 f7       	brne	.-4      	; 0x1a0a <HCLCD_Vid8Bits_Init+0x2e0>
    1a0e:	98 8b       	std	Y+16, r25	; 0x10
    1a10:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_8Bits(DISPLAY_CLEAR);
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	0e 94 85 0a 	call	0x150a	; 0x150a <HCLCD_VidWriteCommand_8Bits>
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	90 e0       	ldi	r25, 0x00	; 0
    1a1c:	a0 e0       	ldi	r26, 0x00	; 0
    1a1e:	b0 e4       	ldi	r27, 0x40	; 64
    1a20:	8b 87       	std	Y+11, r24	; 0x0b
    1a22:	9c 87       	std	Y+12, r25	; 0x0c
    1a24:	ad 87       	std	Y+13, r26	; 0x0d
    1a26:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a28:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a2a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a2c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a2e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a30:	20 e0       	ldi	r18, 0x00	; 0
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	4a e7       	ldi	r20, 0x7A	; 122
    1a36:	53 e4       	ldi	r21, 0x43	; 67
    1a38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a3c:	dc 01       	movw	r26, r24
    1a3e:	cb 01       	movw	r24, r22
    1a40:	8f 83       	std	Y+7, r24	; 0x07
    1a42:	98 87       	std	Y+8, r25	; 0x08
    1a44:	a9 87       	std	Y+9, r26	; 0x09
    1a46:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1a48:	6f 81       	ldd	r22, Y+7	; 0x07
    1a4a:	78 85       	ldd	r23, Y+8	; 0x08
    1a4c:	89 85       	ldd	r24, Y+9	; 0x09
    1a4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a50:	20 e0       	ldi	r18, 0x00	; 0
    1a52:	30 e0       	ldi	r19, 0x00	; 0
    1a54:	40 e8       	ldi	r20, 0x80	; 128
    1a56:	5f e3       	ldi	r21, 0x3F	; 63
    1a58:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a5c:	88 23       	and	r24, r24
    1a5e:	2c f4       	brge	.+10     	; 0x1a6a <HCLCD_Vid8Bits_Init+0x340>
		__ticks = 1;
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	9e 83       	std	Y+6, r25	; 0x06
    1a66:	8d 83       	std	Y+5, r24	; 0x05
    1a68:	3f c0       	rjmp	.+126    	; 0x1ae8 <HCLCD_Vid8Bits_Init+0x3be>
	else if (__tmp > 65535)
    1a6a:	6f 81       	ldd	r22, Y+7	; 0x07
    1a6c:	78 85       	ldd	r23, Y+8	; 0x08
    1a6e:	89 85       	ldd	r24, Y+9	; 0x09
    1a70:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a72:	20 e0       	ldi	r18, 0x00	; 0
    1a74:	3f ef       	ldi	r19, 0xFF	; 255
    1a76:	4f e7       	ldi	r20, 0x7F	; 127
    1a78:	57 e4       	ldi	r21, 0x47	; 71
    1a7a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a7e:	18 16       	cp	r1, r24
    1a80:	4c f5       	brge	.+82     	; 0x1ad4 <HCLCD_Vid8Bits_Init+0x3aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a82:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a84:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a86:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a88:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a8a:	20 e0       	ldi	r18, 0x00	; 0
    1a8c:	30 e0       	ldi	r19, 0x00	; 0
    1a8e:	40 e2       	ldi	r20, 0x20	; 32
    1a90:	51 e4       	ldi	r21, 0x41	; 65
    1a92:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a96:	dc 01       	movw	r26, r24
    1a98:	cb 01       	movw	r24, r22
    1a9a:	bc 01       	movw	r22, r24
    1a9c:	cd 01       	movw	r24, r26
    1a9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1aa2:	dc 01       	movw	r26, r24
    1aa4:	cb 01       	movw	r24, r22
    1aa6:	9e 83       	std	Y+6, r25	; 0x06
    1aa8:	8d 83       	std	Y+5, r24	; 0x05
    1aaa:	0f c0       	rjmp	.+30     	; 0x1aca <HCLCD_Vid8Bits_Init+0x3a0>
    1aac:	89 e1       	ldi	r24, 0x19	; 25
    1aae:	90 e0       	ldi	r25, 0x00	; 0
    1ab0:	9c 83       	std	Y+4, r25	; 0x04
    1ab2:	8b 83       	std	Y+3, r24	; 0x03
    1ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab8:	01 97       	sbiw	r24, 0x01	; 1
    1aba:	f1 f7       	brne	.-4      	; 0x1ab8 <HCLCD_Vid8Bits_Init+0x38e>
    1abc:	9c 83       	std	Y+4, r25	; 0x04
    1abe:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ac2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ac4:	01 97       	sbiw	r24, 0x01	; 1
    1ac6:	9e 83       	std	Y+6, r25	; 0x06
    1ac8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1aca:	8d 81       	ldd	r24, Y+5	; 0x05
    1acc:	9e 81       	ldd	r25, Y+6	; 0x06
    1ace:	00 97       	sbiw	r24, 0x00	; 0
    1ad0:	69 f7       	brne	.-38     	; 0x1aac <HCLCD_Vid8Bits_Init+0x382>
    1ad2:	14 c0       	rjmp	.+40     	; 0x1afc <HCLCD_Vid8Bits_Init+0x3d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ad4:	6f 81       	ldd	r22, Y+7	; 0x07
    1ad6:	78 85       	ldd	r23, Y+8	; 0x08
    1ad8:	89 85       	ldd	r24, Y+9	; 0x09
    1ada:	9a 85       	ldd	r25, Y+10	; 0x0a
    1adc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ae0:	dc 01       	movw	r26, r24
    1ae2:	cb 01       	movw	r24, r22
    1ae4:	9e 83       	std	Y+6, r25	; 0x06
    1ae6:	8d 83       	std	Y+5, r24	; 0x05
    1ae8:	8d 81       	ldd	r24, Y+5	; 0x05
    1aea:	9e 81       	ldd	r25, Y+6	; 0x06
    1aec:	9a 83       	std	Y+2, r25	; 0x02
    1aee:	89 83       	std	Y+1, r24	; 0x01
    1af0:	89 81       	ldd	r24, Y+1	; 0x01
    1af2:	9a 81       	ldd	r25, Y+2	; 0x02
    1af4:	01 97       	sbiw	r24, 0x01	; 1
    1af6:	f1 f7       	brne	.-4      	; 0x1af4 <HCLCD_Vid8Bits_Init+0x3ca>
    1af8:	9a 83       	std	Y+2, r25	; 0x02
    1afa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_ENTRY_MODE_SET);
    1afc:	86 e0       	ldi	r24, 0x06	; 6
    1afe:	0e 94 85 0a 	call	0x150a	; 0x150a <HCLCD_VidWriteCommand_8Bits>
}
    1b02:	e8 96       	adiw	r28, 0x38	; 56
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	de bf       	out	0x3e, r29	; 62
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	cd bf       	out	0x3d, r28	; 61
    1b0e:	cf 91       	pop	r28
    1b10:	df 91       	pop	r29
    1b12:	08 95       	ret

00001b14 <HCLCD_VidWriteChar_8Bits>:
void HCLCD_VidWriteChar_8Bits(u8 Copy_u8Data)
{
    1b14:	df 93       	push	r29
    1b16:	cf 93       	push	r28
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	6d 97       	sbiw	r28, 0x1d	; 29
    1b1e:	0f b6       	in	r0, 0x3f	; 63
    1b20:	f8 94       	cli
    1b22:	de bf       	out	0x3e, r29	; 62
    1b24:	0f be       	out	0x3f, r0	; 63
    1b26:	cd bf       	out	0x3d, r28	; 61
    1b28:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Data register--> Write one on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	61 e0       	ldi	r22, 0x01	; 1
    1b2e:	41 e0       	ldi	r20, 0x01	; 1
    1b30:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Data);
    1b34:	80 e0       	ldi	r24, 0x00	; 0
    1b36:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1b38:	0e 94 15 08 	call	0x102a	; 0x102a <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1b3c:	83 e0       	ldi	r24, 0x03	; 3
    1b3e:	61 e0       	ldi	r22, 0x01	; 1
    1b40:	41 e0       	ldi	r20, 0x01	; 1
    1b42:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
    1b46:	80 e0       	ldi	r24, 0x00	; 0
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	a0 e0       	ldi	r26, 0x00	; 0
    1b4c:	b0 e4       	ldi	r27, 0x40	; 64
    1b4e:	89 8f       	std	Y+25, r24	; 0x19
    1b50:	9a 8f       	std	Y+26, r25	; 0x1a
    1b52:	ab 8f       	std	Y+27, r26	; 0x1b
    1b54:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b56:	69 8d       	ldd	r22, Y+25	; 0x19
    1b58:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1b5a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b5c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b5e:	20 e0       	ldi	r18, 0x00	; 0
    1b60:	30 e0       	ldi	r19, 0x00	; 0
    1b62:	4a e7       	ldi	r20, 0x7A	; 122
    1b64:	53 e4       	ldi	r21, 0x43	; 67
    1b66:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b6a:	dc 01       	movw	r26, r24
    1b6c:	cb 01       	movw	r24, r22
    1b6e:	8d 8b       	std	Y+21, r24	; 0x15
    1b70:	9e 8b       	std	Y+22, r25	; 0x16
    1b72:	af 8b       	std	Y+23, r26	; 0x17
    1b74:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1b76:	6d 89       	ldd	r22, Y+21	; 0x15
    1b78:	7e 89       	ldd	r23, Y+22	; 0x16
    1b7a:	8f 89       	ldd	r24, Y+23	; 0x17
    1b7c:	98 8d       	ldd	r25, Y+24	; 0x18
    1b7e:	20 e0       	ldi	r18, 0x00	; 0
    1b80:	30 e0       	ldi	r19, 0x00	; 0
    1b82:	40 e8       	ldi	r20, 0x80	; 128
    1b84:	5f e3       	ldi	r21, 0x3F	; 63
    1b86:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b8a:	88 23       	and	r24, r24
    1b8c:	2c f4       	brge	.+10     	; 0x1b98 <HCLCD_VidWriteChar_8Bits+0x84>
		__ticks = 1;
    1b8e:	81 e0       	ldi	r24, 0x01	; 1
    1b90:	90 e0       	ldi	r25, 0x00	; 0
    1b92:	9c 8b       	std	Y+20, r25	; 0x14
    1b94:	8b 8b       	std	Y+19, r24	; 0x13
    1b96:	3f c0       	rjmp	.+126    	; 0x1c16 <HCLCD_VidWriteChar_8Bits+0x102>
	else if (__tmp > 65535)
    1b98:	6d 89       	ldd	r22, Y+21	; 0x15
    1b9a:	7e 89       	ldd	r23, Y+22	; 0x16
    1b9c:	8f 89       	ldd	r24, Y+23	; 0x17
    1b9e:	98 8d       	ldd	r25, Y+24	; 0x18
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	3f ef       	ldi	r19, 0xFF	; 255
    1ba4:	4f e7       	ldi	r20, 0x7F	; 127
    1ba6:	57 e4       	ldi	r21, 0x47	; 71
    1ba8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1bac:	18 16       	cp	r1, r24
    1bae:	4c f5       	brge	.+82     	; 0x1c02 <HCLCD_VidWriteChar_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bb0:	69 8d       	ldd	r22, Y+25	; 0x19
    1bb2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1bb4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1bb6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1bb8:	20 e0       	ldi	r18, 0x00	; 0
    1bba:	30 e0       	ldi	r19, 0x00	; 0
    1bbc:	40 e2       	ldi	r20, 0x20	; 32
    1bbe:	51 e4       	ldi	r21, 0x41	; 65
    1bc0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bc4:	dc 01       	movw	r26, r24
    1bc6:	cb 01       	movw	r24, r22
    1bc8:	bc 01       	movw	r22, r24
    1bca:	cd 01       	movw	r24, r26
    1bcc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bd0:	dc 01       	movw	r26, r24
    1bd2:	cb 01       	movw	r24, r22
    1bd4:	9c 8b       	std	Y+20, r25	; 0x14
    1bd6:	8b 8b       	std	Y+19, r24	; 0x13
    1bd8:	0f c0       	rjmp	.+30     	; 0x1bf8 <HCLCD_VidWriteChar_8Bits+0xe4>
    1bda:	89 e1       	ldi	r24, 0x19	; 25
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	9a 8b       	std	Y+18, r25	; 0x12
    1be0:	89 8b       	std	Y+17, r24	; 0x11
    1be2:	89 89       	ldd	r24, Y+17	; 0x11
    1be4:	9a 89       	ldd	r25, Y+18	; 0x12
    1be6:	01 97       	sbiw	r24, 0x01	; 1
    1be8:	f1 f7       	brne	.-4      	; 0x1be6 <HCLCD_VidWriteChar_8Bits+0xd2>
    1bea:	9a 8b       	std	Y+18, r25	; 0x12
    1bec:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bee:	8b 89       	ldd	r24, Y+19	; 0x13
    1bf0:	9c 89       	ldd	r25, Y+20	; 0x14
    1bf2:	01 97       	sbiw	r24, 0x01	; 1
    1bf4:	9c 8b       	std	Y+20, r25	; 0x14
    1bf6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bf8:	8b 89       	ldd	r24, Y+19	; 0x13
    1bfa:	9c 89       	ldd	r25, Y+20	; 0x14
    1bfc:	00 97       	sbiw	r24, 0x00	; 0
    1bfe:	69 f7       	brne	.-38     	; 0x1bda <HCLCD_VidWriteChar_8Bits+0xc6>
    1c00:	14 c0       	rjmp	.+40     	; 0x1c2a <HCLCD_VidWriteChar_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c02:	6d 89       	ldd	r22, Y+21	; 0x15
    1c04:	7e 89       	ldd	r23, Y+22	; 0x16
    1c06:	8f 89       	ldd	r24, Y+23	; 0x17
    1c08:	98 8d       	ldd	r25, Y+24	; 0x18
    1c0a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c0e:	dc 01       	movw	r26, r24
    1c10:	cb 01       	movw	r24, r22
    1c12:	9c 8b       	std	Y+20, r25	; 0x14
    1c14:	8b 8b       	std	Y+19, r24	; 0x13
    1c16:	8b 89       	ldd	r24, Y+19	; 0x13
    1c18:	9c 89       	ldd	r25, Y+20	; 0x14
    1c1a:	98 8b       	std	Y+16, r25	; 0x10
    1c1c:	8f 87       	std	Y+15, r24	; 0x0f
    1c1e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c20:	98 89       	ldd	r25, Y+16	; 0x10
    1c22:	01 97       	sbiw	r24, 0x01	; 1
    1c24:	f1 f7       	brne	.-4      	; 0x1c22 <HCLCD_VidWriteChar_8Bits+0x10e>
    1c26:	98 8b       	std	Y+16, r25	; 0x10
    1c28:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    1c2a:	83 e0       	ldi	r24, 0x03	; 3
    1c2c:	61 e0       	ldi	r22, 0x01	; 1
    1c2e:	40 e0       	ldi	r20, 0x00	; 0
    1c30:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
    1c34:	80 e0       	ldi	r24, 0x00	; 0
    1c36:	90 e0       	ldi	r25, 0x00	; 0
    1c38:	a0 e0       	ldi	r26, 0x00	; 0
    1c3a:	b0 e4       	ldi	r27, 0x40	; 64
    1c3c:	8b 87       	std	Y+11, r24	; 0x0b
    1c3e:	9c 87       	std	Y+12, r25	; 0x0c
    1c40:	ad 87       	std	Y+13, r26	; 0x0d
    1c42:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c44:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c46:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c48:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c4c:	20 e0       	ldi	r18, 0x00	; 0
    1c4e:	30 e0       	ldi	r19, 0x00	; 0
    1c50:	4a e7       	ldi	r20, 0x7A	; 122
    1c52:	53 e4       	ldi	r21, 0x43	; 67
    1c54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c58:	dc 01       	movw	r26, r24
    1c5a:	cb 01       	movw	r24, r22
    1c5c:	8f 83       	std	Y+7, r24	; 0x07
    1c5e:	98 87       	std	Y+8, r25	; 0x08
    1c60:	a9 87       	std	Y+9, r26	; 0x09
    1c62:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1c64:	6f 81       	ldd	r22, Y+7	; 0x07
    1c66:	78 85       	ldd	r23, Y+8	; 0x08
    1c68:	89 85       	ldd	r24, Y+9	; 0x09
    1c6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c6c:	20 e0       	ldi	r18, 0x00	; 0
    1c6e:	30 e0       	ldi	r19, 0x00	; 0
    1c70:	40 e8       	ldi	r20, 0x80	; 128
    1c72:	5f e3       	ldi	r21, 0x3F	; 63
    1c74:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c78:	88 23       	and	r24, r24
    1c7a:	2c f4       	brge	.+10     	; 0x1c86 <HCLCD_VidWriteChar_8Bits+0x172>
		__ticks = 1;
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	9e 83       	std	Y+6, r25	; 0x06
    1c82:	8d 83       	std	Y+5, r24	; 0x05
    1c84:	3f c0       	rjmp	.+126    	; 0x1d04 <HCLCD_VidWriteChar_8Bits+0x1f0>
	else if (__tmp > 65535)
    1c86:	6f 81       	ldd	r22, Y+7	; 0x07
    1c88:	78 85       	ldd	r23, Y+8	; 0x08
    1c8a:	89 85       	ldd	r24, Y+9	; 0x09
    1c8c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c8e:	20 e0       	ldi	r18, 0x00	; 0
    1c90:	3f ef       	ldi	r19, 0xFF	; 255
    1c92:	4f e7       	ldi	r20, 0x7F	; 127
    1c94:	57 e4       	ldi	r21, 0x47	; 71
    1c96:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c9a:	18 16       	cp	r1, r24
    1c9c:	4c f5       	brge	.+82     	; 0x1cf0 <HCLCD_VidWriteChar_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c9e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ca0:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ca2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ca4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ca6:	20 e0       	ldi	r18, 0x00	; 0
    1ca8:	30 e0       	ldi	r19, 0x00	; 0
    1caa:	40 e2       	ldi	r20, 0x20	; 32
    1cac:	51 e4       	ldi	r21, 0x41	; 65
    1cae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cb2:	dc 01       	movw	r26, r24
    1cb4:	cb 01       	movw	r24, r22
    1cb6:	bc 01       	movw	r22, r24
    1cb8:	cd 01       	movw	r24, r26
    1cba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cbe:	dc 01       	movw	r26, r24
    1cc0:	cb 01       	movw	r24, r22
    1cc2:	9e 83       	std	Y+6, r25	; 0x06
    1cc4:	8d 83       	std	Y+5, r24	; 0x05
    1cc6:	0f c0       	rjmp	.+30     	; 0x1ce6 <HCLCD_VidWriteChar_8Bits+0x1d2>
    1cc8:	89 e1       	ldi	r24, 0x19	; 25
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	9c 83       	std	Y+4, r25	; 0x04
    1cce:	8b 83       	std	Y+3, r24	; 0x03
    1cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd4:	01 97       	sbiw	r24, 0x01	; 1
    1cd6:	f1 f7       	brne	.-4      	; 0x1cd4 <HCLCD_VidWriteChar_8Bits+0x1c0>
    1cd8:	9c 83       	std	Y+4, r25	; 0x04
    1cda:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cdc:	8d 81       	ldd	r24, Y+5	; 0x05
    1cde:	9e 81       	ldd	r25, Y+6	; 0x06
    1ce0:	01 97       	sbiw	r24, 0x01	; 1
    1ce2:	9e 83       	std	Y+6, r25	; 0x06
    1ce4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cea:	00 97       	sbiw	r24, 0x00	; 0
    1cec:	69 f7       	brne	.-38     	; 0x1cc8 <HCLCD_VidWriteChar_8Bits+0x1b4>
    1cee:	14 c0       	rjmp	.+40     	; 0x1d18 <HCLCD_VidWriteChar_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1cf0:	6f 81       	ldd	r22, Y+7	; 0x07
    1cf2:	78 85       	ldd	r23, Y+8	; 0x08
    1cf4:	89 85       	ldd	r24, Y+9	; 0x09
    1cf6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cf8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cfc:	dc 01       	movw	r26, r24
    1cfe:	cb 01       	movw	r24, r22
    1d00:	9e 83       	std	Y+6, r25	; 0x06
    1d02:	8d 83       	std	Y+5, r24	; 0x05
    1d04:	8d 81       	ldd	r24, Y+5	; 0x05
    1d06:	9e 81       	ldd	r25, Y+6	; 0x06
    1d08:	9a 83       	std	Y+2, r25	; 0x02
    1d0a:	89 83       	std	Y+1, r24	; 0x01
    1d0c:	89 81       	ldd	r24, Y+1	; 0x01
    1d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d10:	01 97       	sbiw	r24, 0x01	; 1
    1d12:	f1 f7       	brne	.-4      	; 0x1d10 <HCLCD_VidWriteChar_8Bits+0x1fc>
    1d14:	9a 83       	std	Y+2, r25	; 0x02
    1d16:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    1d18:	83 e0       	ldi	r24, 0x03	; 3
    1d1a:	61 e0       	ldi	r22, 0x01	; 1
    1d1c:	41 e0       	ldi	r20, 0x01	; 1
    1d1e:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
}
    1d22:	6d 96       	adiw	r28, 0x1d	; 29
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	de bf       	out	0x3e, r29	; 62
    1d2a:	0f be       	out	0x3f, r0	; 63
    1d2c:	cd bf       	out	0x3d, r28	; 61
    1d2e:	cf 91       	pop	r28
    1d30:	df 91       	pop	r29
    1d32:	08 95       	ret

00001d34 <HCLCD_VidWriteString_8Bits>:

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
    1d34:	df 93       	push	r29
    1d36:	cf 93       	push	r28
    1d38:	00 d0       	rcall	.+0      	; 0x1d3a <HCLCD_VidWriteString_8Bits+0x6>
    1d3a:	0f 92       	push	r0
    1d3c:	cd b7       	in	r28, 0x3d	; 61
    1d3e:	de b7       	in	r29, 0x3e	; 62
    1d40:	9b 83       	std	Y+3, r25	; 0x03
    1d42:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    1d44:	19 82       	std	Y+1, r1	; 0x01
    1d46:	0e c0       	rjmp	.+28     	; 0x1d64 <HCLCD_VidWriteString_8Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
    1d48:	89 81       	ldd	r24, Y+1	; 0x01
    1d4a:	28 2f       	mov	r18, r24
    1d4c:	30 e0       	ldi	r19, 0x00	; 0
    1d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d50:	9b 81       	ldd	r25, Y+3	; 0x03
    1d52:	fc 01       	movw	r30, r24
    1d54:	e2 0f       	add	r30, r18
    1d56:	f3 1f       	adc	r31, r19
    1d58:	80 81       	ld	r24, Z
    1d5a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <HCLCD_VidWriteChar_8Bits>
		Loc_u8Count++;
    1d5e:	89 81       	ldd	r24, Y+1	; 0x01
    1d60:	8f 5f       	subi	r24, 0xFF	; 255
    1d62:	89 83       	std	Y+1, r24	; 0x01
}

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    1d64:	89 81       	ldd	r24, Y+1	; 0x01
    1d66:	28 2f       	mov	r18, r24
    1d68:	30 e0       	ldi	r19, 0x00	; 0
    1d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d6c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d6e:	fc 01       	movw	r30, r24
    1d70:	e2 0f       	add	r30, r18
    1d72:	f3 1f       	adc	r31, r19
    1d74:	80 81       	ld	r24, Z
    1d76:	88 23       	and	r24, r24
    1d78:	39 f7       	brne	.-50     	; 0x1d48 <HCLCD_VidWriteString_8Bits+0x14>
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    1d7a:	0f 90       	pop	r0
    1d7c:	0f 90       	pop	r0
    1d7e:	0f 90       	pop	r0
    1d80:	cf 91       	pop	r28
    1d82:	df 91       	pop	r29
    1d84:	08 95       	ret

00001d86 <HCLCD_VidWriteNumber_8Bits>:
void HCLCD_VidWriteNumber_8Bits(u32 Copy_u8Number)
{
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	df 93       	push	r29
    1d8c:	cf 93       	push	r28
    1d8e:	cd b7       	in	r28, 0x3d	; 61
    1d90:	de b7       	in	r29, 0x3e	; 62
    1d92:	60 97       	sbiw	r28, 0x10	; 16
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	de bf       	out	0x3e, r29	; 62
    1d9a:	0f be       	out	0x3f, r0	; 63
    1d9c:	cd bf       	out	0x3d, r28	; 61
    1d9e:	6d 87       	std	Y+13, r22	; 0x0d
    1da0:	7e 87       	std	Y+14, r23	; 0x0e
    1da2:	8f 87       	std	Y+15, r24	; 0x0f
    1da4:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    1da6:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    1da8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1daa:	9e 85       	ldd	r25, Y+14	; 0x0e
    1dac:	af 85       	ldd	r26, Y+15	; 0x0f
    1dae:	b8 89       	ldd	r27, Y+16	; 0x10
    1db0:	00 97       	sbiw	r24, 0x00	; 0
    1db2:	a1 05       	cpc	r26, r1
    1db4:	b1 05       	cpc	r27, r1
    1db6:	09 f4       	brne	.+2      	; 0x1dba <HCLCD_VidWriteNumber_8Bits+0x34>
    1db8:	4f c0       	rjmp	.+158    	; 0x1e58 <HCLCD_VidWriteNumber_8Bits+0xd2>
    1dba:	2d c0       	rjmp	.+90     	; 0x1e16 <HCLCD_VidWriteNumber_8Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    1dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dbe:	08 2f       	mov	r16, r24
    1dc0:	10 e0       	ldi	r17, 0x00	; 0
    1dc2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1dc4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1dc6:	af 85       	ldd	r26, Y+15	; 0x0f
    1dc8:	b8 89       	ldd	r27, Y+16	; 0x10
    1dca:	2a e0       	ldi	r18, 0x0A	; 10
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	40 e0       	ldi	r20, 0x00	; 0
    1dd0:	50 e0       	ldi	r21, 0x00	; 0
    1dd2:	bc 01       	movw	r22, r24
    1dd4:	cd 01       	movw	r24, r26
    1dd6:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <__udivmodsi4>
    1dda:	dc 01       	movw	r26, r24
    1ddc:	cb 01       	movw	r24, r22
    1dde:	28 2f       	mov	r18, r24
    1de0:	ce 01       	movw	r24, r28
    1de2:	03 96       	adiw	r24, 0x03	; 3
    1de4:	fc 01       	movw	r30, r24
    1de6:	e0 0f       	add	r30, r16
    1de8:	f1 1f       	adc	r31, r17
    1dea:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    1dec:	8d 85       	ldd	r24, Y+13	; 0x0d
    1dee:	9e 85       	ldd	r25, Y+14	; 0x0e
    1df0:	af 85       	ldd	r26, Y+15	; 0x0f
    1df2:	b8 89       	ldd	r27, Y+16	; 0x10
    1df4:	2a e0       	ldi	r18, 0x0A	; 10
    1df6:	30 e0       	ldi	r19, 0x00	; 0
    1df8:	40 e0       	ldi	r20, 0x00	; 0
    1dfa:	50 e0       	ldi	r21, 0x00	; 0
    1dfc:	bc 01       	movw	r22, r24
    1dfe:	cd 01       	movw	r24, r26
    1e00:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <__udivmodsi4>
    1e04:	da 01       	movw	r26, r20
    1e06:	c9 01       	movw	r24, r18
    1e08:	8d 87       	std	Y+13, r24	; 0x0d
    1e0a:	9e 87       	std	Y+14, r25	; 0x0e
    1e0c:	af 87       	std	Y+15, r26	; 0x0f
    1e0e:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    1e10:	8a 81       	ldd	r24, Y+2	; 0x02
    1e12:	8f 5f       	subi	r24, 0xFF	; 255
    1e14:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    1e16:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e18:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e1a:	af 85       	ldd	r26, Y+15	; 0x0f
    1e1c:	b8 89       	ldd	r27, Y+16	; 0x10
    1e1e:	00 97       	sbiw	r24, 0x00	; 0
    1e20:	a1 05       	cpc	r26, r1
    1e22:	b1 05       	cpc	r27, r1
    1e24:	59 f6       	brne	.-106    	; 0x1dbc <HCLCD_VidWriteNumber_8Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    1e26:	8a 81       	ldd	r24, Y+2	; 0x02
    1e28:	81 50       	subi	r24, 0x01	; 1
    1e2a:	89 83       	std	Y+1, r24	; 0x01
    1e2c:	11 c0       	rjmp	.+34     	; 0x1e50 <HCLCD_VidWriteNumber_8Bits+0xca>
		{
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
    1e2e:	89 81       	ldd	r24, Y+1	; 0x01
    1e30:	28 2f       	mov	r18, r24
    1e32:	33 27       	eor	r19, r19
    1e34:	27 fd       	sbrc	r18, 7
    1e36:	30 95       	com	r19
    1e38:	ce 01       	movw	r24, r28
    1e3a:	03 96       	adiw	r24, 0x03	; 3
    1e3c:	fc 01       	movw	r30, r24
    1e3e:	e2 0f       	add	r30, r18
    1e40:	f3 1f       	adc	r31, r19
    1e42:	80 81       	ld	r24, Z
    1e44:	80 5d       	subi	r24, 0xD0	; 208
    1e46:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <HCLCD_VidWriteChar_8Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    1e4a:	89 81       	ldd	r24, Y+1	; 0x01
    1e4c:	81 50       	subi	r24, 0x01	; 1
    1e4e:	89 83       	std	Y+1, r24	; 0x01
    1e50:	89 81       	ldd	r24, Y+1	; 0x01
    1e52:	88 23       	and	r24, r24
    1e54:	64 f7       	brge	.-40     	; 0x1e2e <HCLCD_VidWriteNumber_8Bits+0xa8>
    1e56:	03 c0       	rjmp	.+6      	; 0x1e5e <HCLCD_VidWriteNumber_8Bits+0xd8>
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    1e58:	80 e3       	ldi	r24, 0x30	; 48
    1e5a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <HCLCD_VidWriteChar_8Bits>
	}
}
    1e5e:	60 96       	adiw	r28, 0x10	; 16
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	de bf       	out	0x3e, r29	; 62
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	cd bf       	out	0x3d, r28	; 61
    1e6a:	cf 91       	pop	r28
    1e6c:	df 91       	pop	r29
    1e6e:	1f 91       	pop	r17
    1e70:	0f 91       	pop	r16
    1e72:	08 95       	ret

00001e74 <HCLCD_VidSetPosition>:
void HCLCD_VidSetPosition(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	00 d0       	rcall	.+0      	; 0x1e7a <HCLCD_VidSetPosition+0x6>
    1e7a:	cd b7       	in	r28, 0x3d	; 61
    1e7c:	de b7       	in	r29, 0x3e	; 62
    1e7e:	89 83       	std	Y+1, r24	; 0x01
    1e80:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    1e82:	89 81       	ldd	r24, Y+1	; 0x01
    1e84:	81 30       	cpi	r24, 0x01	; 1
    1e86:	41 f4       	brne	.+16     	; 0x1e98 <HCLCD_VidSetPosition+0x24>
    1e88:	8a 81       	ldd	r24, Y+2	; 0x02
    1e8a:	80 31       	cpi	r24, 0x10	; 16
    1e8c:	28 f4       	brcc	.+10     	; 0x1e98 <HCLCD_VidSetPosition+0x24>
	{
		HCLCD_VidWriteCommand_8Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    1e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e90:	80 58       	subi	r24, 0x80	; 128
    1e92:	0e 94 85 0a 	call	0x150a	; 0x150a <HCLCD_VidWriteCommand_8Bits>
    1e96:	0a c0       	rjmp	.+20     	; 0x1eac <HCLCD_VidSetPosition+0x38>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	82 30       	cpi	r24, 0x02	; 2
    1e9c:	39 f4       	brne	.+14     	; 0x1eac <HCLCD_VidSetPosition+0x38>
    1e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea0:	80 31       	cpi	r24, 0x10	; 16
    1ea2:	20 f4       	brcc	.+8      	; 0x1eac <HCLCD_VidSetPosition+0x38>
	{
		HCLCD_VidWriteCommand_8Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    1ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea6:	80 54       	subi	r24, 0x40	; 64
    1ea8:	0e 94 85 0a 	call	0x150a	; 0x150a <HCLCD_VidWriteCommand_8Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    1eac:	0f 90       	pop	r0
    1eae:	0f 90       	pop	r0
    1eb0:	cf 91       	pop	r28
    1eb2:	df 91       	pop	r29
    1eb4:	08 95       	ret

00001eb6 <HCLCD_VidWriteCommand_4Bits>:

void HCLCD_VidWriteCommand_4Bits(u8 Copy_u8Command)
{
    1eb6:	df 93       	push	r29
    1eb8:	cf 93       	push	r28
    1eba:	cd b7       	in	r28, 0x3d	; 61
    1ebc:	de b7       	in	r29, 0x3e	; 62
    1ebe:	60 97       	sbiw	r28, 0x10	; 16
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
    1eca:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyCommand;
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    1ecc:	81 e0       	ldi	r24, 0x01	; 1
    1ece:	61 e0       	ldi	r22, 0x01	; 1
    1ed0:	40 e0       	ldi	r20, 0x00	; 0
    1ed2:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send  Command*/
	LOC_u8CopyCommand=(Copy_u8Command&0x0F)<<HCLCD_PINSTART;
    1ed6:	88 89       	ldd	r24, Y+16	; 0x10
    1ed8:	88 2f       	mov	r24, r24
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	82 95       	swap	r24
    1ede:	92 95       	swap	r25
    1ee0:	90 7f       	andi	r25, 0xF0	; 240
    1ee2:	98 27       	eor	r25, r24
    1ee4:	80 7f       	andi	r24, 0xF0	; 240
    1ee6:	98 27       	eor	r25, r24
    1ee8:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyCommand);
    1eea:	84 e0       	ldi	r24, 0x04	; 4
    1eec:	60 e0       	ldi	r22, 0x00	; 0
    1eee:	4f 85       	ldd	r20, Y+15	; 0x0f
    1ef0:	0e 94 f5 08 	call	0x11ea	; 0x11ea <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1ef4:	83 e0       	ldi	r24, 0x03	; 3
    1ef6:	61 e0       	ldi	r22, 0x01	; 1
    1ef8:	41 e0       	ldi	r20, 0x01	; 1
    1efa:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
    1efe:	80 e0       	ldi	r24, 0x00	; 0
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	a0 e0       	ldi	r26, 0x00	; 0
    1f04:	b0 e4       	ldi	r27, 0x40	; 64
    1f06:	8b 87       	std	Y+11, r24	; 0x0b
    1f08:	9c 87       	std	Y+12, r25	; 0x0c
    1f0a:	ad 87       	std	Y+13, r26	; 0x0d
    1f0c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f0e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f10:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f12:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f14:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f16:	20 e0       	ldi	r18, 0x00	; 0
    1f18:	30 e0       	ldi	r19, 0x00	; 0
    1f1a:	4a e7       	ldi	r20, 0x7A	; 122
    1f1c:	53 e4       	ldi	r21, 0x43	; 67
    1f1e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f22:	dc 01       	movw	r26, r24
    1f24:	cb 01       	movw	r24, r22
    1f26:	8f 83       	std	Y+7, r24	; 0x07
    1f28:	98 87       	std	Y+8, r25	; 0x08
    1f2a:	a9 87       	std	Y+9, r26	; 0x09
    1f2c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f2e:	6f 81       	ldd	r22, Y+7	; 0x07
    1f30:	78 85       	ldd	r23, Y+8	; 0x08
    1f32:	89 85       	ldd	r24, Y+9	; 0x09
    1f34:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f36:	20 e0       	ldi	r18, 0x00	; 0
    1f38:	30 e0       	ldi	r19, 0x00	; 0
    1f3a:	40 e8       	ldi	r20, 0x80	; 128
    1f3c:	5f e3       	ldi	r21, 0x3F	; 63
    1f3e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1f42:	88 23       	and	r24, r24
    1f44:	2c f4       	brge	.+10     	; 0x1f50 <HCLCD_VidWriteCommand_4Bits+0x9a>
		__ticks = 1;
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	9e 83       	std	Y+6, r25	; 0x06
    1f4c:	8d 83       	std	Y+5, r24	; 0x05
    1f4e:	3f c0       	rjmp	.+126    	; 0x1fce <HCLCD_VidWriteCommand_4Bits+0x118>
	else if (__tmp > 65535)
    1f50:	6f 81       	ldd	r22, Y+7	; 0x07
    1f52:	78 85       	ldd	r23, Y+8	; 0x08
    1f54:	89 85       	ldd	r24, Y+9	; 0x09
    1f56:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f58:	20 e0       	ldi	r18, 0x00	; 0
    1f5a:	3f ef       	ldi	r19, 0xFF	; 255
    1f5c:	4f e7       	ldi	r20, 0x7F	; 127
    1f5e:	57 e4       	ldi	r21, 0x47	; 71
    1f60:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1f64:	18 16       	cp	r1, r24
    1f66:	4c f5       	brge	.+82     	; 0x1fba <HCLCD_VidWriteCommand_4Bits+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f68:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f6a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f70:	20 e0       	ldi	r18, 0x00	; 0
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	40 e2       	ldi	r20, 0x20	; 32
    1f76:	51 e4       	ldi	r21, 0x41	; 65
    1f78:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f7c:	dc 01       	movw	r26, r24
    1f7e:	cb 01       	movw	r24, r22
    1f80:	bc 01       	movw	r22, r24
    1f82:	cd 01       	movw	r24, r26
    1f84:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f88:	dc 01       	movw	r26, r24
    1f8a:	cb 01       	movw	r24, r22
    1f8c:	9e 83       	std	Y+6, r25	; 0x06
    1f8e:	8d 83       	std	Y+5, r24	; 0x05
    1f90:	0f c0       	rjmp	.+30     	; 0x1fb0 <HCLCD_VidWriteCommand_4Bits+0xfa>
    1f92:	89 e1       	ldi	r24, 0x19	; 25
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	9c 83       	std	Y+4, r25	; 0x04
    1f98:	8b 83       	std	Y+3, r24	; 0x03
    1f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9e:	01 97       	sbiw	r24, 0x01	; 1
    1fa0:	f1 f7       	brne	.-4      	; 0x1f9e <HCLCD_VidWriteCommand_4Bits+0xe8>
    1fa2:	9c 83       	std	Y+4, r25	; 0x04
    1fa4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1fa6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fa8:	9e 81       	ldd	r25, Y+6	; 0x06
    1faa:	01 97       	sbiw	r24, 0x01	; 1
    1fac:	9e 83       	std	Y+6, r25	; 0x06
    1fae:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    1fb4:	00 97       	sbiw	r24, 0x00	; 0
    1fb6:	69 f7       	brne	.-38     	; 0x1f92 <HCLCD_VidWriteCommand_4Bits+0xdc>
    1fb8:	14 c0       	rjmp	.+40     	; 0x1fe2 <HCLCD_VidWriteCommand_4Bits+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1fba:	6f 81       	ldd	r22, Y+7	; 0x07
    1fbc:	78 85       	ldd	r23, Y+8	; 0x08
    1fbe:	89 85       	ldd	r24, Y+9	; 0x09
    1fc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fc2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	cb 01       	movw	r24, r22
    1fca:	9e 83       	std	Y+6, r25	; 0x06
    1fcc:	8d 83       	std	Y+5, r24	; 0x05
    1fce:	8d 81       	ldd	r24, Y+5	; 0x05
    1fd0:	9e 81       	ldd	r25, Y+6	; 0x06
    1fd2:	9a 83       	std	Y+2, r25	; 0x02
    1fd4:	89 83       	std	Y+1, r24	; 0x01
    1fd6:	89 81       	ldd	r24, Y+1	; 0x01
    1fd8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fda:	01 97       	sbiw	r24, 0x01	; 1
    1fdc:	f1 f7       	brne	.-4      	; 0x1fda <HCLCD_VidWriteCommand_4Bits+0x124>
    1fde:	9a 83       	std	Y+2, r25	; 0x02
    1fe0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    1fe2:	83 e0       	ldi	r24, 0x03	; 3
    1fe4:	61 e0       	ldi	r22, 0x01	; 1
    1fe6:	40 e0       	ldi	r20, 0x00	; 0
    1fe8:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
}
    1fec:	60 96       	adiw	r28, 0x10	; 16
    1fee:	0f b6       	in	r0, 0x3f	; 63
    1ff0:	f8 94       	cli
    1ff2:	de bf       	out	0x3e, r29	; 62
    1ff4:	0f be       	out	0x3f, r0	; 63
    1ff6:	cd bf       	out	0x3d, r28	; 61
    1ff8:	cf 91       	pop	r28
    1ffa:	df 91       	pop	r29
    1ffc:	08 95       	ret

00001ffe <HCLCD_Vid4Bits_Init>:
void HCLCD_Vid4Bits_Init(void)
{
    1ffe:	df 93       	push	r29
    2000:	cf 93       	push	r28
    2002:	cd b7       	in	r28, 0x3d	; 61
    2004:	de b7       	in	r29, 0x3e	; 62
    2006:	e9 97       	sbiw	r28, 0x39	; 57
    2008:	0f b6       	in	r0, 0x3f	; 63
    200a:	f8 94       	cli
    200c:	de bf       	out	0x3e, r29	; 62
    200e:	0f be       	out	0x3f, r0	; 63
    2010:	cd bf       	out	0x3d, r28	; 61
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    2012:	87 e0       	ldi	r24, 0x07	; 7
    2014:	89 af       	std	Y+57, r24	; 0x39
    2016:	08 c0       	rjmp	.+16     	; 0x2028 <HCLCD_Vid4Bits_Init+0x2a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
    2018:	89 ad       	ldd	r24, Y+57	; 0x39
    201a:	60 e0       	ldi	r22, 0x00	; 0
    201c:	41 e0       	ldi	r20, 0x01	; 1
    201e:	0e 94 bf 05 	call	0xb7e	; 0xb7e <MDIO_Error_State_SetPinDirection>
}
void HCLCD_Vid4Bits_Init(void)
{
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    2022:	89 ad       	ldd	r24, Y+57	; 0x39
    2024:	81 50       	subi	r24, 0x01	; 1
    2026:	89 af       	std	Y+57, r24	; 0x39
    2028:	89 ad       	ldd	r24, Y+57	; 0x39
    202a:	84 30       	cpi	r24, 0x04	; 4
    202c:	ac f7       	brge	.-22     	; 0x2018 <HCLCD_Vid4Bits_Init+0x1a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
	}
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	61 e0       	ldi	r22, 0x01	; 1
    2032:	41 e0       	ldi	r20, 0x01	; 1
    2034:	0e 94 bf 05 	call	0xb7e	; 0xb7e <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    2038:	83 e0       	ldi	r24, 0x03	; 3
    203a:	61 e0       	ldi	r22, 0x01	; 1
    203c:	41 e0       	ldi	r20, 0x01	; 1
    203e:	0e 94 bf 05 	call	0xb7e	; 0xb7e <MDIO_Error_State_SetPinDirection>
    2042:	80 e0       	ldi	r24, 0x00	; 0
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	a0 ef       	ldi	r26, 0xF0	; 240
    2048:	b1 e4       	ldi	r27, 0x41	; 65
    204a:	8d ab       	std	Y+53, r24	; 0x35
    204c:	9e ab       	std	Y+54, r25	; 0x36
    204e:	af ab       	std	Y+55, r26	; 0x37
    2050:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2052:	6d a9       	ldd	r22, Y+53	; 0x35
    2054:	7e a9       	ldd	r23, Y+54	; 0x36
    2056:	8f a9       	ldd	r24, Y+55	; 0x37
    2058:	98 ad       	ldd	r25, Y+56	; 0x38
    205a:	20 e0       	ldi	r18, 0x00	; 0
    205c:	30 e0       	ldi	r19, 0x00	; 0
    205e:	4a e7       	ldi	r20, 0x7A	; 122
    2060:	53 e4       	ldi	r21, 0x43	; 67
    2062:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2066:	dc 01       	movw	r26, r24
    2068:	cb 01       	movw	r24, r22
    206a:	89 ab       	std	Y+49, r24	; 0x31
    206c:	9a ab       	std	Y+50, r25	; 0x32
    206e:	ab ab       	std	Y+51, r26	; 0x33
    2070:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2072:	69 a9       	ldd	r22, Y+49	; 0x31
    2074:	7a a9       	ldd	r23, Y+50	; 0x32
    2076:	8b a9       	ldd	r24, Y+51	; 0x33
    2078:	9c a9       	ldd	r25, Y+52	; 0x34
    207a:	20 e0       	ldi	r18, 0x00	; 0
    207c:	30 e0       	ldi	r19, 0x00	; 0
    207e:	40 e8       	ldi	r20, 0x80	; 128
    2080:	5f e3       	ldi	r21, 0x3F	; 63
    2082:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2086:	88 23       	and	r24, r24
    2088:	2c f4       	brge	.+10     	; 0x2094 <HCLCD_Vid4Bits_Init+0x96>
		__ticks = 1;
    208a:	81 e0       	ldi	r24, 0x01	; 1
    208c:	90 e0       	ldi	r25, 0x00	; 0
    208e:	98 ab       	std	Y+48, r25	; 0x30
    2090:	8f a7       	std	Y+47, r24	; 0x2f
    2092:	3f c0       	rjmp	.+126    	; 0x2112 <HCLCD_Vid4Bits_Init+0x114>
	else if (__tmp > 65535)
    2094:	69 a9       	ldd	r22, Y+49	; 0x31
    2096:	7a a9       	ldd	r23, Y+50	; 0x32
    2098:	8b a9       	ldd	r24, Y+51	; 0x33
    209a:	9c a9       	ldd	r25, Y+52	; 0x34
    209c:	20 e0       	ldi	r18, 0x00	; 0
    209e:	3f ef       	ldi	r19, 0xFF	; 255
    20a0:	4f e7       	ldi	r20, 0x7F	; 127
    20a2:	57 e4       	ldi	r21, 0x47	; 71
    20a4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    20a8:	18 16       	cp	r1, r24
    20aa:	4c f5       	brge	.+82     	; 0x20fe <HCLCD_Vid4Bits_Init+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20ac:	6d a9       	ldd	r22, Y+53	; 0x35
    20ae:	7e a9       	ldd	r23, Y+54	; 0x36
    20b0:	8f a9       	ldd	r24, Y+55	; 0x37
    20b2:	98 ad       	ldd	r25, Y+56	; 0x38
    20b4:	20 e0       	ldi	r18, 0x00	; 0
    20b6:	30 e0       	ldi	r19, 0x00	; 0
    20b8:	40 e2       	ldi	r20, 0x20	; 32
    20ba:	51 e4       	ldi	r21, 0x41	; 65
    20bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20c0:	dc 01       	movw	r26, r24
    20c2:	cb 01       	movw	r24, r22
    20c4:	bc 01       	movw	r22, r24
    20c6:	cd 01       	movw	r24, r26
    20c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20cc:	dc 01       	movw	r26, r24
    20ce:	cb 01       	movw	r24, r22
    20d0:	98 ab       	std	Y+48, r25	; 0x30
    20d2:	8f a7       	std	Y+47, r24	; 0x2f
    20d4:	0f c0       	rjmp	.+30     	; 0x20f4 <HCLCD_Vid4Bits_Init+0xf6>
    20d6:	89 e1       	ldi	r24, 0x19	; 25
    20d8:	90 e0       	ldi	r25, 0x00	; 0
    20da:	9e a7       	std	Y+46, r25	; 0x2e
    20dc:	8d a7       	std	Y+45, r24	; 0x2d
    20de:	8d a5       	ldd	r24, Y+45	; 0x2d
    20e0:	9e a5       	ldd	r25, Y+46	; 0x2e
    20e2:	01 97       	sbiw	r24, 0x01	; 1
    20e4:	f1 f7       	brne	.-4      	; 0x20e2 <HCLCD_Vid4Bits_Init+0xe4>
    20e6:	9e a7       	std	Y+46, r25	; 0x2e
    20e8:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    20ea:	8f a5       	ldd	r24, Y+47	; 0x2f
    20ec:	98 a9       	ldd	r25, Y+48	; 0x30
    20ee:	01 97       	sbiw	r24, 0x01	; 1
    20f0:	98 ab       	std	Y+48, r25	; 0x30
    20f2:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    20f4:	8f a5       	ldd	r24, Y+47	; 0x2f
    20f6:	98 a9       	ldd	r25, Y+48	; 0x30
    20f8:	00 97       	sbiw	r24, 0x00	; 0
    20fa:	69 f7       	brne	.-38     	; 0x20d6 <HCLCD_Vid4Bits_Init+0xd8>
    20fc:	14 c0       	rjmp	.+40     	; 0x2126 <HCLCD_Vid4Bits_Init+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    20fe:	69 a9       	ldd	r22, Y+49	; 0x31
    2100:	7a a9       	ldd	r23, Y+50	; 0x32
    2102:	8b a9       	ldd	r24, Y+51	; 0x33
    2104:	9c a9       	ldd	r25, Y+52	; 0x34
    2106:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    210a:	dc 01       	movw	r26, r24
    210c:	cb 01       	movw	r24, r22
    210e:	98 ab       	std	Y+48, r25	; 0x30
    2110:	8f a7       	std	Y+47, r24	; 0x2f
    2112:	8f a5       	ldd	r24, Y+47	; 0x2f
    2114:	98 a9       	ldd	r25, Y+48	; 0x30
    2116:	9c a7       	std	Y+44, r25	; 0x2c
    2118:	8b a7       	std	Y+43, r24	; 0x2b
    211a:	8b a5       	ldd	r24, Y+43	; 0x2b
    211c:	9c a5       	ldd	r25, Y+44	; 0x2c
    211e:	01 97       	sbiw	r24, 0x01	; 1
    2120:	f1 f7       	brne	.-4      	; 0x211e <HCLCD_Vid4Bits_Init+0x120>
    2122:	9c a7       	std	Y+44, r25	; 0x2c
    2124:	8b a7       	std	Y+43, r24	; 0x2b
	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    2126:	82 e0       	ldi	r24, 0x02	; 2
    2128:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    212c:	82 e0       	ldi	r24, 0x02	; 2
    212e:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET);
    2132:	88 e2       	ldi	r24, 0x28	; 40
    2134:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
    2138:	80 e0       	ldi	r24, 0x00	; 0
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	a0 e8       	ldi	r26, 0x80	; 128
    213e:	bf e3       	ldi	r27, 0x3F	; 63
    2140:	8f a3       	std	Y+39, r24	; 0x27
    2142:	98 a7       	std	Y+40, r25	; 0x28
    2144:	a9 a7       	std	Y+41, r26	; 0x29
    2146:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2148:	6f a1       	ldd	r22, Y+39	; 0x27
    214a:	78 a5       	ldd	r23, Y+40	; 0x28
    214c:	89 a5       	ldd	r24, Y+41	; 0x29
    214e:	9a a5       	ldd	r25, Y+42	; 0x2a
    2150:	20 e0       	ldi	r18, 0x00	; 0
    2152:	30 e0       	ldi	r19, 0x00	; 0
    2154:	4a e7       	ldi	r20, 0x7A	; 122
    2156:	53 e4       	ldi	r21, 0x43	; 67
    2158:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    215c:	dc 01       	movw	r26, r24
    215e:	cb 01       	movw	r24, r22
    2160:	8b a3       	std	Y+35, r24	; 0x23
    2162:	9c a3       	std	Y+36, r25	; 0x24
    2164:	ad a3       	std	Y+37, r26	; 0x25
    2166:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2168:	6b a1       	ldd	r22, Y+35	; 0x23
    216a:	7c a1       	ldd	r23, Y+36	; 0x24
    216c:	8d a1       	ldd	r24, Y+37	; 0x25
    216e:	9e a1       	ldd	r25, Y+38	; 0x26
    2170:	20 e0       	ldi	r18, 0x00	; 0
    2172:	30 e0       	ldi	r19, 0x00	; 0
    2174:	40 e8       	ldi	r20, 0x80	; 128
    2176:	5f e3       	ldi	r21, 0x3F	; 63
    2178:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    217c:	88 23       	and	r24, r24
    217e:	2c f4       	brge	.+10     	; 0x218a <HCLCD_Vid4Bits_Init+0x18c>
		__ticks = 1;
    2180:	81 e0       	ldi	r24, 0x01	; 1
    2182:	90 e0       	ldi	r25, 0x00	; 0
    2184:	9a a3       	std	Y+34, r25	; 0x22
    2186:	89 a3       	std	Y+33, r24	; 0x21
    2188:	3f c0       	rjmp	.+126    	; 0x2208 <HCLCD_Vid4Bits_Init+0x20a>
	else if (__tmp > 65535)
    218a:	6b a1       	ldd	r22, Y+35	; 0x23
    218c:	7c a1       	ldd	r23, Y+36	; 0x24
    218e:	8d a1       	ldd	r24, Y+37	; 0x25
    2190:	9e a1       	ldd	r25, Y+38	; 0x26
    2192:	20 e0       	ldi	r18, 0x00	; 0
    2194:	3f ef       	ldi	r19, 0xFF	; 255
    2196:	4f e7       	ldi	r20, 0x7F	; 127
    2198:	57 e4       	ldi	r21, 0x47	; 71
    219a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    219e:	18 16       	cp	r1, r24
    21a0:	4c f5       	brge	.+82     	; 0x21f4 <HCLCD_Vid4Bits_Init+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21a2:	6f a1       	ldd	r22, Y+39	; 0x27
    21a4:	78 a5       	ldd	r23, Y+40	; 0x28
    21a6:	89 a5       	ldd	r24, Y+41	; 0x29
    21a8:	9a a5       	ldd	r25, Y+42	; 0x2a
    21aa:	20 e0       	ldi	r18, 0x00	; 0
    21ac:	30 e0       	ldi	r19, 0x00	; 0
    21ae:	40 e2       	ldi	r20, 0x20	; 32
    21b0:	51 e4       	ldi	r21, 0x41	; 65
    21b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21b6:	dc 01       	movw	r26, r24
    21b8:	cb 01       	movw	r24, r22
    21ba:	bc 01       	movw	r22, r24
    21bc:	cd 01       	movw	r24, r26
    21be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21c2:	dc 01       	movw	r26, r24
    21c4:	cb 01       	movw	r24, r22
    21c6:	9a a3       	std	Y+34, r25	; 0x22
    21c8:	89 a3       	std	Y+33, r24	; 0x21
    21ca:	0f c0       	rjmp	.+30     	; 0x21ea <HCLCD_Vid4Bits_Init+0x1ec>
    21cc:	89 e1       	ldi	r24, 0x19	; 25
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	98 a3       	std	Y+32, r25	; 0x20
    21d2:	8f 8f       	std	Y+31, r24	; 0x1f
    21d4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    21d6:	98 a1       	ldd	r25, Y+32	; 0x20
    21d8:	01 97       	sbiw	r24, 0x01	; 1
    21da:	f1 f7       	brne	.-4      	; 0x21d8 <HCLCD_Vid4Bits_Init+0x1da>
    21dc:	98 a3       	std	Y+32, r25	; 0x20
    21de:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    21e0:	89 a1       	ldd	r24, Y+33	; 0x21
    21e2:	9a a1       	ldd	r25, Y+34	; 0x22
    21e4:	01 97       	sbiw	r24, 0x01	; 1
    21e6:	9a a3       	std	Y+34, r25	; 0x22
    21e8:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    21ea:	89 a1       	ldd	r24, Y+33	; 0x21
    21ec:	9a a1       	ldd	r25, Y+34	; 0x22
    21ee:	00 97       	sbiw	r24, 0x00	; 0
    21f0:	69 f7       	brne	.-38     	; 0x21cc <HCLCD_Vid4Bits_Init+0x1ce>
    21f2:	14 c0       	rjmp	.+40     	; 0x221c <HCLCD_Vid4Bits_Init+0x21e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21f4:	6b a1       	ldd	r22, Y+35	; 0x23
    21f6:	7c a1       	ldd	r23, Y+36	; 0x24
    21f8:	8d a1       	ldd	r24, Y+37	; 0x25
    21fa:	9e a1       	ldd	r25, Y+38	; 0x26
    21fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2200:	dc 01       	movw	r26, r24
    2202:	cb 01       	movw	r24, r22
    2204:	9a a3       	std	Y+34, r25	; 0x22
    2206:	89 a3       	std	Y+33, r24	; 0x21
    2208:	89 a1       	ldd	r24, Y+33	; 0x21
    220a:	9a a1       	ldd	r25, Y+34	; 0x22
    220c:	9e 8f       	std	Y+30, r25	; 0x1e
    220e:	8d 8f       	std	Y+29, r24	; 0x1d
    2210:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2212:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2214:	01 97       	sbiw	r24, 0x01	; 1
    2216:	f1 f7       	brne	.-4      	; 0x2214 <HCLCD_Vid4Bits_Init+0x216>
    2218:	9e 8f       	std	Y+30, r25	; 0x1e
    221a:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF>>4);
    221c:	80 e0       	ldi	r24, 0x00	; 0
    221e:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF);
    2222:	8f e0       	ldi	r24, 0x0F	; 15
    2224:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
    2228:	80 e0       	ldi	r24, 0x00	; 0
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	a0 e8       	ldi	r26, 0x80	; 128
    222e:	bf e3       	ldi	r27, 0x3F	; 63
    2230:	89 8f       	std	Y+25, r24	; 0x19
    2232:	9a 8f       	std	Y+26, r25	; 0x1a
    2234:	ab 8f       	std	Y+27, r26	; 0x1b
    2236:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2238:	69 8d       	ldd	r22, Y+25	; 0x19
    223a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    223c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    223e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2240:	20 e0       	ldi	r18, 0x00	; 0
    2242:	30 e0       	ldi	r19, 0x00	; 0
    2244:	4a e7       	ldi	r20, 0x7A	; 122
    2246:	53 e4       	ldi	r21, 0x43	; 67
    2248:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    224c:	dc 01       	movw	r26, r24
    224e:	cb 01       	movw	r24, r22
    2250:	8d 8b       	std	Y+21, r24	; 0x15
    2252:	9e 8b       	std	Y+22, r25	; 0x16
    2254:	af 8b       	std	Y+23, r26	; 0x17
    2256:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2258:	6d 89       	ldd	r22, Y+21	; 0x15
    225a:	7e 89       	ldd	r23, Y+22	; 0x16
    225c:	8f 89       	ldd	r24, Y+23	; 0x17
    225e:	98 8d       	ldd	r25, Y+24	; 0x18
    2260:	20 e0       	ldi	r18, 0x00	; 0
    2262:	30 e0       	ldi	r19, 0x00	; 0
    2264:	40 e8       	ldi	r20, 0x80	; 128
    2266:	5f e3       	ldi	r21, 0x3F	; 63
    2268:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    226c:	88 23       	and	r24, r24
    226e:	2c f4       	brge	.+10     	; 0x227a <HCLCD_Vid4Bits_Init+0x27c>
		__ticks = 1;
    2270:	81 e0       	ldi	r24, 0x01	; 1
    2272:	90 e0       	ldi	r25, 0x00	; 0
    2274:	9c 8b       	std	Y+20, r25	; 0x14
    2276:	8b 8b       	std	Y+19, r24	; 0x13
    2278:	3f c0       	rjmp	.+126    	; 0x22f8 <HCLCD_Vid4Bits_Init+0x2fa>
	else if (__tmp > 65535)
    227a:	6d 89       	ldd	r22, Y+21	; 0x15
    227c:	7e 89       	ldd	r23, Y+22	; 0x16
    227e:	8f 89       	ldd	r24, Y+23	; 0x17
    2280:	98 8d       	ldd	r25, Y+24	; 0x18
    2282:	20 e0       	ldi	r18, 0x00	; 0
    2284:	3f ef       	ldi	r19, 0xFF	; 255
    2286:	4f e7       	ldi	r20, 0x7F	; 127
    2288:	57 e4       	ldi	r21, 0x47	; 71
    228a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    228e:	18 16       	cp	r1, r24
    2290:	4c f5       	brge	.+82     	; 0x22e4 <HCLCD_Vid4Bits_Init+0x2e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2292:	69 8d       	ldd	r22, Y+25	; 0x19
    2294:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2296:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2298:	9c 8d       	ldd	r25, Y+28	; 0x1c
    229a:	20 e0       	ldi	r18, 0x00	; 0
    229c:	30 e0       	ldi	r19, 0x00	; 0
    229e:	40 e2       	ldi	r20, 0x20	; 32
    22a0:	51 e4       	ldi	r21, 0x41	; 65
    22a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22a6:	dc 01       	movw	r26, r24
    22a8:	cb 01       	movw	r24, r22
    22aa:	bc 01       	movw	r22, r24
    22ac:	cd 01       	movw	r24, r26
    22ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22b2:	dc 01       	movw	r26, r24
    22b4:	cb 01       	movw	r24, r22
    22b6:	9c 8b       	std	Y+20, r25	; 0x14
    22b8:	8b 8b       	std	Y+19, r24	; 0x13
    22ba:	0f c0       	rjmp	.+30     	; 0x22da <HCLCD_Vid4Bits_Init+0x2dc>
    22bc:	89 e1       	ldi	r24, 0x19	; 25
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	9a 8b       	std	Y+18, r25	; 0x12
    22c2:	89 8b       	std	Y+17, r24	; 0x11
    22c4:	89 89       	ldd	r24, Y+17	; 0x11
    22c6:	9a 89       	ldd	r25, Y+18	; 0x12
    22c8:	01 97       	sbiw	r24, 0x01	; 1
    22ca:	f1 f7       	brne	.-4      	; 0x22c8 <HCLCD_Vid4Bits_Init+0x2ca>
    22cc:	9a 8b       	std	Y+18, r25	; 0x12
    22ce:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22d0:	8b 89       	ldd	r24, Y+19	; 0x13
    22d2:	9c 89       	ldd	r25, Y+20	; 0x14
    22d4:	01 97       	sbiw	r24, 0x01	; 1
    22d6:	9c 8b       	std	Y+20, r25	; 0x14
    22d8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    22da:	8b 89       	ldd	r24, Y+19	; 0x13
    22dc:	9c 89       	ldd	r25, Y+20	; 0x14
    22de:	00 97       	sbiw	r24, 0x00	; 0
    22e0:	69 f7       	brne	.-38     	; 0x22bc <HCLCD_Vid4Bits_Init+0x2be>
    22e2:	14 c0       	rjmp	.+40     	; 0x230c <HCLCD_Vid4Bits_Init+0x30e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    22e4:	6d 89       	ldd	r22, Y+21	; 0x15
    22e6:	7e 89       	ldd	r23, Y+22	; 0x16
    22e8:	8f 89       	ldd	r24, Y+23	; 0x17
    22ea:	98 8d       	ldd	r25, Y+24	; 0x18
    22ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22f0:	dc 01       	movw	r26, r24
    22f2:	cb 01       	movw	r24, r22
    22f4:	9c 8b       	std	Y+20, r25	; 0x14
    22f6:	8b 8b       	std	Y+19, r24	; 0x13
    22f8:	8b 89       	ldd	r24, Y+19	; 0x13
    22fa:	9c 89       	ldd	r25, Y+20	; 0x14
    22fc:	98 8b       	std	Y+16, r25	; 0x10
    22fe:	8f 87       	std	Y+15, r24	; 0x0f
    2300:	8f 85       	ldd	r24, Y+15	; 0x0f
    2302:	98 89       	ldd	r25, Y+16	; 0x10
    2304:	01 97       	sbiw	r24, 0x01	; 1
    2306:	f1 f7       	brne	.-4      	; 0x2304 <HCLCD_Vid4Bits_Init+0x306>
    2308:	98 8b       	std	Y+16, r25	; 0x10
    230a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR>>4);
    230c:	80 e0       	ldi	r24, 0x00	; 0
    230e:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR);
    2312:	81 e0       	ldi	r24, 0x01	; 1
    2314:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
    2318:	80 e0       	ldi	r24, 0x00	; 0
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	a0 e0       	ldi	r26, 0x00	; 0
    231e:	b0 e4       	ldi	r27, 0x40	; 64
    2320:	8b 87       	std	Y+11, r24	; 0x0b
    2322:	9c 87       	std	Y+12, r25	; 0x0c
    2324:	ad 87       	std	Y+13, r26	; 0x0d
    2326:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2328:	6b 85       	ldd	r22, Y+11	; 0x0b
    232a:	7c 85       	ldd	r23, Y+12	; 0x0c
    232c:	8d 85       	ldd	r24, Y+13	; 0x0d
    232e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2330:	20 e0       	ldi	r18, 0x00	; 0
    2332:	30 e0       	ldi	r19, 0x00	; 0
    2334:	4a e7       	ldi	r20, 0x7A	; 122
    2336:	53 e4       	ldi	r21, 0x43	; 67
    2338:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    233c:	dc 01       	movw	r26, r24
    233e:	cb 01       	movw	r24, r22
    2340:	8f 83       	std	Y+7, r24	; 0x07
    2342:	98 87       	std	Y+8, r25	; 0x08
    2344:	a9 87       	std	Y+9, r26	; 0x09
    2346:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2348:	6f 81       	ldd	r22, Y+7	; 0x07
    234a:	78 85       	ldd	r23, Y+8	; 0x08
    234c:	89 85       	ldd	r24, Y+9	; 0x09
    234e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2350:	20 e0       	ldi	r18, 0x00	; 0
    2352:	30 e0       	ldi	r19, 0x00	; 0
    2354:	40 e8       	ldi	r20, 0x80	; 128
    2356:	5f e3       	ldi	r21, 0x3F	; 63
    2358:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    235c:	88 23       	and	r24, r24
    235e:	2c f4       	brge	.+10     	; 0x236a <HCLCD_Vid4Bits_Init+0x36c>
		__ticks = 1;
    2360:	81 e0       	ldi	r24, 0x01	; 1
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	9e 83       	std	Y+6, r25	; 0x06
    2366:	8d 83       	std	Y+5, r24	; 0x05
    2368:	3f c0       	rjmp	.+126    	; 0x23e8 <HCLCD_Vid4Bits_Init+0x3ea>
	else if (__tmp > 65535)
    236a:	6f 81       	ldd	r22, Y+7	; 0x07
    236c:	78 85       	ldd	r23, Y+8	; 0x08
    236e:	89 85       	ldd	r24, Y+9	; 0x09
    2370:	9a 85       	ldd	r25, Y+10	; 0x0a
    2372:	20 e0       	ldi	r18, 0x00	; 0
    2374:	3f ef       	ldi	r19, 0xFF	; 255
    2376:	4f e7       	ldi	r20, 0x7F	; 127
    2378:	57 e4       	ldi	r21, 0x47	; 71
    237a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    237e:	18 16       	cp	r1, r24
    2380:	4c f5       	brge	.+82     	; 0x23d4 <HCLCD_Vid4Bits_Init+0x3d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2382:	6b 85       	ldd	r22, Y+11	; 0x0b
    2384:	7c 85       	ldd	r23, Y+12	; 0x0c
    2386:	8d 85       	ldd	r24, Y+13	; 0x0d
    2388:	9e 85       	ldd	r25, Y+14	; 0x0e
    238a:	20 e0       	ldi	r18, 0x00	; 0
    238c:	30 e0       	ldi	r19, 0x00	; 0
    238e:	40 e2       	ldi	r20, 0x20	; 32
    2390:	51 e4       	ldi	r21, 0x41	; 65
    2392:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2396:	dc 01       	movw	r26, r24
    2398:	cb 01       	movw	r24, r22
    239a:	bc 01       	movw	r22, r24
    239c:	cd 01       	movw	r24, r26
    239e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23a2:	dc 01       	movw	r26, r24
    23a4:	cb 01       	movw	r24, r22
    23a6:	9e 83       	std	Y+6, r25	; 0x06
    23a8:	8d 83       	std	Y+5, r24	; 0x05
    23aa:	0f c0       	rjmp	.+30     	; 0x23ca <HCLCD_Vid4Bits_Init+0x3cc>
    23ac:	89 e1       	ldi	r24, 0x19	; 25
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	9c 83       	std	Y+4, r25	; 0x04
    23b2:	8b 83       	std	Y+3, r24	; 0x03
    23b4:	8b 81       	ldd	r24, Y+3	; 0x03
    23b6:	9c 81       	ldd	r25, Y+4	; 0x04
    23b8:	01 97       	sbiw	r24, 0x01	; 1
    23ba:	f1 f7       	brne	.-4      	; 0x23b8 <HCLCD_Vid4Bits_Init+0x3ba>
    23bc:	9c 83       	std	Y+4, r25	; 0x04
    23be:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23c0:	8d 81       	ldd	r24, Y+5	; 0x05
    23c2:	9e 81       	ldd	r25, Y+6	; 0x06
    23c4:	01 97       	sbiw	r24, 0x01	; 1
    23c6:	9e 83       	std	Y+6, r25	; 0x06
    23c8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23ca:	8d 81       	ldd	r24, Y+5	; 0x05
    23cc:	9e 81       	ldd	r25, Y+6	; 0x06
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	69 f7       	brne	.-38     	; 0x23ac <HCLCD_Vid4Bits_Init+0x3ae>
    23d2:	14 c0       	rjmp	.+40     	; 0x23fc <HCLCD_Vid4Bits_Init+0x3fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    23d4:	6f 81       	ldd	r22, Y+7	; 0x07
    23d6:	78 85       	ldd	r23, Y+8	; 0x08
    23d8:	89 85       	ldd	r24, Y+9	; 0x09
    23da:	9a 85       	ldd	r25, Y+10	; 0x0a
    23dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23e0:	dc 01       	movw	r26, r24
    23e2:	cb 01       	movw	r24, r22
    23e4:	9e 83       	std	Y+6, r25	; 0x06
    23e6:	8d 83       	std	Y+5, r24	; 0x05
    23e8:	8d 81       	ldd	r24, Y+5	; 0x05
    23ea:	9e 81       	ldd	r25, Y+6	; 0x06
    23ec:	9a 83       	std	Y+2, r25	; 0x02
    23ee:	89 83       	std	Y+1, r24	; 0x01
    23f0:	89 81       	ldd	r24, Y+1	; 0x01
    23f2:	9a 81       	ldd	r25, Y+2	; 0x02
    23f4:	01 97       	sbiw	r24, 0x01	; 1
    23f6:	f1 f7       	brne	.-4      	; 0x23f4 <HCLCD_Vid4Bits_Init+0x3f6>
    23f8:	9a 83       	std	Y+2, r25	; 0x02
    23fa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET>>4);
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET);
    2402:	86 e0       	ldi	r24, 0x06	; 6
    2404:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
}
    2408:	e9 96       	adiw	r28, 0x39	; 57
    240a:	0f b6       	in	r0, 0x3f	; 63
    240c:	f8 94       	cli
    240e:	de bf       	out	0x3e, r29	; 62
    2410:	0f be       	out	0x3f, r0	; 63
    2412:	cd bf       	out	0x3d, r28	; 61
    2414:	cf 91       	pop	r28
    2416:	df 91       	pop	r29
    2418:	08 95       	ret

0000241a <HCLCD_VidWriteChar_4Bits>:
void HCLCD_VidWriteChar_4Bits(u8 Copy_u8Data)
{
    241a:	df 93       	push	r29
    241c:	cf 93       	push	r28
    241e:	cd b7       	in	r28, 0x3d	; 61
    2420:	de b7       	in	r29, 0x3e	; 62
    2422:	60 97       	sbiw	r28, 0x10	; 16
    2424:	0f b6       	in	r0, 0x3f	; 63
    2426:	f8 94       	cli
    2428:	de bf       	out	0x3e, r29	; 62
    242a:	0f be       	out	0x3f, r0	; 63
    242c:	cd bf       	out	0x3d, r28	; 61
    242e:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyData;
	/*select Data register--> Write One on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    2430:	81 e0       	ldi	r24, 0x01	; 1
    2432:	61 e0       	ldi	r22, 0x01	; 1
    2434:	41 e0       	ldi	r20, 0x01	; 1
    2436:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Data*/
	LOC_u8CopyData=(Copy_u8Data&0x0F)<<HCLCD_PINSTART;
    243a:	88 89       	ldd	r24, Y+16	; 0x10
    243c:	88 2f       	mov	r24, r24
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	82 95       	swap	r24
    2442:	92 95       	swap	r25
    2444:	90 7f       	andi	r25, 0xF0	; 240
    2446:	98 27       	eor	r25, r24
    2448:	80 7f       	andi	r24, 0xF0	; 240
    244a:	98 27       	eor	r25, r24
    244c:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyData);
    244e:	84 e0       	ldi	r24, 0x04	; 4
    2450:	60 e0       	ldi	r22, 0x00	; 0
    2452:	4f 85       	ldd	r20, Y+15	; 0x0f
    2454:	0e 94 f5 08 	call	0x11ea	; 0x11ea <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2458:	83 e0       	ldi	r24, 0x03	; 3
    245a:	61 e0       	ldi	r22, 0x01	; 1
    245c:	41 e0       	ldi	r20, 0x01	; 1
    245e:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
    2462:	80 e0       	ldi	r24, 0x00	; 0
    2464:	90 e0       	ldi	r25, 0x00	; 0
    2466:	a0 e0       	ldi	r26, 0x00	; 0
    2468:	b0 e4       	ldi	r27, 0x40	; 64
    246a:	8b 87       	std	Y+11, r24	; 0x0b
    246c:	9c 87       	std	Y+12, r25	; 0x0c
    246e:	ad 87       	std	Y+13, r26	; 0x0d
    2470:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2472:	6b 85       	ldd	r22, Y+11	; 0x0b
    2474:	7c 85       	ldd	r23, Y+12	; 0x0c
    2476:	8d 85       	ldd	r24, Y+13	; 0x0d
    2478:	9e 85       	ldd	r25, Y+14	; 0x0e
    247a:	20 e0       	ldi	r18, 0x00	; 0
    247c:	30 e0       	ldi	r19, 0x00	; 0
    247e:	4a e7       	ldi	r20, 0x7A	; 122
    2480:	53 e4       	ldi	r21, 0x43	; 67
    2482:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2486:	dc 01       	movw	r26, r24
    2488:	cb 01       	movw	r24, r22
    248a:	8f 83       	std	Y+7, r24	; 0x07
    248c:	98 87       	std	Y+8, r25	; 0x08
    248e:	a9 87       	std	Y+9, r26	; 0x09
    2490:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2492:	6f 81       	ldd	r22, Y+7	; 0x07
    2494:	78 85       	ldd	r23, Y+8	; 0x08
    2496:	89 85       	ldd	r24, Y+9	; 0x09
    2498:	9a 85       	ldd	r25, Y+10	; 0x0a
    249a:	20 e0       	ldi	r18, 0x00	; 0
    249c:	30 e0       	ldi	r19, 0x00	; 0
    249e:	40 e8       	ldi	r20, 0x80	; 128
    24a0:	5f e3       	ldi	r21, 0x3F	; 63
    24a2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    24a6:	88 23       	and	r24, r24
    24a8:	2c f4       	brge	.+10     	; 0x24b4 <HCLCD_VidWriteChar_4Bits+0x9a>
		__ticks = 1;
    24aa:	81 e0       	ldi	r24, 0x01	; 1
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    24ae:	9e 83       	std	Y+6, r25	; 0x06
    24b0:	8d 83       	std	Y+5, r24	; 0x05
    24b2:	3f c0       	rjmp	.+126    	; 0x2532 <HCLCD_VidWriteChar_4Bits+0x118>
	else if (__tmp > 65535)
    24b4:	6f 81       	ldd	r22, Y+7	; 0x07
    24b6:	78 85       	ldd	r23, Y+8	; 0x08
    24b8:	89 85       	ldd	r24, Y+9	; 0x09
    24ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    24bc:	20 e0       	ldi	r18, 0x00	; 0
    24be:	3f ef       	ldi	r19, 0xFF	; 255
    24c0:	4f e7       	ldi	r20, 0x7F	; 127
    24c2:	57 e4       	ldi	r21, 0x47	; 71
    24c4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    24c8:	18 16       	cp	r1, r24
    24ca:	4c f5       	brge	.+82     	; 0x251e <HCLCD_VidWriteChar_4Bits+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    24cc:	6b 85       	ldd	r22, Y+11	; 0x0b
    24ce:	7c 85       	ldd	r23, Y+12	; 0x0c
    24d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    24d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    24d4:	20 e0       	ldi	r18, 0x00	; 0
    24d6:	30 e0       	ldi	r19, 0x00	; 0
    24d8:	40 e2       	ldi	r20, 0x20	; 32
    24da:	51 e4       	ldi	r21, 0x41	; 65
    24dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24e0:	dc 01       	movw	r26, r24
    24e2:	cb 01       	movw	r24, r22
    24e4:	bc 01       	movw	r22, r24
    24e6:	cd 01       	movw	r24, r26
    24e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24ec:	dc 01       	movw	r26, r24
    24ee:	cb 01       	movw	r24, r22
    24f0:	9e 83       	std	Y+6, r25	; 0x06
    24f2:	8d 83       	std	Y+5, r24	; 0x05
    24f4:	0f c0       	rjmp	.+30     	; 0x2514 <HCLCD_VidWriteChar_4Bits+0xfa>
    24f6:	89 e1       	ldi	r24, 0x19	; 25
    24f8:	90 e0       	ldi	r25, 0x00	; 0
    24fa:	9c 83       	std	Y+4, r25	; 0x04
    24fc:	8b 83       	std	Y+3, r24	; 0x03
    24fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2500:	9c 81       	ldd	r25, Y+4	; 0x04
    2502:	01 97       	sbiw	r24, 0x01	; 1
    2504:	f1 f7       	brne	.-4      	; 0x2502 <HCLCD_VidWriteChar_4Bits+0xe8>
    2506:	9c 83       	std	Y+4, r25	; 0x04
    2508:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    250a:	8d 81       	ldd	r24, Y+5	; 0x05
    250c:	9e 81       	ldd	r25, Y+6	; 0x06
    250e:	01 97       	sbiw	r24, 0x01	; 1
    2510:	9e 83       	std	Y+6, r25	; 0x06
    2512:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2514:	8d 81       	ldd	r24, Y+5	; 0x05
    2516:	9e 81       	ldd	r25, Y+6	; 0x06
    2518:	00 97       	sbiw	r24, 0x00	; 0
    251a:	69 f7       	brne	.-38     	; 0x24f6 <HCLCD_VidWriteChar_4Bits+0xdc>
    251c:	14 c0       	rjmp	.+40     	; 0x2546 <HCLCD_VidWriteChar_4Bits+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    251e:	6f 81       	ldd	r22, Y+7	; 0x07
    2520:	78 85       	ldd	r23, Y+8	; 0x08
    2522:	89 85       	ldd	r24, Y+9	; 0x09
    2524:	9a 85       	ldd	r25, Y+10	; 0x0a
    2526:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    252a:	dc 01       	movw	r26, r24
    252c:	cb 01       	movw	r24, r22
    252e:	9e 83       	std	Y+6, r25	; 0x06
    2530:	8d 83       	std	Y+5, r24	; 0x05
    2532:	8d 81       	ldd	r24, Y+5	; 0x05
    2534:	9e 81       	ldd	r25, Y+6	; 0x06
    2536:	9a 83       	std	Y+2, r25	; 0x02
    2538:	89 83       	std	Y+1, r24	; 0x01
    253a:	89 81       	ldd	r24, Y+1	; 0x01
    253c:	9a 81       	ldd	r25, Y+2	; 0x02
    253e:	01 97       	sbiw	r24, 0x01	; 1
    2540:	f1 f7       	brne	.-4      	; 0x253e <HCLCD_VidWriteChar_4Bits+0x124>
    2542:	9a 83       	std	Y+2, r25	; 0x02
    2544:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2546:	83 e0       	ldi	r24, 0x03	; 3
    2548:	61 e0       	ldi	r22, 0x01	; 1
    254a:	40 e0       	ldi	r20, 0x00	; 0
    254c:	0e 94 12 07 	call	0xe24	; 0xe24 <MDIO_Error_State_SetPinValue>
}
    2550:	60 96       	adiw	r28, 0x10	; 16
    2552:	0f b6       	in	r0, 0x3f	; 63
    2554:	f8 94       	cli
    2556:	de bf       	out	0x3e, r29	; 62
    2558:	0f be       	out	0x3f, r0	; 63
    255a:	cd bf       	out	0x3d, r28	; 61
    255c:	cf 91       	pop	r28
    255e:	df 91       	pop	r29
    2560:	08 95       	ret

00002562 <HCLCD_VidSendChar_4Bits>:
void HCLCD_VidSendChar_4Bits(u8 Copy_u8Data)
{
    2562:	df 93       	push	r29
    2564:	cf 93       	push	r28
    2566:	0f 92       	push	r0
    2568:	cd b7       	in	r28, 0x3d	; 61
    256a:	de b7       	in	r29, 0x3e	; 62
    256c:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data>>4);
    256e:	89 81       	ldd	r24, Y+1	; 0x01
    2570:	82 95       	swap	r24
    2572:	8f 70       	andi	r24, 0x0F	; 15
    2574:	0e 94 0d 12 	call	0x241a	; 0x241a <HCLCD_VidWriteChar_4Bits>
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
    2578:	89 81       	ldd	r24, Y+1	; 0x01
    257a:	0e 94 0d 12 	call	0x241a	; 0x241a <HCLCD_VidWriteChar_4Bits>
}
    257e:	0f 90       	pop	r0
    2580:	cf 91       	pop	r28
    2582:	df 91       	pop	r29
    2584:	08 95       	ret

00002586 <HCLCD_VidWriteString_4Bits>:
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
    2586:	df 93       	push	r29
    2588:	cf 93       	push	r28
    258a:	00 d0       	rcall	.+0      	; 0x258c <HCLCD_VidWriteString_4Bits+0x6>
    258c:	0f 92       	push	r0
    258e:	cd b7       	in	r28, 0x3d	; 61
    2590:	de b7       	in	r29, 0x3e	; 62
    2592:	9b 83       	std	Y+3, r25	; 0x03
    2594:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    2596:	19 82       	std	Y+1, r1	; 0x01
    2598:	0e c0       	rjmp	.+28     	; 0x25b6 <HCLCD_VidWriteString_4Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
    259a:	89 81       	ldd	r24, Y+1	; 0x01
    259c:	28 2f       	mov	r18, r24
    259e:	30 e0       	ldi	r19, 0x00	; 0
    25a0:	8a 81       	ldd	r24, Y+2	; 0x02
    25a2:	9b 81       	ldd	r25, Y+3	; 0x03
    25a4:	fc 01       	movw	r30, r24
    25a6:	e2 0f       	add	r30, r18
    25a8:	f3 1f       	adc	r31, r19
    25aa:	80 81       	ld	r24, Z
    25ac:	0e 94 b1 12 	call	0x2562	; 0x2562 <HCLCD_VidSendChar_4Bits>
		Loc_u8Count++;
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	8f 5f       	subi	r24, 0xFF	; 255
    25b4:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
}
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    25b6:	89 81       	ldd	r24, Y+1	; 0x01
    25b8:	28 2f       	mov	r18, r24
    25ba:	30 e0       	ldi	r19, 0x00	; 0
    25bc:	8a 81       	ldd	r24, Y+2	; 0x02
    25be:	9b 81       	ldd	r25, Y+3	; 0x03
    25c0:	fc 01       	movw	r30, r24
    25c2:	e2 0f       	add	r30, r18
    25c4:	f3 1f       	adc	r31, r19
    25c6:	80 81       	ld	r24, Z
    25c8:	88 23       	and	r24, r24
    25ca:	39 f7       	brne	.-50     	; 0x259a <HCLCD_VidWriteString_4Bits+0x14>
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    25cc:	0f 90       	pop	r0
    25ce:	0f 90       	pop	r0
    25d0:	0f 90       	pop	r0
    25d2:	cf 91       	pop	r28
    25d4:	df 91       	pop	r29
    25d6:	08 95       	ret

000025d8 <HCLCD_VidWriteNumber_4Bits>:
void HCLCD_VidWriteNumber_4Bits(u32 Copy_u8Number)
{
    25d8:	0f 93       	push	r16
    25da:	1f 93       	push	r17
    25dc:	df 93       	push	r29
    25de:	cf 93       	push	r28
    25e0:	cd b7       	in	r28, 0x3d	; 61
    25e2:	de b7       	in	r29, 0x3e	; 62
    25e4:	60 97       	sbiw	r28, 0x10	; 16
    25e6:	0f b6       	in	r0, 0x3f	; 63
    25e8:	f8 94       	cli
    25ea:	de bf       	out	0x3e, r29	; 62
    25ec:	0f be       	out	0x3f, r0	; 63
    25ee:	cd bf       	out	0x3d, r28	; 61
    25f0:	6d 87       	std	Y+13, r22	; 0x0d
    25f2:	7e 87       	std	Y+14, r23	; 0x0e
    25f4:	8f 87       	std	Y+15, r24	; 0x0f
    25f6:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    25f8:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    25fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    25fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    25fe:	af 85       	ldd	r26, Y+15	; 0x0f
    2600:	b8 89       	ldd	r27, Y+16	; 0x10
    2602:	00 97       	sbiw	r24, 0x00	; 0
    2604:	a1 05       	cpc	r26, r1
    2606:	b1 05       	cpc	r27, r1
    2608:	09 f4       	brne	.+2      	; 0x260c <HCLCD_VidWriteNumber_4Bits+0x34>
    260a:	4f c0       	rjmp	.+158    	; 0x26aa <HCLCD_VidWriteNumber_4Bits+0xd2>
    260c:	2d c0       	rjmp	.+90     	; 0x2668 <HCLCD_VidWriteNumber_4Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    260e:	8a 81       	ldd	r24, Y+2	; 0x02
    2610:	08 2f       	mov	r16, r24
    2612:	10 e0       	ldi	r17, 0x00	; 0
    2614:	8d 85       	ldd	r24, Y+13	; 0x0d
    2616:	9e 85       	ldd	r25, Y+14	; 0x0e
    2618:	af 85       	ldd	r26, Y+15	; 0x0f
    261a:	b8 89       	ldd	r27, Y+16	; 0x10
    261c:	2a e0       	ldi	r18, 0x0A	; 10
    261e:	30 e0       	ldi	r19, 0x00	; 0
    2620:	40 e0       	ldi	r20, 0x00	; 0
    2622:	50 e0       	ldi	r21, 0x00	; 0
    2624:	bc 01       	movw	r22, r24
    2626:	cd 01       	movw	r24, r26
    2628:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <__udivmodsi4>
    262c:	dc 01       	movw	r26, r24
    262e:	cb 01       	movw	r24, r22
    2630:	28 2f       	mov	r18, r24
    2632:	ce 01       	movw	r24, r28
    2634:	03 96       	adiw	r24, 0x03	; 3
    2636:	fc 01       	movw	r30, r24
    2638:	e0 0f       	add	r30, r16
    263a:	f1 1f       	adc	r31, r17
    263c:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    263e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2640:	9e 85       	ldd	r25, Y+14	; 0x0e
    2642:	af 85       	ldd	r26, Y+15	; 0x0f
    2644:	b8 89       	ldd	r27, Y+16	; 0x10
    2646:	2a e0       	ldi	r18, 0x0A	; 10
    2648:	30 e0       	ldi	r19, 0x00	; 0
    264a:	40 e0       	ldi	r20, 0x00	; 0
    264c:	50 e0       	ldi	r21, 0x00	; 0
    264e:	bc 01       	movw	r22, r24
    2650:	cd 01       	movw	r24, r26
    2652:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <__udivmodsi4>
    2656:	da 01       	movw	r26, r20
    2658:	c9 01       	movw	r24, r18
    265a:	8d 87       	std	Y+13, r24	; 0x0d
    265c:	9e 87       	std	Y+14, r25	; 0x0e
    265e:	af 87       	std	Y+15, r26	; 0x0f
    2660:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    2662:	8a 81       	ldd	r24, Y+2	; 0x02
    2664:	8f 5f       	subi	r24, 0xFF	; 255
    2666:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    2668:	8d 85       	ldd	r24, Y+13	; 0x0d
    266a:	9e 85       	ldd	r25, Y+14	; 0x0e
    266c:	af 85       	ldd	r26, Y+15	; 0x0f
    266e:	b8 89       	ldd	r27, Y+16	; 0x10
    2670:	00 97       	sbiw	r24, 0x00	; 0
    2672:	a1 05       	cpc	r26, r1
    2674:	b1 05       	cpc	r27, r1
    2676:	59 f6       	brne	.-106    	; 0x260e <HCLCD_VidWriteNumber_4Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2678:	8a 81       	ldd	r24, Y+2	; 0x02
    267a:	81 50       	subi	r24, 0x01	; 1
    267c:	89 83       	std	Y+1, r24	; 0x01
    267e:	11 c0       	rjmp	.+34     	; 0x26a2 <HCLCD_VidWriteNumber_4Bits+0xca>
		{
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
    2680:	89 81       	ldd	r24, Y+1	; 0x01
    2682:	28 2f       	mov	r18, r24
    2684:	33 27       	eor	r19, r19
    2686:	27 fd       	sbrc	r18, 7
    2688:	30 95       	com	r19
    268a:	ce 01       	movw	r24, r28
    268c:	03 96       	adiw	r24, 0x03	; 3
    268e:	fc 01       	movw	r30, r24
    2690:	e2 0f       	add	r30, r18
    2692:	f3 1f       	adc	r31, r19
    2694:	80 81       	ld	r24, Z
    2696:	80 5d       	subi	r24, 0xD0	; 208
    2698:	0e 94 b1 12 	call	0x2562	; 0x2562 <HCLCD_VidSendChar_4Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    269c:	89 81       	ldd	r24, Y+1	; 0x01
    269e:	81 50       	subi	r24, 0x01	; 1
    26a0:	89 83       	std	Y+1, r24	; 0x01
    26a2:	89 81       	ldd	r24, Y+1	; 0x01
    26a4:	88 23       	and	r24, r24
    26a6:	64 f7       	brge	.-40     	; 0x2680 <HCLCD_VidWriteNumber_4Bits+0xa8>
    26a8:	03 c0       	rjmp	.+6      	; 0x26b0 <HCLCD_VidWriteNumber_4Bits+0xd8>
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    26aa:	80 e3       	ldi	r24, 0x30	; 48
    26ac:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <HCLCD_VidWriteChar_8Bits>
	}
}
    26b0:	60 96       	adiw	r28, 0x10	; 16
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
    26bc:	cf 91       	pop	r28
    26be:	df 91       	pop	r29
    26c0:	1f 91       	pop	r17
    26c2:	0f 91       	pop	r16
    26c4:	08 95       	ret

000026c6 <HCLCD_VidSetPosition_4BitsMode>:
void HCLCD_VidSetPosition_4BitsMode(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    26c6:	df 93       	push	r29
    26c8:	cf 93       	push	r28
    26ca:	00 d0       	rcall	.+0      	; 0x26cc <HCLCD_VidSetPosition_4BitsMode+0x6>
    26cc:	cd b7       	in	r28, 0x3d	; 61
    26ce:	de b7       	in	r29, 0x3e	; 62
    26d0:	89 83       	std	Y+1, r24	; 0x01
    26d2:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	81 30       	cpi	r24, 0x01	; 1
    26d8:	b9 f4       	brne	.+46     	; 0x2708 <HCLCD_VidSetPosition_4BitsMode+0x42>
    26da:	8a 81       	ldd	r24, Y+2	; 0x02
    26dc:	80 31       	cpi	r24, 0x10	; 16
    26de:	a0 f4       	brcc	.+40     	; 0x2708 <HCLCD_VidSetPosition_4BitsMode+0x42>
	{
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    26e0:	8a 81       	ldd	r24, Y+2	; 0x02
    26e2:	88 2f       	mov	r24, r24
    26e4:	90 e0       	ldi	r25, 0x00	; 0
    26e6:	80 58       	subi	r24, 0x80	; 128
    26e8:	9f 4f       	sbci	r25, 0xFF	; 255
    26ea:	95 95       	asr	r25
    26ec:	87 95       	ror	r24
    26ee:	95 95       	asr	r25
    26f0:	87 95       	ror	r24
    26f2:	95 95       	asr	r25
    26f4:	87 95       	ror	r24
    26f6:	95 95       	asr	r25
    26f8:	87 95       	ror	r24
    26fa:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    26fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2700:	80 58       	subi	r24, 0x80	; 128
    2702:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
    2706:	19 c0       	rjmp	.+50     	; 0x273a <HCLCD_VidSetPosition_4BitsMode+0x74>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2708:	89 81       	ldd	r24, Y+1	; 0x01
    270a:	82 30       	cpi	r24, 0x02	; 2
    270c:	b1 f4       	brne	.+44     	; 0x273a <HCLCD_VidSetPosition_4BitsMode+0x74>
    270e:	8a 81       	ldd	r24, Y+2	; 0x02
    2710:	80 31       	cpi	r24, 0x10	; 16
    2712:	98 f4       	brcc	.+38     	; 0x273a <HCLCD_VidSetPosition_4BitsMode+0x74>
	{
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2714:	8a 81       	ldd	r24, Y+2	; 0x02
    2716:	88 2f       	mov	r24, r24
    2718:	90 e0       	ldi	r25, 0x00	; 0
    271a:	80 54       	subi	r24, 0x40	; 64
    271c:	9f 4f       	sbci	r25, 0xFF	; 255
    271e:	95 95       	asr	r25
    2720:	87 95       	ror	r24
    2722:	95 95       	asr	r25
    2724:	87 95       	ror	r24
    2726:	95 95       	asr	r25
    2728:	87 95       	ror	r24
    272a:	95 95       	asr	r25
    272c:	87 95       	ror	r24
    272e:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2732:	8a 81       	ldd	r24, Y+2	; 0x02
    2734:	80 54       	subi	r24, 0x40	; 64
    2736:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    273a:	0f 90       	pop	r0
    273c:	0f 90       	pop	r0
    273e:	cf 91       	pop	r28
    2740:	df 91       	pop	r29
    2742:	08 95       	ret

00002744 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2744:	df 93       	push	r29
    2746:	cf 93       	push	r28
    2748:	cd b7       	in	r28, 0x3d	; 61
    274a:	de b7       	in	r29, 0x3e	; 62
    274c:	27 97       	sbiw	r28, 0x07	; 7
    274e:	0f b6       	in	r0, 0x3f	; 63
    2750:	f8 94       	cli
    2752:	de bf       	out	0x3e, r29	; 62
    2754:	0f be       	out	0x3f, r0	; 63
    2756:	cd bf       	out	0x3d, r28	; 61
    2758:	9d 83       	std	Y+5, r25	; 0x05
    275a:	8c 83       	std	Y+4, r24	; 0x04
    275c:	6e 83       	std	Y+6, r22	; 0x06
    275e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2760:	8a e1       	ldi	r24, 0x1A	; 26
    2762:	90 e0       	ldi	r25, 0x00	; 0
    2764:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <pvPortMalloc>
    2768:	9a 83       	std	Y+2, r25	; 0x02
    276a:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    276c:	89 81       	ldd	r24, Y+1	; 0x01
    276e:	9a 81       	ldd	r25, Y+2	; 0x02
    2770:	00 97       	sbiw	r24, 0x00	; 0
    2772:	09 f4       	brne	.+2      	; 0x2776 <xCoRoutineCreate+0x32>
    2774:	6f c0       	rjmp	.+222    	; 0x2854 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2776:	80 91 84 00 	lds	r24, 0x0084
    277a:	90 91 85 00 	lds	r25, 0x0085
    277e:	00 97       	sbiw	r24, 0x00	; 0
    2780:	41 f4       	brne	.+16     	; 0x2792 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2782:	89 81       	ldd	r24, Y+1	; 0x01
    2784:	9a 81       	ldd	r25, Y+2	; 0x02
    2786:	90 93 85 00 	sts	0x0085, r25
    278a:	80 93 84 00 	sts	0x0084, r24
			prvInitialiseCoRoutineLists();
    278e:	0e 94 09 16 	call	0x2c12	; 0x2c12 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2792:	8e 81       	ldd	r24, Y+6	; 0x06
    2794:	82 30       	cpi	r24, 0x02	; 2
    2796:	10 f0       	brcs	.+4      	; 0x279c <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    279c:	e9 81       	ldd	r30, Y+1	; 0x01
    279e:	fa 81       	ldd	r31, Y+2	; 0x02
    27a0:	11 8e       	std	Z+25, r1	; 0x19
    27a2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    27a4:	e9 81       	ldd	r30, Y+1	; 0x01
    27a6:	fa 81       	ldd	r31, Y+2	; 0x02
    27a8:	8e 81       	ldd	r24, Y+6	; 0x06
    27aa:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    27ac:	e9 81       	ldd	r30, Y+1	; 0x01
    27ae:	fa 81       	ldd	r31, Y+2	; 0x02
    27b0:	8f 81       	ldd	r24, Y+7	; 0x07
    27b2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    27b4:	e9 81       	ldd	r30, Y+1	; 0x01
    27b6:	fa 81       	ldd	r31, Y+2	; 0x02
    27b8:	8c 81       	ldd	r24, Y+4	; 0x04
    27ba:	9d 81       	ldd	r25, Y+5	; 0x05
    27bc:	91 83       	std	Z+1, r25	; 0x01
    27be:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    27c0:	89 81       	ldd	r24, Y+1	; 0x01
    27c2:	9a 81       	ldd	r25, Y+2	; 0x02
    27c4:	02 96       	adiw	r24, 0x02	; 2
    27c6:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    27ca:	89 81       	ldd	r24, Y+1	; 0x01
    27cc:	9a 81       	ldd	r25, Y+2	; 0x02
    27ce:	0c 96       	adiw	r24, 0x0c	; 12
    27d0:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    27d4:	e9 81       	ldd	r30, Y+1	; 0x01
    27d6:	fa 81       	ldd	r31, Y+2	; 0x02
    27d8:	89 81       	ldd	r24, Y+1	; 0x01
    27da:	9a 81       	ldd	r25, Y+2	; 0x02
    27dc:	91 87       	std	Z+9, r25	; 0x09
    27de:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    27e0:	e9 81       	ldd	r30, Y+1	; 0x01
    27e2:	fa 81       	ldd	r31, Y+2	; 0x02
    27e4:	89 81       	ldd	r24, Y+1	; 0x01
    27e6:	9a 81       	ldd	r25, Y+2	; 0x02
    27e8:	93 8b       	std	Z+19, r25	; 0x13
    27ea:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    27ec:	8e 81       	ldd	r24, Y+6	; 0x06
    27ee:	28 2f       	mov	r18, r24
    27f0:	30 e0       	ldi	r19, 0x00	; 0
    27f2:	85 e0       	ldi	r24, 0x05	; 5
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	82 1b       	sub	r24, r18
    27f8:	93 0b       	sbc	r25, r19
    27fa:	e9 81       	ldd	r30, Y+1	; 0x01
    27fc:	fa 81       	ldd	r31, Y+2	; 0x02
    27fe:	95 87       	std	Z+13, r25	; 0x0d
    2800:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2802:	e9 81       	ldd	r30, Y+1	; 0x01
    2804:	fa 81       	ldd	r31, Y+2	; 0x02
    2806:	96 89       	ldd	r25, Z+22	; 0x16
    2808:	80 91 86 00 	lds	r24, 0x0086
    280c:	89 17       	cp	r24, r25
    280e:	28 f4       	brcc	.+10     	; 0x281a <xCoRoutineCreate+0xd6>
    2810:	e9 81       	ldd	r30, Y+1	; 0x01
    2812:	fa 81       	ldd	r31, Y+2	; 0x02
    2814:	86 89       	ldd	r24, Z+22	; 0x16
    2816:	80 93 86 00 	sts	0x0086, r24
    281a:	e9 81       	ldd	r30, Y+1	; 0x01
    281c:	fa 81       	ldd	r31, Y+2	; 0x02
    281e:	86 89       	ldd	r24, Z+22	; 0x16
    2820:	28 2f       	mov	r18, r24
    2822:	30 e0       	ldi	r19, 0x00	; 0
    2824:	c9 01       	movw	r24, r18
    2826:	88 0f       	add	r24, r24
    2828:	99 1f       	adc	r25, r25
    282a:	88 0f       	add	r24, r24
    282c:	99 1f       	adc	r25, r25
    282e:	88 0f       	add	r24, r24
    2830:	99 1f       	adc	r25, r25
    2832:	82 0f       	add	r24, r18
    2834:	93 1f       	adc	r25, r19
    2836:	ac 01       	movw	r20, r24
    2838:	43 57       	subi	r20, 0x73	; 115
    283a:	5f 4f       	sbci	r21, 0xFF	; 255
    283c:	89 81       	ldd	r24, Y+1	; 0x01
    283e:	9a 81       	ldd	r25, Y+2	; 0x02
    2840:	9c 01       	movw	r18, r24
    2842:	2e 5f       	subi	r18, 0xFE	; 254
    2844:	3f 4f       	sbci	r19, 0xFF	; 255
    2846:	ca 01       	movw	r24, r20
    2848:	b9 01       	movw	r22, r18
    284a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>

		xReturn = pdPASS;
    284e:	81 e0       	ldi	r24, 0x01	; 1
    2850:	8b 83       	std	Y+3, r24	; 0x03
    2852:	02 c0       	rjmp	.+4      	; 0x2858 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2854:	8f ef       	ldi	r24, 0xFF	; 255
    2856:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2858:	8b 81       	ldd	r24, Y+3	; 0x03
}
    285a:	27 96       	adiw	r28, 0x07	; 7
    285c:	0f b6       	in	r0, 0x3f	; 63
    285e:	f8 94       	cli
    2860:	de bf       	out	0x3e, r29	; 62
    2862:	0f be       	out	0x3f, r0	; 63
    2864:	cd bf       	out	0x3d, r28	; 61
    2866:	cf 91       	pop	r28
    2868:	df 91       	pop	r29
    286a:	08 95       	ret

0000286c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    286c:	df 93       	push	r29
    286e:	cf 93       	push	r28
    2870:	00 d0       	rcall	.+0      	; 0x2872 <vCoRoutineAddToDelayedList+0x6>
    2872:	00 d0       	rcall	.+0      	; 0x2874 <vCoRoutineAddToDelayedList+0x8>
    2874:	00 d0       	rcall	.+0      	; 0x2876 <vCoRoutineAddToDelayedList+0xa>
    2876:	cd b7       	in	r28, 0x3d	; 61
    2878:	de b7       	in	r29, 0x3e	; 62
    287a:	9c 83       	std	Y+4, r25	; 0x04
    287c:	8b 83       	std	Y+3, r24	; 0x03
    287e:	7e 83       	std	Y+6, r23	; 0x06
    2880:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2882:	20 91 87 00 	lds	r18, 0x0087
    2886:	30 91 88 00 	lds	r19, 0x0088
    288a:	8b 81       	ldd	r24, Y+3	; 0x03
    288c:	9c 81       	ldd	r25, Y+4	; 0x04
    288e:	82 0f       	add	r24, r18
    2890:	93 1f       	adc	r25, r19
    2892:	9a 83       	std	Y+2, r25	; 0x02
    2894:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2896:	80 91 84 00 	lds	r24, 0x0084
    289a:	90 91 85 00 	lds	r25, 0x0085
    289e:	02 96       	adiw	r24, 0x02	; 2
    28a0:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    28a4:	e0 91 84 00 	lds	r30, 0x0084
    28a8:	f0 91 85 00 	lds	r31, 0x0085
    28ac:	89 81       	ldd	r24, Y+1	; 0x01
    28ae:	9a 81       	ldd	r25, Y+2	; 0x02
    28b0:	93 83       	std	Z+3, r25	; 0x03
    28b2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    28b4:	20 91 87 00 	lds	r18, 0x0087
    28b8:	30 91 88 00 	lds	r19, 0x0088
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	9a 81       	ldd	r25, Y+2	; 0x02
    28c0:	82 17       	cp	r24, r18
    28c2:	93 07       	cpc	r25, r19
    28c4:	70 f4       	brcc	.+28     	; 0x28e2 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28c6:	80 91 b3 00 	lds	r24, 0x00B3
    28ca:	90 91 b4 00 	lds	r25, 0x00B4
    28ce:	20 91 84 00 	lds	r18, 0x0084
    28d2:	30 91 85 00 	lds	r19, 0x0085
    28d6:	2e 5f       	subi	r18, 0xFE	; 254
    28d8:	3f 4f       	sbci	r19, 0xFF	; 255
    28da:	b9 01       	movw	r22, r18
    28dc:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vListInsert>
    28e0:	0d c0       	rjmp	.+26     	; 0x28fc <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28e2:	80 91 b1 00 	lds	r24, 0x00B1
    28e6:	90 91 b2 00 	lds	r25, 0x00B2
    28ea:	20 91 84 00 	lds	r18, 0x0084
    28ee:	30 91 85 00 	lds	r19, 0x0085
    28f2:	2e 5f       	subi	r18, 0xFE	; 254
    28f4:	3f 4f       	sbci	r19, 0xFF	; 255
    28f6:	b9 01       	movw	r22, r18
    28f8:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vListInsert>
	}

	if( pxEventList )
    28fc:	8d 81       	ldd	r24, Y+5	; 0x05
    28fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2900:	00 97       	sbiw	r24, 0x00	; 0
    2902:	61 f0       	breq	.+24     	; 0x291c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2904:	80 91 84 00 	lds	r24, 0x0084
    2908:	90 91 85 00 	lds	r25, 0x0085
    290c:	9c 01       	movw	r18, r24
    290e:	24 5f       	subi	r18, 0xF4	; 244
    2910:	3f 4f       	sbci	r19, 0xFF	; 255
    2912:	8d 81       	ldd	r24, Y+5	; 0x05
    2914:	9e 81       	ldd	r25, Y+6	; 0x06
    2916:	b9 01       	movw	r22, r18
    2918:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vListInsert>
	}
}
    291c:	26 96       	adiw	r28, 0x06	; 6
    291e:	0f b6       	in	r0, 0x3f	; 63
    2920:	f8 94       	cli
    2922:	de bf       	out	0x3e, r29	; 62
    2924:	0f be       	out	0x3f, r0	; 63
    2926:	cd bf       	out	0x3d, r28	; 61
    2928:	cf 91       	pop	r28
    292a:	df 91       	pop	r29
    292c:	08 95       	ret

0000292e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    292e:	df 93       	push	r29
    2930:	cf 93       	push	r28
    2932:	00 d0       	rcall	.+0      	; 0x2934 <prvCheckPendingReadyList+0x6>
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	3a c0       	rjmp	.+116    	; 0x29ae <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    293a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    293c:	e0 91 ba 00 	lds	r30, 0x00BA
    2940:	f0 91 bb 00 	lds	r31, 0x00BB
    2944:	86 81       	ldd	r24, Z+6	; 0x06
    2946:	97 81       	ldd	r25, Z+7	; 0x07
    2948:	9a 83       	std	Y+2, r25	; 0x02
    294a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    294c:	89 81       	ldd	r24, Y+1	; 0x01
    294e:	9a 81       	ldd	r25, Y+2	; 0x02
    2950:	0c 96       	adiw	r24, 0x0c	; 12
    2952:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2956:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2958:	89 81       	ldd	r24, Y+1	; 0x01
    295a:	9a 81       	ldd	r25, Y+2	; 0x02
    295c:	02 96       	adiw	r24, 0x02	; 2
    295e:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2962:	e9 81       	ldd	r30, Y+1	; 0x01
    2964:	fa 81       	ldd	r31, Y+2	; 0x02
    2966:	96 89       	ldd	r25, Z+22	; 0x16
    2968:	80 91 86 00 	lds	r24, 0x0086
    296c:	89 17       	cp	r24, r25
    296e:	28 f4       	brcc	.+10     	; 0x297a <prvCheckPendingReadyList+0x4c>
    2970:	e9 81       	ldd	r30, Y+1	; 0x01
    2972:	fa 81       	ldd	r31, Y+2	; 0x02
    2974:	86 89       	ldd	r24, Z+22	; 0x16
    2976:	80 93 86 00 	sts	0x0086, r24
    297a:	e9 81       	ldd	r30, Y+1	; 0x01
    297c:	fa 81       	ldd	r31, Y+2	; 0x02
    297e:	86 89       	ldd	r24, Z+22	; 0x16
    2980:	28 2f       	mov	r18, r24
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	c9 01       	movw	r24, r18
    2986:	88 0f       	add	r24, r24
    2988:	99 1f       	adc	r25, r25
    298a:	88 0f       	add	r24, r24
    298c:	99 1f       	adc	r25, r25
    298e:	88 0f       	add	r24, r24
    2990:	99 1f       	adc	r25, r25
    2992:	82 0f       	add	r24, r18
    2994:	93 1f       	adc	r25, r19
    2996:	ac 01       	movw	r20, r24
    2998:	43 57       	subi	r20, 0x73	; 115
    299a:	5f 4f       	sbci	r21, 0xFF	; 255
    299c:	89 81       	ldd	r24, Y+1	; 0x01
    299e:	9a 81       	ldd	r25, Y+2	; 0x02
    29a0:	9c 01       	movw	r18, r24
    29a2:	2e 5f       	subi	r18, 0xFE	; 254
    29a4:	3f 4f       	sbci	r19, 0xFF	; 255
    29a6:	ca 01       	movw	r24, r20
    29a8:	b9 01       	movw	r22, r18
    29aa:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29ae:	80 91 b5 00 	lds	r24, 0x00B5
    29b2:	88 23       	and	r24, r24
    29b4:	09 f0       	breq	.+2      	; 0x29b8 <prvCheckPendingReadyList+0x8a>
    29b6:	c1 cf       	rjmp	.-126    	; 0x293a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    29b8:	0f 90       	pop	r0
    29ba:	0f 90       	pop	r0
    29bc:	cf 91       	pop	r28
    29be:	df 91       	pop	r29
    29c0:	08 95       	ret

000029c2 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    29c2:	df 93       	push	r29
    29c4:	cf 93       	push	r28
    29c6:	00 d0       	rcall	.+0      	; 0x29c8 <prvCheckDelayedList+0x6>
    29c8:	00 d0       	rcall	.+0      	; 0x29ca <prvCheckDelayedList+0x8>
    29ca:	cd b7       	in	r28, 0x3d	; 61
    29cc:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    29ce:	0e 94 65 22 	call	0x44ca	; 0x44ca <xTaskGetTickCount>
    29d2:	20 91 89 00 	lds	r18, 0x0089
    29d6:	30 91 8a 00 	lds	r19, 0x008A
    29da:	82 1b       	sub	r24, r18
    29dc:	93 0b       	sbc	r25, r19
    29de:	90 93 8c 00 	sts	0x008C, r25
    29e2:	80 93 8b 00 	sts	0x008B, r24
    29e6:	85 c0       	rjmp	.+266    	; 0x2af2 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    29e8:	80 91 87 00 	lds	r24, 0x0087
    29ec:	90 91 88 00 	lds	r25, 0x0088
    29f0:	01 96       	adiw	r24, 0x01	; 1
    29f2:	90 93 88 00 	sts	0x0088, r25
    29f6:	80 93 87 00 	sts	0x0087, r24
		xPassedTicks--;
    29fa:	80 91 8b 00 	lds	r24, 0x008B
    29fe:	90 91 8c 00 	lds	r25, 0x008C
    2a02:	01 97       	sbiw	r24, 0x01	; 1
    2a04:	90 93 8c 00 	sts	0x008C, r25
    2a08:	80 93 8b 00 	sts	0x008B, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a0c:	80 91 87 00 	lds	r24, 0x0087
    2a10:	90 91 88 00 	lds	r25, 0x0088
    2a14:	00 97       	sbiw	r24, 0x00	; 0
    2a16:	09 f0       	breq	.+2      	; 0x2a1a <prvCheckDelayedList+0x58>
    2a18:	64 c0       	rjmp	.+200    	; 0x2ae2 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a1a:	80 91 b1 00 	lds	r24, 0x00B1
    2a1e:	90 91 b2 00 	lds	r25, 0x00B2
    2a22:	9a 83       	std	Y+2, r25	; 0x02
    2a24:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2a26:	80 91 b3 00 	lds	r24, 0x00B3
    2a2a:	90 91 b4 00 	lds	r25, 0x00B4
    2a2e:	90 93 b2 00 	sts	0x00B2, r25
    2a32:	80 93 b1 00 	sts	0x00B1, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a36:	89 81       	ldd	r24, Y+1	; 0x01
    2a38:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3a:	90 93 b4 00 	sts	0x00B4, r25
    2a3e:	80 93 b3 00 	sts	0x00B3, r24
    2a42:	4f c0       	rjmp	.+158    	; 0x2ae2 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a44:	e0 91 b1 00 	lds	r30, 0x00B1
    2a48:	f0 91 b2 00 	lds	r31, 0x00B2
    2a4c:	05 80       	ldd	r0, Z+5	; 0x05
    2a4e:	f6 81       	ldd	r31, Z+6	; 0x06
    2a50:	e0 2d       	mov	r30, r0
    2a52:	86 81       	ldd	r24, Z+6	; 0x06
    2a54:	97 81       	ldd	r25, Z+7	; 0x07
    2a56:	9c 83       	std	Y+4, r25	; 0x04
    2a58:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5e:	22 81       	ldd	r18, Z+2	; 0x02
    2a60:	33 81       	ldd	r19, Z+3	; 0x03
    2a62:	80 91 87 00 	lds	r24, 0x0087
    2a66:	90 91 88 00 	lds	r25, 0x0088
    2a6a:	82 17       	cp	r24, r18
    2a6c:	93 07       	cpc	r25, r19
    2a6e:	08 f4       	brcc	.+2      	; 0x2a72 <prvCheckDelayedList+0xb0>
    2a70:	40 c0       	rjmp	.+128    	; 0x2af2 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2a72:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2a74:	8b 81       	ldd	r24, Y+3	; 0x03
    2a76:	9c 81       	ldd	r25, Y+4	; 0x04
    2a78:	02 96       	adiw	r24, 0x02	; 2
    2a7a:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2a7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a80:	fc 81       	ldd	r31, Y+4	; 0x04
    2a82:	84 89       	ldd	r24, Z+20	; 0x14
    2a84:	95 89       	ldd	r25, Z+21	; 0x15
    2a86:	00 97       	sbiw	r24, 0x00	; 0
    2a88:	29 f0       	breq	.+10     	; 0x2a94 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8e:	0c 96       	adiw	r24, 0x0c	; 12
    2a90:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2a94:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2a96:	eb 81       	ldd	r30, Y+3	; 0x03
    2a98:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9a:	96 89       	ldd	r25, Z+22	; 0x16
    2a9c:	80 91 86 00 	lds	r24, 0x0086
    2aa0:	89 17       	cp	r24, r25
    2aa2:	28 f4       	brcc	.+10     	; 0x2aae <prvCheckDelayedList+0xec>
    2aa4:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa6:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa8:	86 89       	ldd	r24, Z+22	; 0x16
    2aaa:	80 93 86 00 	sts	0x0086, r24
    2aae:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab2:	86 89       	ldd	r24, Z+22	; 0x16
    2ab4:	28 2f       	mov	r18, r24
    2ab6:	30 e0       	ldi	r19, 0x00	; 0
    2ab8:	c9 01       	movw	r24, r18
    2aba:	88 0f       	add	r24, r24
    2abc:	99 1f       	adc	r25, r25
    2abe:	88 0f       	add	r24, r24
    2ac0:	99 1f       	adc	r25, r25
    2ac2:	88 0f       	add	r24, r24
    2ac4:	99 1f       	adc	r25, r25
    2ac6:	82 0f       	add	r24, r18
    2ac8:	93 1f       	adc	r25, r19
    2aca:	ac 01       	movw	r20, r24
    2acc:	43 57       	subi	r20, 0x73	; 115
    2ace:	5f 4f       	sbci	r21, 0xFF	; 255
    2ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad4:	9c 01       	movw	r18, r24
    2ad6:	2e 5f       	subi	r18, 0xFE	; 254
    2ad8:	3f 4f       	sbci	r19, 0xFF	; 255
    2ada:	ca 01       	movw	r24, r20
    2adc:	b9 01       	movw	r22, r18
    2ade:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2ae2:	e0 91 b1 00 	lds	r30, 0x00B1
    2ae6:	f0 91 b2 00 	lds	r31, 0x00B2
    2aea:	80 81       	ld	r24, Z
    2aec:	88 23       	and	r24, r24
    2aee:	09 f0       	breq	.+2      	; 0x2af2 <prvCheckDelayedList+0x130>
    2af0:	a9 cf       	rjmp	.-174    	; 0x2a44 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2af2:	80 91 8b 00 	lds	r24, 0x008B
    2af6:	90 91 8c 00 	lds	r25, 0x008C
    2afa:	00 97       	sbiw	r24, 0x00	; 0
    2afc:	09 f0       	breq	.+2      	; 0x2b00 <prvCheckDelayedList+0x13e>
    2afe:	74 cf       	rjmp	.-280    	; 0x29e8 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2b00:	80 91 87 00 	lds	r24, 0x0087
    2b04:	90 91 88 00 	lds	r25, 0x0088
    2b08:	90 93 8a 00 	sts	0x008A, r25
    2b0c:	80 93 89 00 	sts	0x0089, r24
}
    2b10:	0f 90       	pop	r0
    2b12:	0f 90       	pop	r0
    2b14:	0f 90       	pop	r0
    2b16:	0f 90       	pop	r0
    2b18:	cf 91       	pop	r28
    2b1a:	df 91       	pop	r29
    2b1c:	08 95       	ret

00002b1e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2b1e:	df 93       	push	r29
    2b20:	cf 93       	push	r28
    2b22:	00 d0       	rcall	.+0      	; 0x2b24 <vCoRoutineSchedule+0x6>
    2b24:	cd b7       	in	r28, 0x3d	; 61
    2b26:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2b28:	0e 94 97 14 	call	0x292e	; 0x292e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2b2c:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <prvCheckDelayedList>
    2b30:	0a c0       	rjmp	.+20     	; 0x2b46 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b32:	80 91 86 00 	lds	r24, 0x0086
    2b36:	88 23       	and	r24, r24
    2b38:	09 f4       	brne	.+2      	; 0x2b3c <vCoRoutineSchedule+0x1e>
    2b3a:	66 c0       	rjmp	.+204    	; 0x2c08 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2b3c:	80 91 86 00 	lds	r24, 0x0086
    2b40:	81 50       	subi	r24, 0x01	; 1
    2b42:	80 93 86 00 	sts	0x0086, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b46:	80 91 86 00 	lds	r24, 0x0086
    2b4a:	28 2f       	mov	r18, r24
    2b4c:	30 e0       	ldi	r19, 0x00	; 0
    2b4e:	c9 01       	movw	r24, r18
    2b50:	88 0f       	add	r24, r24
    2b52:	99 1f       	adc	r25, r25
    2b54:	88 0f       	add	r24, r24
    2b56:	99 1f       	adc	r25, r25
    2b58:	88 0f       	add	r24, r24
    2b5a:	99 1f       	adc	r25, r25
    2b5c:	82 0f       	add	r24, r18
    2b5e:	93 1f       	adc	r25, r19
    2b60:	fc 01       	movw	r30, r24
    2b62:	e3 57       	subi	r30, 0x73	; 115
    2b64:	ff 4f       	sbci	r31, 0xFF	; 255
    2b66:	80 81       	ld	r24, Z
    2b68:	88 23       	and	r24, r24
    2b6a:	19 f3       	breq	.-58     	; 0x2b32 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2b6c:	80 91 86 00 	lds	r24, 0x0086
    2b70:	28 2f       	mov	r18, r24
    2b72:	30 e0       	ldi	r19, 0x00	; 0
    2b74:	c9 01       	movw	r24, r18
    2b76:	88 0f       	add	r24, r24
    2b78:	99 1f       	adc	r25, r25
    2b7a:	88 0f       	add	r24, r24
    2b7c:	99 1f       	adc	r25, r25
    2b7e:	88 0f       	add	r24, r24
    2b80:	99 1f       	adc	r25, r25
    2b82:	82 0f       	add	r24, r18
    2b84:	93 1f       	adc	r25, r19
    2b86:	83 57       	subi	r24, 0x73	; 115
    2b88:	9f 4f       	sbci	r25, 0xFF	; 255
    2b8a:	9a 83       	std	Y+2, r25	; 0x02
    2b8c:	89 83       	std	Y+1, r24	; 0x01
    2b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b90:	fa 81       	ldd	r31, Y+2	; 0x02
    2b92:	01 80       	ldd	r0, Z+1	; 0x01
    2b94:	f2 81       	ldd	r31, Z+2	; 0x02
    2b96:	e0 2d       	mov	r30, r0
    2b98:	82 81       	ldd	r24, Z+2	; 0x02
    2b9a:	93 81       	ldd	r25, Z+3	; 0x03
    2b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba0:	92 83       	std	Z+2, r25	; 0x02
    2ba2:	81 83       	std	Z+1, r24	; 0x01
    2ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba8:	21 81       	ldd	r18, Z+1	; 0x01
    2baa:	32 81       	ldd	r19, Z+2	; 0x02
    2bac:	89 81       	ldd	r24, Y+1	; 0x01
    2bae:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb0:	03 96       	adiw	r24, 0x03	; 3
    2bb2:	28 17       	cp	r18, r24
    2bb4:	39 07       	cpc	r19, r25
    2bb6:	59 f4       	brne	.+22     	; 0x2bce <vCoRoutineSchedule+0xb0>
    2bb8:	e9 81       	ldd	r30, Y+1	; 0x01
    2bba:	fa 81       	ldd	r31, Y+2	; 0x02
    2bbc:	01 80       	ldd	r0, Z+1	; 0x01
    2bbe:	f2 81       	ldd	r31, Z+2	; 0x02
    2bc0:	e0 2d       	mov	r30, r0
    2bc2:	82 81       	ldd	r24, Z+2	; 0x02
    2bc4:	93 81       	ldd	r25, Z+3	; 0x03
    2bc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2bca:	92 83       	std	Z+2, r25	; 0x02
    2bcc:	81 83       	std	Z+1, r24	; 0x01
    2bce:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2bd2:	01 80       	ldd	r0, Z+1	; 0x01
    2bd4:	f2 81       	ldd	r31, Z+2	; 0x02
    2bd6:	e0 2d       	mov	r30, r0
    2bd8:	86 81       	ldd	r24, Z+6	; 0x06
    2bda:	97 81       	ldd	r25, Z+7	; 0x07
    2bdc:	90 93 85 00 	sts	0x0085, r25
    2be0:	80 93 84 00 	sts	0x0084, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2be4:	e0 91 84 00 	lds	r30, 0x0084
    2be8:	f0 91 85 00 	lds	r31, 0x0085
    2bec:	40 81       	ld	r20, Z
    2bee:	51 81       	ldd	r21, Z+1	; 0x01
    2bf0:	80 91 84 00 	lds	r24, 0x0084
    2bf4:	90 91 85 00 	lds	r25, 0x0085
    2bf8:	e0 91 84 00 	lds	r30, 0x0084
    2bfc:	f0 91 85 00 	lds	r31, 0x0085
    2c00:	27 89       	ldd	r18, Z+23	; 0x17
    2c02:	62 2f       	mov	r22, r18
    2c04:	fa 01       	movw	r30, r20
    2c06:	09 95       	icall

	return;
}
    2c08:	0f 90       	pop	r0
    2c0a:	0f 90       	pop	r0
    2c0c:	cf 91       	pop	r28
    2c0e:	df 91       	pop	r29
    2c10:	08 95       	ret

00002c12 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2c12:	df 93       	push	r29
    2c14:	cf 93       	push	r28
    2c16:	0f 92       	push	r0
    2c18:	cd b7       	in	r28, 0x3d	; 61
    2c1a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c1c:	19 82       	std	Y+1, r1	; 0x01
    2c1e:	13 c0       	rjmp	.+38     	; 0x2c46 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2c20:	89 81       	ldd	r24, Y+1	; 0x01
    2c22:	28 2f       	mov	r18, r24
    2c24:	30 e0       	ldi	r19, 0x00	; 0
    2c26:	c9 01       	movw	r24, r18
    2c28:	88 0f       	add	r24, r24
    2c2a:	99 1f       	adc	r25, r25
    2c2c:	88 0f       	add	r24, r24
    2c2e:	99 1f       	adc	r25, r25
    2c30:	88 0f       	add	r24, r24
    2c32:	99 1f       	adc	r25, r25
    2c34:	82 0f       	add	r24, r18
    2c36:	93 1f       	adc	r25, r19
    2c38:	83 57       	subi	r24, 0x73	; 115
    2c3a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c3c:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c40:	89 81       	ldd	r24, Y+1	; 0x01
    2c42:	8f 5f       	subi	r24, 0xFF	; 255
    2c44:	89 83       	std	Y+1, r24	; 0x01
    2c46:	89 81       	ldd	r24, Y+1	; 0x01
    2c48:	82 30       	cpi	r24, 0x02	; 2
    2c4a:	50 f3       	brcs	.-44     	; 0x2c20 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2c4c:	8f e9       	ldi	r24, 0x9F	; 159
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2c54:	88 ea       	ldi	r24, 0xA8	; 168
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2c5c:	85 eb       	ldi	r24, 0xB5	; 181
    2c5e:	90 e0       	ldi	r25, 0x00	; 0
    2c60:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2c64:	8f e9       	ldi	r24, 0x9F	; 159
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	90 93 b2 00 	sts	0x00B2, r25
    2c6c:	80 93 b1 00 	sts	0x00B1, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2c70:	88 ea       	ldi	r24, 0xA8	; 168
    2c72:	90 e0       	ldi	r25, 0x00	; 0
    2c74:	90 93 b4 00 	sts	0x00B4, r25
    2c78:	80 93 b3 00 	sts	0x00B3, r24
}
    2c7c:	0f 90       	pop	r0
    2c7e:	cf 91       	pop	r28
    2c80:	df 91       	pop	r29
    2c82:	08 95       	ret

00002c84 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2c84:	df 93       	push	r29
    2c86:	cf 93       	push	r28
    2c88:	00 d0       	rcall	.+0      	; 0x2c8a <xCoRoutineRemoveFromEventList+0x6>
    2c8a:	00 d0       	rcall	.+0      	; 0x2c8c <xCoRoutineRemoveFromEventList+0x8>
    2c8c:	0f 92       	push	r0
    2c8e:	cd b7       	in	r28, 0x3d	; 61
    2c90:	de b7       	in	r29, 0x3e	; 62
    2c92:	9d 83       	std	Y+5, r25	; 0x05
    2c94:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c96:	ec 81       	ldd	r30, Y+4	; 0x04
    2c98:	fd 81       	ldd	r31, Y+5	; 0x05
    2c9a:	05 80       	ldd	r0, Z+5	; 0x05
    2c9c:	f6 81       	ldd	r31, Z+6	; 0x06
    2c9e:	e0 2d       	mov	r30, r0
    2ca0:	86 81       	ldd	r24, Z+6	; 0x06
    2ca2:	97 81       	ldd	r25, Z+7	; 0x07
    2ca4:	9b 83       	std	Y+3, r25	; 0x03
    2ca6:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    2caa:	9b 81       	ldd	r25, Y+3	; 0x03
    2cac:	0c 96       	adiw	r24, 0x0c	; 12
    2cae:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb4:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb6:	9c 01       	movw	r18, r24
    2cb8:	24 5f       	subi	r18, 0xF4	; 244
    2cba:	3f 4f       	sbci	r19, 0xFF	; 255
    2cbc:	85 eb       	ldi	r24, 0xB5	; 181
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
    2cc0:	b9 01       	movw	r22, r18
    2cc2:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2cc6:	ea 81       	ldd	r30, Y+2	; 0x02
    2cc8:	fb 81       	ldd	r31, Y+3	; 0x03
    2cca:	96 89       	ldd	r25, Z+22	; 0x16
    2ccc:	e0 91 84 00 	lds	r30, 0x0084
    2cd0:	f0 91 85 00 	lds	r31, 0x0085
    2cd4:	86 89       	ldd	r24, Z+22	; 0x16
    2cd6:	98 17       	cp	r25, r24
    2cd8:	18 f0       	brcs	.+6      	; 0x2ce0 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2cda:	81 e0       	ldi	r24, 0x01	; 1
    2cdc:	89 83       	std	Y+1, r24	; 0x01
    2cde:	01 c0       	rjmp	.+2      	; 0x2ce2 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2ce0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2ce2:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ce4:	0f 90       	pop	r0
    2ce6:	0f 90       	pop	r0
    2ce8:	0f 90       	pop	r0
    2cea:	0f 90       	pop	r0
    2cec:	0f 90       	pop	r0
    2cee:	cf 91       	pop	r28
    2cf0:	df 91       	pop	r29
    2cf2:	08 95       	ret

00002cf4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2cf4:	df 93       	push	r29
    2cf6:	cf 93       	push	r28
    2cf8:	00 d0       	rcall	.+0      	; 0x2cfa <pvPortMalloc+0x6>
    2cfa:	00 d0       	rcall	.+0      	; 0x2cfc <pvPortMalloc+0x8>
    2cfc:	cd b7       	in	r28, 0x3d	; 61
    2cfe:	de b7       	in	r29, 0x3e	; 62
    2d00:	9c 83       	std	Y+4, r25	; 0x04
    2d02:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2d04:	1a 82       	std	Y+2, r1	; 0x02
    2d06:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2d08:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2d0c:	80 91 be 00 	lds	r24, 0x00BE
    2d10:	90 91 bf 00 	lds	r25, 0x00BF
    2d14:	2b 81       	ldd	r18, Y+3	; 0x03
    2d16:	3c 81       	ldd	r19, Y+4	; 0x04
    2d18:	82 0f       	add	r24, r18
    2d1a:	93 1f       	adc	r25, r19
    2d1c:	23 e0       	ldi	r18, 0x03	; 3
    2d1e:	88 3e       	cpi	r24, 0xE8	; 232
    2d20:	92 07       	cpc	r25, r18
    2d22:	18 f5       	brcc	.+70     	; 0x2d6a <pvPortMalloc+0x76>
    2d24:	20 91 be 00 	lds	r18, 0x00BE
    2d28:	30 91 bf 00 	lds	r19, 0x00BF
    2d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d30:	28 0f       	add	r18, r24
    2d32:	39 1f       	adc	r19, r25
    2d34:	80 91 be 00 	lds	r24, 0x00BE
    2d38:	90 91 bf 00 	lds	r25, 0x00BF
    2d3c:	82 17       	cp	r24, r18
    2d3e:	93 07       	cpc	r25, r19
    2d40:	a0 f4       	brcc	.+40     	; 0x2d6a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2d42:	80 91 be 00 	lds	r24, 0x00BE
    2d46:	90 91 bf 00 	lds	r25, 0x00BF
    2d4a:	80 54       	subi	r24, 0x40	; 64
    2d4c:	9f 4f       	sbci	r25, 0xFF	; 255
    2d4e:	9a 83       	std	Y+2, r25	; 0x02
    2d50:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2d52:	20 91 be 00 	lds	r18, 0x00BE
    2d56:	30 91 bf 00 	lds	r19, 0x00BF
    2d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5e:	82 0f       	add	r24, r18
    2d60:	93 1f       	adc	r25, r19
    2d62:	90 93 bf 00 	sts	0x00BF, r25
    2d66:	80 93 be 00 	sts	0x00BE, r24
		}	
	}
	xTaskResumeAll();
    2d6a:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2d6e:	89 81       	ldd	r24, Y+1	; 0x01
    2d70:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d72:	0f 90       	pop	r0
    2d74:	0f 90       	pop	r0
    2d76:	0f 90       	pop	r0
    2d78:	0f 90       	pop	r0
    2d7a:	cf 91       	pop	r28
    2d7c:	df 91       	pop	r29
    2d7e:	08 95       	ret

00002d80 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2d80:	df 93       	push	r29
    2d82:	cf 93       	push	r28
    2d84:	00 d0       	rcall	.+0      	; 0x2d86 <vPortFree+0x6>
    2d86:	cd b7       	in	r28, 0x3d	; 61
    2d88:	de b7       	in	r29, 0x3e	; 62
    2d8a:	9a 83       	std	Y+2, r25	; 0x02
    2d8c:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2d8e:	0f 90       	pop	r0
    2d90:	0f 90       	pop	r0
    2d92:	cf 91       	pop	r28
    2d94:	df 91       	pop	r29
    2d96:	08 95       	ret

00002d98 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2d98:	df 93       	push	r29
    2d9a:	cf 93       	push	r28
    2d9c:	cd b7       	in	r28, 0x3d	; 61
    2d9e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2da0:	10 92 bf 00 	sts	0x00BF, r1
    2da4:	10 92 be 00 	sts	0x00BE, r1
}
    2da8:	cf 91       	pop	r28
    2daa:	df 91       	pop	r29
    2dac:	08 95       	ret

00002dae <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2dae:	df 93       	push	r29
    2db0:	cf 93       	push	r28
    2db2:	cd b7       	in	r28, 0x3d	; 61
    2db4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2db6:	20 91 be 00 	lds	r18, 0x00BE
    2dba:	30 91 bf 00 	lds	r19, 0x00BF
    2dbe:	88 ee       	ldi	r24, 0xE8	; 232
    2dc0:	93 e0       	ldi	r25, 0x03	; 3
    2dc2:	82 1b       	sub	r24, r18
    2dc4:	93 0b       	sbc	r25, r19
}
    2dc6:	cf 91       	pop	r28
    2dc8:	df 91       	pop	r29
    2dca:	08 95       	ret

00002dcc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2dcc:	df 93       	push	r29
    2dce:	cf 93       	push	r28
    2dd0:	00 d0       	rcall	.+0      	; 0x2dd2 <vListInitialise+0x6>
    2dd2:	cd b7       	in	r28, 0x3d	; 61
    2dd4:	de b7       	in	r29, 0x3e	; 62
    2dd6:	9a 83       	std	Y+2, r25	; 0x02
    2dd8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2dda:	89 81       	ldd	r24, Y+1	; 0x01
    2ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dde:	03 96       	adiw	r24, 0x03	; 3
    2de0:	e9 81       	ldd	r30, Y+1	; 0x01
    2de2:	fa 81       	ldd	r31, Y+2	; 0x02
    2de4:	92 83       	std	Z+2, r25	; 0x02
    2de6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2de8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dea:	fa 81       	ldd	r31, Y+2	; 0x02
    2dec:	8f ef       	ldi	r24, 0xFF	; 255
    2dee:	9f ef       	ldi	r25, 0xFF	; 255
    2df0:	94 83       	std	Z+4, r25	; 0x04
    2df2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2df4:	89 81       	ldd	r24, Y+1	; 0x01
    2df6:	9a 81       	ldd	r25, Y+2	; 0x02
    2df8:	03 96       	adiw	r24, 0x03	; 3
    2dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dfe:	96 83       	std	Z+6, r25	; 0x06
    2e00:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2e02:	89 81       	ldd	r24, Y+1	; 0x01
    2e04:	9a 81       	ldd	r25, Y+2	; 0x02
    2e06:	03 96       	adiw	r24, 0x03	; 3
    2e08:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0c:	90 87       	std	Z+8, r25	; 0x08
    2e0e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2e10:	e9 81       	ldd	r30, Y+1	; 0x01
    2e12:	fa 81       	ldd	r31, Y+2	; 0x02
    2e14:	10 82       	st	Z, r1
}
    2e16:	0f 90       	pop	r0
    2e18:	0f 90       	pop	r0
    2e1a:	cf 91       	pop	r28
    2e1c:	df 91       	pop	r29
    2e1e:	08 95       	ret

00002e20 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2e20:	df 93       	push	r29
    2e22:	cf 93       	push	r28
    2e24:	00 d0       	rcall	.+0      	; 0x2e26 <vListInitialiseItem+0x6>
    2e26:	cd b7       	in	r28, 0x3d	; 61
    2e28:	de b7       	in	r29, 0x3e	; 62
    2e2a:	9a 83       	std	Y+2, r25	; 0x02
    2e2c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e30:	fa 81       	ldd	r31, Y+2	; 0x02
    2e32:	11 86       	std	Z+9, r1	; 0x09
    2e34:	10 86       	std	Z+8, r1	; 0x08
}
    2e36:	0f 90       	pop	r0
    2e38:	0f 90       	pop	r0
    2e3a:	cf 91       	pop	r28
    2e3c:	df 91       	pop	r29
    2e3e:	08 95       	ret

00002e40 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2e40:	df 93       	push	r29
    2e42:	cf 93       	push	r28
    2e44:	00 d0       	rcall	.+0      	; 0x2e46 <vListInsertEnd+0x6>
    2e46:	00 d0       	rcall	.+0      	; 0x2e48 <vListInsertEnd+0x8>
    2e48:	00 d0       	rcall	.+0      	; 0x2e4a <vListInsertEnd+0xa>
    2e4a:	cd b7       	in	r28, 0x3d	; 61
    2e4c:	de b7       	in	r29, 0x3e	; 62
    2e4e:	9c 83       	std	Y+4, r25	; 0x04
    2e50:	8b 83       	std	Y+3, r24	; 0x03
    2e52:	7e 83       	std	Y+6, r23	; 0x06
    2e54:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2e56:	eb 81       	ldd	r30, Y+3	; 0x03
    2e58:	fc 81       	ldd	r31, Y+4	; 0x04
    2e5a:	81 81       	ldd	r24, Z+1	; 0x01
    2e5c:	92 81       	ldd	r25, Z+2	; 0x02
    2e5e:	9a 83       	std	Y+2, r25	; 0x02
    2e60:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2e62:	e9 81       	ldd	r30, Y+1	; 0x01
    2e64:	fa 81       	ldd	r31, Y+2	; 0x02
    2e66:	82 81       	ldd	r24, Z+2	; 0x02
    2e68:	93 81       	ldd	r25, Z+3	; 0x03
    2e6a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e6c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e6e:	93 83       	std	Z+3, r25	; 0x03
    2e70:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2e72:	eb 81       	ldd	r30, Y+3	; 0x03
    2e74:	fc 81       	ldd	r31, Y+4	; 0x04
    2e76:	81 81       	ldd	r24, Z+1	; 0x01
    2e78:	92 81       	ldd	r25, Z+2	; 0x02
    2e7a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e7c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e7e:	95 83       	std	Z+5, r25	; 0x05
    2e80:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2e82:	e9 81       	ldd	r30, Y+1	; 0x01
    2e84:	fa 81       	ldd	r31, Y+2	; 0x02
    2e86:	02 80       	ldd	r0, Z+2	; 0x02
    2e88:	f3 81       	ldd	r31, Z+3	; 0x03
    2e8a:	e0 2d       	mov	r30, r0
    2e8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2e90:	95 83       	std	Z+5, r25	; 0x05
    2e92:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2e94:	8d 81       	ldd	r24, Y+5	; 0x05
    2e96:	9e 81       	ldd	r25, Y+6	; 0x06
    2e98:	e9 81       	ldd	r30, Y+1	; 0x01
    2e9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e9c:	93 83       	std	Z+3, r25	; 0x03
    2e9e:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2ea0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ea2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea8:	92 83       	std	Z+2, r25	; 0x02
    2eaa:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2eac:	ed 81       	ldd	r30, Y+5	; 0x05
    2eae:	fe 81       	ldd	r31, Y+6	; 0x06
    2eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb4:	91 87       	std	Z+9, r25	; 0x09
    2eb6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eba:	fc 81       	ldd	r31, Y+4	; 0x04
    2ebc:	80 81       	ld	r24, Z
    2ebe:	8f 5f       	subi	r24, 0xFF	; 255
    2ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec4:	80 83       	st	Z, r24
}
    2ec6:	26 96       	adiw	r28, 0x06	; 6
    2ec8:	0f b6       	in	r0, 0x3f	; 63
    2eca:	f8 94       	cli
    2ecc:	de bf       	out	0x3e, r29	; 62
    2ece:	0f be       	out	0x3f, r0	; 63
    2ed0:	cd bf       	out	0x3d, r28	; 61
    2ed2:	cf 91       	pop	r28
    2ed4:	df 91       	pop	r29
    2ed6:	08 95       	ret

00002ed8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2ed8:	df 93       	push	r29
    2eda:	cf 93       	push	r28
    2edc:	cd b7       	in	r28, 0x3d	; 61
    2ede:	de b7       	in	r29, 0x3e	; 62
    2ee0:	28 97       	sbiw	r28, 0x08	; 8
    2ee2:	0f b6       	in	r0, 0x3f	; 63
    2ee4:	f8 94       	cli
    2ee6:	de bf       	out	0x3e, r29	; 62
    2ee8:	0f be       	out	0x3f, r0	; 63
    2eea:	cd bf       	out	0x3d, r28	; 61
    2eec:	9e 83       	std	Y+6, r25	; 0x06
    2eee:	8d 83       	std	Y+5, r24	; 0x05
    2ef0:	78 87       	std	Y+8, r23	; 0x08
    2ef2:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2ef4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ef6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ef8:	80 81       	ld	r24, Z
    2efa:	91 81       	ldd	r25, Z+1	; 0x01
    2efc:	9a 83       	std	Y+2, r25	; 0x02
    2efe:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2f00:	89 81       	ldd	r24, Y+1	; 0x01
    2f02:	9a 81       	ldd	r25, Y+2	; 0x02
    2f04:	2f ef       	ldi	r18, 0xFF	; 255
    2f06:	8f 3f       	cpi	r24, 0xFF	; 255
    2f08:	92 07       	cpc	r25, r18
    2f0a:	39 f4       	brne	.+14     	; 0x2f1a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2f0c:	ed 81       	ldd	r30, Y+5	; 0x05
    2f0e:	fe 81       	ldd	r31, Y+6	; 0x06
    2f10:	87 81       	ldd	r24, Z+7	; 0x07
    2f12:	90 85       	ldd	r25, Z+8	; 0x08
    2f14:	9c 83       	std	Y+4, r25	; 0x04
    2f16:	8b 83       	std	Y+3, r24	; 0x03
    2f18:	18 c0       	rjmp	.+48     	; 0x2f4a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2f1a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f1c:	9e 81       	ldd	r25, Y+6	; 0x06
    2f1e:	03 96       	adiw	r24, 0x03	; 3
    2f20:	9c 83       	std	Y+4, r25	; 0x04
    2f22:	8b 83       	std	Y+3, r24	; 0x03
    2f24:	06 c0       	rjmp	.+12     	; 0x2f32 <vListInsert+0x5a>
    2f26:	eb 81       	ldd	r30, Y+3	; 0x03
    2f28:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2a:	82 81       	ldd	r24, Z+2	; 0x02
    2f2c:	93 81       	ldd	r25, Z+3	; 0x03
    2f2e:	9c 83       	std	Y+4, r25	; 0x04
    2f30:	8b 83       	std	Y+3, r24	; 0x03
    2f32:	eb 81       	ldd	r30, Y+3	; 0x03
    2f34:	fc 81       	ldd	r31, Y+4	; 0x04
    2f36:	02 80       	ldd	r0, Z+2	; 0x02
    2f38:	f3 81       	ldd	r31, Z+3	; 0x03
    2f3a:	e0 2d       	mov	r30, r0
    2f3c:	20 81       	ld	r18, Z
    2f3e:	31 81       	ldd	r19, Z+1	; 0x01
    2f40:	89 81       	ldd	r24, Y+1	; 0x01
    2f42:	9a 81       	ldd	r25, Y+2	; 0x02
    2f44:	82 17       	cp	r24, r18
    2f46:	93 07       	cpc	r25, r19
    2f48:	70 f7       	brcc	.-36     	; 0x2f26 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4e:	82 81       	ldd	r24, Z+2	; 0x02
    2f50:	93 81       	ldd	r25, Z+3	; 0x03
    2f52:	ef 81       	ldd	r30, Y+7	; 0x07
    2f54:	f8 85       	ldd	r31, Y+8	; 0x08
    2f56:	93 83       	std	Z+3, r25	; 0x03
    2f58:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2f5a:	ef 81       	ldd	r30, Y+7	; 0x07
    2f5c:	f8 85       	ldd	r31, Y+8	; 0x08
    2f5e:	02 80       	ldd	r0, Z+2	; 0x02
    2f60:	f3 81       	ldd	r31, Z+3	; 0x03
    2f62:	e0 2d       	mov	r30, r0
    2f64:	8f 81       	ldd	r24, Y+7	; 0x07
    2f66:	98 85       	ldd	r25, Y+8	; 0x08
    2f68:	95 83       	std	Z+5, r25	; 0x05
    2f6a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2f6c:	ef 81       	ldd	r30, Y+7	; 0x07
    2f6e:	f8 85       	ldd	r31, Y+8	; 0x08
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    2f72:	9c 81       	ldd	r25, Y+4	; 0x04
    2f74:	95 83       	std	Z+5, r25	; 0x05
    2f76:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2f78:	8f 81       	ldd	r24, Y+7	; 0x07
    2f7a:	98 85       	ldd	r25, Y+8	; 0x08
    2f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f80:	93 83       	std	Z+3, r25	; 0x03
    2f82:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2f84:	ef 81       	ldd	r30, Y+7	; 0x07
    2f86:	f8 85       	ldd	r31, Y+8	; 0x08
    2f88:	8d 81       	ldd	r24, Y+5	; 0x05
    2f8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2f8c:	91 87       	std	Z+9, r25	; 0x09
    2f8e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2f90:	ed 81       	ldd	r30, Y+5	; 0x05
    2f92:	fe 81       	ldd	r31, Y+6	; 0x06
    2f94:	80 81       	ld	r24, Z
    2f96:	8f 5f       	subi	r24, 0xFF	; 255
    2f98:	ed 81       	ldd	r30, Y+5	; 0x05
    2f9a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f9c:	80 83       	st	Z, r24
}
    2f9e:	28 96       	adiw	r28, 0x08	; 8
    2fa0:	0f b6       	in	r0, 0x3f	; 63
    2fa2:	f8 94       	cli
    2fa4:	de bf       	out	0x3e, r29	; 62
    2fa6:	0f be       	out	0x3f, r0	; 63
    2fa8:	cd bf       	out	0x3d, r28	; 61
    2faa:	cf 91       	pop	r28
    2fac:	df 91       	pop	r29
    2fae:	08 95       	ret

00002fb0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2fb0:	df 93       	push	r29
    2fb2:	cf 93       	push	r28
    2fb4:	00 d0       	rcall	.+0      	; 0x2fb6 <vListRemove+0x6>
    2fb6:	00 d0       	rcall	.+0      	; 0x2fb8 <vListRemove+0x8>
    2fb8:	cd b7       	in	r28, 0x3d	; 61
    2fba:	de b7       	in	r29, 0x3e	; 62
    2fbc:	9c 83       	std	Y+4, r25	; 0x04
    2fbe:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2fc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc4:	a2 81       	ldd	r26, Z+2	; 0x02
    2fc6:	b3 81       	ldd	r27, Z+3	; 0x03
    2fc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fca:	fc 81       	ldd	r31, Y+4	; 0x04
    2fcc:	84 81       	ldd	r24, Z+4	; 0x04
    2fce:	95 81       	ldd	r25, Z+5	; 0x05
    2fd0:	15 96       	adiw	r26, 0x05	; 5
    2fd2:	9c 93       	st	X, r25
    2fd4:	8e 93       	st	-X, r24
    2fd6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2fd8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fda:	fc 81       	ldd	r31, Y+4	; 0x04
    2fdc:	a4 81       	ldd	r26, Z+4	; 0x04
    2fde:	b5 81       	ldd	r27, Z+5	; 0x05
    2fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe4:	82 81       	ldd	r24, Z+2	; 0x02
    2fe6:	93 81       	ldd	r25, Z+3	; 0x03
    2fe8:	13 96       	adiw	r26, 0x03	; 3
    2fea:	9c 93       	st	X, r25
    2fec:	8e 93       	st	-X, r24
    2fee:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff4:	80 85       	ldd	r24, Z+8	; 0x08
    2ff6:	91 85       	ldd	r25, Z+9	; 0x09
    2ff8:	9a 83       	std	Y+2, r25	; 0x02
    2ffa:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    3000:	21 81       	ldd	r18, Z+1	; 0x01
    3002:	32 81       	ldd	r19, Z+2	; 0x02
    3004:	8b 81       	ldd	r24, Y+3	; 0x03
    3006:	9c 81       	ldd	r25, Y+4	; 0x04
    3008:	28 17       	cp	r18, r24
    300a:	39 07       	cpc	r19, r25
    300c:	41 f4       	brne	.+16     	; 0x301e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    300e:	eb 81       	ldd	r30, Y+3	; 0x03
    3010:	fc 81       	ldd	r31, Y+4	; 0x04
    3012:	84 81       	ldd	r24, Z+4	; 0x04
    3014:	95 81       	ldd	r25, Z+5	; 0x05
    3016:	e9 81       	ldd	r30, Y+1	; 0x01
    3018:	fa 81       	ldd	r31, Y+2	; 0x02
    301a:	92 83       	std	Z+2, r25	; 0x02
    301c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    301e:	eb 81       	ldd	r30, Y+3	; 0x03
    3020:	fc 81       	ldd	r31, Y+4	; 0x04
    3022:	11 86       	std	Z+9, r1	; 0x09
    3024:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3026:	e9 81       	ldd	r30, Y+1	; 0x01
    3028:	fa 81       	ldd	r31, Y+2	; 0x02
    302a:	80 81       	ld	r24, Z
    302c:	81 50       	subi	r24, 0x01	; 1
    302e:	e9 81       	ldd	r30, Y+1	; 0x01
    3030:	fa 81       	ldd	r31, Y+2	; 0x02
    3032:	80 83       	st	Z, r24
}
    3034:	0f 90       	pop	r0
    3036:	0f 90       	pop	r0
    3038:	0f 90       	pop	r0
    303a:	0f 90       	pop	r0
    303c:	cf 91       	pop	r28
    303e:	df 91       	pop	r29
    3040:	08 95       	ret

00003042 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    3042:	df 93       	push	r29
    3044:	cf 93       	push	r28
    3046:	cd b7       	in	r28, 0x3d	; 61
    3048:	de b7       	in	r29, 0x3e	; 62
    304a:	28 97       	sbiw	r28, 0x08	; 8
    304c:	0f b6       	in	r0, 0x3f	; 63
    304e:	f8 94       	cli
    3050:	de bf       	out	0x3e, r29	; 62
    3052:	0f be       	out	0x3f, r0	; 63
    3054:	cd bf       	out	0x3d, r28	; 61
    3056:	9c 83       	std	Y+4, r25	; 0x04
    3058:	8b 83       	std	Y+3, r24	; 0x03
    305a:	7e 83       	std	Y+6, r23	; 0x06
    305c:	6d 83       	std	Y+5, r22	; 0x05
    305e:	58 87       	std	Y+8, r21	; 0x08
    3060:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3062:	eb 81       	ldd	r30, Y+3	; 0x03
    3064:	fc 81       	ldd	r31, Y+4	; 0x04
    3066:	81 e1       	ldi	r24, 0x11	; 17
    3068:	80 83       	st	Z, r24
	pxTopOfStack--;
    306a:	8b 81       	ldd	r24, Y+3	; 0x03
    306c:	9c 81       	ldd	r25, Y+4	; 0x04
    306e:	01 97       	sbiw	r24, 0x01	; 1
    3070:	9c 83       	std	Y+4, r25	; 0x04
    3072:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3074:	eb 81       	ldd	r30, Y+3	; 0x03
    3076:	fc 81       	ldd	r31, Y+4	; 0x04
    3078:	82 e2       	ldi	r24, 0x22	; 34
    307a:	80 83       	st	Z, r24
	pxTopOfStack--;
    307c:	8b 81       	ldd	r24, Y+3	; 0x03
    307e:	9c 81       	ldd	r25, Y+4	; 0x04
    3080:	01 97       	sbiw	r24, 0x01	; 1
    3082:	9c 83       	std	Y+4, r25	; 0x04
    3084:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3086:	eb 81       	ldd	r30, Y+3	; 0x03
    3088:	fc 81       	ldd	r31, Y+4	; 0x04
    308a:	83 e3       	ldi	r24, 0x33	; 51
    308c:	80 83       	st	Z, r24
	pxTopOfStack--;
    308e:	8b 81       	ldd	r24, Y+3	; 0x03
    3090:	9c 81       	ldd	r25, Y+4	; 0x04
    3092:	01 97       	sbiw	r24, 0x01	; 1
    3094:	9c 83       	std	Y+4, r25	; 0x04
    3096:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    3098:	8d 81       	ldd	r24, Y+5	; 0x05
    309a:	9e 81       	ldd	r25, Y+6	; 0x06
    309c:	9a 83       	std	Y+2, r25	; 0x02
    309e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    30a0:	89 81       	ldd	r24, Y+1	; 0x01
    30a2:	eb 81       	ldd	r30, Y+3	; 0x03
    30a4:	fc 81       	ldd	r31, Y+4	; 0x04
    30a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    30a8:	8b 81       	ldd	r24, Y+3	; 0x03
    30aa:	9c 81       	ldd	r25, Y+4	; 0x04
    30ac:	01 97       	sbiw	r24, 0x01	; 1
    30ae:	9c 83       	std	Y+4, r25	; 0x04
    30b0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    30b2:	89 81       	ldd	r24, Y+1	; 0x01
    30b4:	9a 81       	ldd	r25, Y+2	; 0x02
    30b6:	89 2f       	mov	r24, r25
    30b8:	99 27       	eor	r25, r25
    30ba:	9a 83       	std	Y+2, r25	; 0x02
    30bc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    30be:	89 81       	ldd	r24, Y+1	; 0x01
    30c0:	eb 81       	ldd	r30, Y+3	; 0x03
    30c2:	fc 81       	ldd	r31, Y+4	; 0x04
    30c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    30c6:	8b 81       	ldd	r24, Y+3	; 0x03
    30c8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ca:	01 97       	sbiw	r24, 0x01	; 1
    30cc:	9c 83       	std	Y+4, r25	; 0x04
    30ce:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    30d0:	eb 81       	ldd	r30, Y+3	; 0x03
    30d2:	fc 81       	ldd	r31, Y+4	; 0x04
    30d4:	10 82       	st	Z, r1
	pxTopOfStack--;
    30d6:	8b 81       	ldd	r24, Y+3	; 0x03
    30d8:	9c 81       	ldd	r25, Y+4	; 0x04
    30da:	01 97       	sbiw	r24, 0x01	; 1
    30dc:	9c 83       	std	Y+4, r25	; 0x04
    30de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    30e0:	eb 81       	ldd	r30, Y+3	; 0x03
    30e2:	fc 81       	ldd	r31, Y+4	; 0x04
    30e4:	80 e8       	ldi	r24, 0x80	; 128
    30e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    30e8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ea:	9c 81       	ldd	r25, Y+4	; 0x04
    30ec:	01 97       	sbiw	r24, 0x01	; 1
    30ee:	9c 83       	std	Y+4, r25	; 0x04
    30f0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    30f2:	eb 81       	ldd	r30, Y+3	; 0x03
    30f4:	fc 81       	ldd	r31, Y+4	; 0x04
    30f6:	10 82       	st	Z, r1
	pxTopOfStack--;
    30f8:	8b 81       	ldd	r24, Y+3	; 0x03
    30fa:	9c 81       	ldd	r25, Y+4	; 0x04
    30fc:	01 97       	sbiw	r24, 0x01	; 1
    30fe:	9c 83       	std	Y+4, r25	; 0x04
    3100:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3102:	eb 81       	ldd	r30, Y+3	; 0x03
    3104:	fc 81       	ldd	r31, Y+4	; 0x04
    3106:	82 e0       	ldi	r24, 0x02	; 2
    3108:	80 83       	st	Z, r24
	pxTopOfStack--;
    310a:	8b 81       	ldd	r24, Y+3	; 0x03
    310c:	9c 81       	ldd	r25, Y+4	; 0x04
    310e:	01 97       	sbiw	r24, 0x01	; 1
    3110:	9c 83       	std	Y+4, r25	; 0x04
    3112:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3114:	eb 81       	ldd	r30, Y+3	; 0x03
    3116:	fc 81       	ldd	r31, Y+4	; 0x04
    3118:	83 e0       	ldi	r24, 0x03	; 3
    311a:	80 83       	st	Z, r24
	pxTopOfStack--;
    311c:	8b 81       	ldd	r24, Y+3	; 0x03
    311e:	9c 81       	ldd	r25, Y+4	; 0x04
    3120:	01 97       	sbiw	r24, 0x01	; 1
    3122:	9c 83       	std	Y+4, r25	; 0x04
    3124:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3126:	eb 81       	ldd	r30, Y+3	; 0x03
    3128:	fc 81       	ldd	r31, Y+4	; 0x04
    312a:	84 e0       	ldi	r24, 0x04	; 4
    312c:	80 83       	st	Z, r24
	pxTopOfStack--;
    312e:	8b 81       	ldd	r24, Y+3	; 0x03
    3130:	9c 81       	ldd	r25, Y+4	; 0x04
    3132:	01 97       	sbiw	r24, 0x01	; 1
    3134:	9c 83       	std	Y+4, r25	; 0x04
    3136:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3138:	eb 81       	ldd	r30, Y+3	; 0x03
    313a:	fc 81       	ldd	r31, Y+4	; 0x04
    313c:	85 e0       	ldi	r24, 0x05	; 5
    313e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3140:	8b 81       	ldd	r24, Y+3	; 0x03
    3142:	9c 81       	ldd	r25, Y+4	; 0x04
    3144:	01 97       	sbiw	r24, 0x01	; 1
    3146:	9c 83       	std	Y+4, r25	; 0x04
    3148:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    314a:	eb 81       	ldd	r30, Y+3	; 0x03
    314c:	fc 81       	ldd	r31, Y+4	; 0x04
    314e:	86 e0       	ldi	r24, 0x06	; 6
    3150:	80 83       	st	Z, r24
	pxTopOfStack--;
    3152:	8b 81       	ldd	r24, Y+3	; 0x03
    3154:	9c 81       	ldd	r25, Y+4	; 0x04
    3156:	01 97       	sbiw	r24, 0x01	; 1
    3158:	9c 83       	std	Y+4, r25	; 0x04
    315a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    315c:	eb 81       	ldd	r30, Y+3	; 0x03
    315e:	fc 81       	ldd	r31, Y+4	; 0x04
    3160:	87 e0       	ldi	r24, 0x07	; 7
    3162:	80 83       	st	Z, r24
	pxTopOfStack--;
    3164:	8b 81       	ldd	r24, Y+3	; 0x03
    3166:	9c 81       	ldd	r25, Y+4	; 0x04
    3168:	01 97       	sbiw	r24, 0x01	; 1
    316a:	9c 83       	std	Y+4, r25	; 0x04
    316c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    316e:	eb 81       	ldd	r30, Y+3	; 0x03
    3170:	fc 81       	ldd	r31, Y+4	; 0x04
    3172:	88 e0       	ldi	r24, 0x08	; 8
    3174:	80 83       	st	Z, r24
	pxTopOfStack--;
    3176:	8b 81       	ldd	r24, Y+3	; 0x03
    3178:	9c 81       	ldd	r25, Y+4	; 0x04
    317a:	01 97       	sbiw	r24, 0x01	; 1
    317c:	9c 83       	std	Y+4, r25	; 0x04
    317e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3180:	eb 81       	ldd	r30, Y+3	; 0x03
    3182:	fc 81       	ldd	r31, Y+4	; 0x04
    3184:	89 e0       	ldi	r24, 0x09	; 9
    3186:	80 83       	st	Z, r24
	pxTopOfStack--;
    3188:	8b 81       	ldd	r24, Y+3	; 0x03
    318a:	9c 81       	ldd	r25, Y+4	; 0x04
    318c:	01 97       	sbiw	r24, 0x01	; 1
    318e:	9c 83       	std	Y+4, r25	; 0x04
    3190:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    3192:	eb 81       	ldd	r30, Y+3	; 0x03
    3194:	fc 81       	ldd	r31, Y+4	; 0x04
    3196:	80 e1       	ldi	r24, 0x10	; 16
    3198:	80 83       	st	Z, r24
	pxTopOfStack--;
    319a:	8b 81       	ldd	r24, Y+3	; 0x03
    319c:	9c 81       	ldd	r25, Y+4	; 0x04
    319e:	01 97       	sbiw	r24, 0x01	; 1
    31a0:	9c 83       	std	Y+4, r25	; 0x04
    31a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    31a4:	eb 81       	ldd	r30, Y+3	; 0x03
    31a6:	fc 81       	ldd	r31, Y+4	; 0x04
    31a8:	81 e1       	ldi	r24, 0x11	; 17
    31aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    31ac:	8b 81       	ldd	r24, Y+3	; 0x03
    31ae:	9c 81       	ldd	r25, Y+4	; 0x04
    31b0:	01 97       	sbiw	r24, 0x01	; 1
    31b2:	9c 83       	std	Y+4, r25	; 0x04
    31b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    31b6:	eb 81       	ldd	r30, Y+3	; 0x03
    31b8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ba:	82 e1       	ldi	r24, 0x12	; 18
    31bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    31be:	8b 81       	ldd	r24, Y+3	; 0x03
    31c0:	9c 81       	ldd	r25, Y+4	; 0x04
    31c2:	01 97       	sbiw	r24, 0x01	; 1
    31c4:	9c 83       	std	Y+4, r25	; 0x04
    31c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    31c8:	eb 81       	ldd	r30, Y+3	; 0x03
    31ca:	fc 81       	ldd	r31, Y+4	; 0x04
    31cc:	83 e1       	ldi	r24, 0x13	; 19
    31ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    31d0:	8b 81       	ldd	r24, Y+3	; 0x03
    31d2:	9c 81       	ldd	r25, Y+4	; 0x04
    31d4:	01 97       	sbiw	r24, 0x01	; 1
    31d6:	9c 83       	std	Y+4, r25	; 0x04
    31d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    31da:	eb 81       	ldd	r30, Y+3	; 0x03
    31dc:	fc 81       	ldd	r31, Y+4	; 0x04
    31de:	84 e1       	ldi	r24, 0x14	; 20
    31e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    31e2:	8b 81       	ldd	r24, Y+3	; 0x03
    31e4:	9c 81       	ldd	r25, Y+4	; 0x04
    31e6:	01 97       	sbiw	r24, 0x01	; 1
    31e8:	9c 83       	std	Y+4, r25	; 0x04
    31ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    31ec:	eb 81       	ldd	r30, Y+3	; 0x03
    31ee:	fc 81       	ldd	r31, Y+4	; 0x04
    31f0:	85 e1       	ldi	r24, 0x15	; 21
    31f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    31f4:	8b 81       	ldd	r24, Y+3	; 0x03
    31f6:	9c 81       	ldd	r25, Y+4	; 0x04
    31f8:	01 97       	sbiw	r24, 0x01	; 1
    31fa:	9c 83       	std	Y+4, r25	; 0x04
    31fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    31fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3200:	fc 81       	ldd	r31, Y+4	; 0x04
    3202:	86 e1       	ldi	r24, 0x16	; 22
    3204:	80 83       	st	Z, r24
	pxTopOfStack--;
    3206:	8b 81       	ldd	r24, Y+3	; 0x03
    3208:	9c 81       	ldd	r25, Y+4	; 0x04
    320a:	01 97       	sbiw	r24, 0x01	; 1
    320c:	9c 83       	std	Y+4, r25	; 0x04
    320e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3210:	eb 81       	ldd	r30, Y+3	; 0x03
    3212:	fc 81       	ldd	r31, Y+4	; 0x04
    3214:	87 e1       	ldi	r24, 0x17	; 23
    3216:	80 83       	st	Z, r24
	pxTopOfStack--;
    3218:	8b 81       	ldd	r24, Y+3	; 0x03
    321a:	9c 81       	ldd	r25, Y+4	; 0x04
    321c:	01 97       	sbiw	r24, 0x01	; 1
    321e:	9c 83       	std	Y+4, r25	; 0x04
    3220:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3222:	eb 81       	ldd	r30, Y+3	; 0x03
    3224:	fc 81       	ldd	r31, Y+4	; 0x04
    3226:	88 e1       	ldi	r24, 0x18	; 24
    3228:	80 83       	st	Z, r24
	pxTopOfStack--;
    322a:	8b 81       	ldd	r24, Y+3	; 0x03
    322c:	9c 81       	ldd	r25, Y+4	; 0x04
    322e:	01 97       	sbiw	r24, 0x01	; 1
    3230:	9c 83       	std	Y+4, r25	; 0x04
    3232:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3234:	eb 81       	ldd	r30, Y+3	; 0x03
    3236:	fc 81       	ldd	r31, Y+4	; 0x04
    3238:	89 e1       	ldi	r24, 0x19	; 25
    323a:	80 83       	st	Z, r24
	pxTopOfStack--;
    323c:	8b 81       	ldd	r24, Y+3	; 0x03
    323e:	9c 81       	ldd	r25, Y+4	; 0x04
    3240:	01 97       	sbiw	r24, 0x01	; 1
    3242:	9c 83       	std	Y+4, r25	; 0x04
    3244:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    3246:	eb 81       	ldd	r30, Y+3	; 0x03
    3248:	fc 81       	ldd	r31, Y+4	; 0x04
    324a:	80 e2       	ldi	r24, 0x20	; 32
    324c:	80 83       	st	Z, r24
	pxTopOfStack--;
    324e:	8b 81       	ldd	r24, Y+3	; 0x03
    3250:	9c 81       	ldd	r25, Y+4	; 0x04
    3252:	01 97       	sbiw	r24, 0x01	; 1
    3254:	9c 83       	std	Y+4, r25	; 0x04
    3256:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3258:	eb 81       	ldd	r30, Y+3	; 0x03
    325a:	fc 81       	ldd	r31, Y+4	; 0x04
    325c:	81 e2       	ldi	r24, 0x21	; 33
    325e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3260:	8b 81       	ldd	r24, Y+3	; 0x03
    3262:	9c 81       	ldd	r25, Y+4	; 0x04
    3264:	01 97       	sbiw	r24, 0x01	; 1
    3266:	9c 83       	std	Y+4, r25	; 0x04
    3268:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    326a:	eb 81       	ldd	r30, Y+3	; 0x03
    326c:	fc 81       	ldd	r31, Y+4	; 0x04
    326e:	82 e2       	ldi	r24, 0x22	; 34
    3270:	80 83       	st	Z, r24
	pxTopOfStack--;
    3272:	8b 81       	ldd	r24, Y+3	; 0x03
    3274:	9c 81       	ldd	r25, Y+4	; 0x04
    3276:	01 97       	sbiw	r24, 0x01	; 1
    3278:	9c 83       	std	Y+4, r25	; 0x04
    327a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    327c:	eb 81       	ldd	r30, Y+3	; 0x03
    327e:	fc 81       	ldd	r31, Y+4	; 0x04
    3280:	83 e2       	ldi	r24, 0x23	; 35
    3282:	80 83       	st	Z, r24
	pxTopOfStack--;
    3284:	8b 81       	ldd	r24, Y+3	; 0x03
    3286:	9c 81       	ldd	r25, Y+4	; 0x04
    3288:	01 97       	sbiw	r24, 0x01	; 1
    328a:	9c 83       	std	Y+4, r25	; 0x04
    328c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    328e:	8f 81       	ldd	r24, Y+7	; 0x07
    3290:	98 85       	ldd	r25, Y+8	; 0x08
    3292:	9a 83       	std	Y+2, r25	; 0x02
    3294:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3296:	89 81       	ldd	r24, Y+1	; 0x01
    3298:	eb 81       	ldd	r30, Y+3	; 0x03
    329a:	fc 81       	ldd	r31, Y+4	; 0x04
    329c:	80 83       	st	Z, r24
	pxTopOfStack--;
    329e:	8b 81       	ldd	r24, Y+3	; 0x03
    32a0:	9c 81       	ldd	r25, Y+4	; 0x04
    32a2:	01 97       	sbiw	r24, 0x01	; 1
    32a4:	9c 83       	std	Y+4, r25	; 0x04
    32a6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    32a8:	89 81       	ldd	r24, Y+1	; 0x01
    32aa:	9a 81       	ldd	r25, Y+2	; 0x02
    32ac:	89 2f       	mov	r24, r25
    32ae:	99 27       	eor	r25, r25
    32b0:	9a 83       	std	Y+2, r25	; 0x02
    32b2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    32b4:	89 81       	ldd	r24, Y+1	; 0x01
    32b6:	eb 81       	ldd	r30, Y+3	; 0x03
    32b8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    32bc:	8b 81       	ldd	r24, Y+3	; 0x03
    32be:	9c 81       	ldd	r25, Y+4	; 0x04
    32c0:	01 97       	sbiw	r24, 0x01	; 1
    32c2:	9c 83       	std	Y+4, r25	; 0x04
    32c4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    32c6:	eb 81       	ldd	r30, Y+3	; 0x03
    32c8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ca:	86 e2       	ldi	r24, 0x26	; 38
    32cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    32ce:	8b 81       	ldd	r24, Y+3	; 0x03
    32d0:	9c 81       	ldd	r25, Y+4	; 0x04
    32d2:	01 97       	sbiw	r24, 0x01	; 1
    32d4:	9c 83       	std	Y+4, r25	; 0x04
    32d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    32d8:	eb 81       	ldd	r30, Y+3	; 0x03
    32da:	fc 81       	ldd	r31, Y+4	; 0x04
    32dc:	87 e2       	ldi	r24, 0x27	; 39
    32de:	80 83       	st	Z, r24
	pxTopOfStack--;
    32e0:	8b 81       	ldd	r24, Y+3	; 0x03
    32e2:	9c 81       	ldd	r25, Y+4	; 0x04
    32e4:	01 97       	sbiw	r24, 0x01	; 1
    32e6:	9c 83       	std	Y+4, r25	; 0x04
    32e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    32ea:	eb 81       	ldd	r30, Y+3	; 0x03
    32ec:	fc 81       	ldd	r31, Y+4	; 0x04
    32ee:	88 e2       	ldi	r24, 0x28	; 40
    32f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    32f2:	8b 81       	ldd	r24, Y+3	; 0x03
    32f4:	9c 81       	ldd	r25, Y+4	; 0x04
    32f6:	01 97       	sbiw	r24, 0x01	; 1
    32f8:	9c 83       	std	Y+4, r25	; 0x04
    32fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    32fc:	eb 81       	ldd	r30, Y+3	; 0x03
    32fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3300:	89 e2       	ldi	r24, 0x29	; 41
    3302:	80 83       	st	Z, r24
	pxTopOfStack--;
    3304:	8b 81       	ldd	r24, Y+3	; 0x03
    3306:	9c 81       	ldd	r25, Y+4	; 0x04
    3308:	01 97       	sbiw	r24, 0x01	; 1
    330a:	9c 83       	std	Y+4, r25	; 0x04
    330c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    330e:	eb 81       	ldd	r30, Y+3	; 0x03
    3310:	fc 81       	ldd	r31, Y+4	; 0x04
    3312:	80 e3       	ldi	r24, 0x30	; 48
    3314:	80 83       	st	Z, r24
	pxTopOfStack--;
    3316:	8b 81       	ldd	r24, Y+3	; 0x03
    3318:	9c 81       	ldd	r25, Y+4	; 0x04
    331a:	01 97       	sbiw	r24, 0x01	; 1
    331c:	9c 83       	std	Y+4, r25	; 0x04
    331e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3320:	eb 81       	ldd	r30, Y+3	; 0x03
    3322:	fc 81       	ldd	r31, Y+4	; 0x04
    3324:	81 e3       	ldi	r24, 0x31	; 49
    3326:	80 83       	st	Z, r24
	pxTopOfStack--;
    3328:	8b 81       	ldd	r24, Y+3	; 0x03
    332a:	9c 81       	ldd	r25, Y+4	; 0x04
    332c:	01 97       	sbiw	r24, 0x01	; 1
    332e:	9c 83       	std	Y+4, r25	; 0x04
    3330:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3332:	8b 81       	ldd	r24, Y+3	; 0x03
    3334:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3336:	28 96       	adiw	r28, 0x08	; 8
    3338:	0f b6       	in	r0, 0x3f	; 63
    333a:	f8 94       	cli
    333c:	de bf       	out	0x3e, r29	; 62
    333e:	0f be       	out	0x3f, r0	; 63
    3340:	cd bf       	out	0x3d, r28	; 61
    3342:	cf 91       	pop	r28
    3344:	df 91       	pop	r29
    3346:	08 95       	ret

00003348 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3348:	df 93       	push	r29
    334a:	cf 93       	push	r28
    334c:	cd b7       	in	r28, 0x3d	; 61
    334e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3350:	0e 94 94 1a 	call	0x3528	; 0x3528 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3354:	a0 91 a8 04 	lds	r26, 0x04A8
    3358:	b0 91 a9 04 	lds	r27, 0x04A9
    335c:	cd 91       	ld	r28, X+
    335e:	cd bf       	out	0x3d, r28	; 61
    3360:	dd 91       	ld	r29, X+
    3362:	de bf       	out	0x3e, r29	; 62
    3364:	ff 91       	pop	r31
    3366:	ef 91       	pop	r30
    3368:	df 91       	pop	r29
    336a:	cf 91       	pop	r28
    336c:	bf 91       	pop	r27
    336e:	af 91       	pop	r26
    3370:	9f 91       	pop	r25
    3372:	8f 91       	pop	r24
    3374:	7f 91       	pop	r23
    3376:	6f 91       	pop	r22
    3378:	5f 91       	pop	r21
    337a:	4f 91       	pop	r20
    337c:	3f 91       	pop	r19
    337e:	2f 91       	pop	r18
    3380:	1f 91       	pop	r17
    3382:	0f 91       	pop	r16
    3384:	ff 90       	pop	r15
    3386:	ef 90       	pop	r14
    3388:	df 90       	pop	r13
    338a:	cf 90       	pop	r12
    338c:	bf 90       	pop	r11
    338e:	af 90       	pop	r10
    3390:	9f 90       	pop	r9
    3392:	8f 90       	pop	r8
    3394:	7f 90       	pop	r7
    3396:	6f 90       	pop	r6
    3398:	5f 90       	pop	r5
    339a:	4f 90       	pop	r4
    339c:	3f 90       	pop	r3
    339e:	2f 90       	pop	r2
    33a0:	1f 90       	pop	r1
    33a2:	0f 90       	pop	r0
    33a4:	0f be       	out	0x3f, r0	; 63
    33a6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    33a8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    33aa:	81 e0       	ldi	r24, 0x01	; 1
}
    33ac:	cf 91       	pop	r28
    33ae:	df 91       	pop	r29
    33b0:	08 95       	ret

000033b2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    33b2:	df 93       	push	r29
    33b4:	cf 93       	push	r28
    33b6:	cd b7       	in	r28, 0x3d	; 61
    33b8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    33ba:	cf 91       	pop	r28
    33bc:	df 91       	pop	r29
    33be:	08 95       	ret

000033c0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    33c0:	0f 92       	push	r0
    33c2:	0f b6       	in	r0, 0x3f	; 63
    33c4:	f8 94       	cli
    33c6:	0f 92       	push	r0
    33c8:	1f 92       	push	r1
    33ca:	11 24       	eor	r1, r1
    33cc:	2f 92       	push	r2
    33ce:	3f 92       	push	r3
    33d0:	4f 92       	push	r4
    33d2:	5f 92       	push	r5
    33d4:	6f 92       	push	r6
    33d6:	7f 92       	push	r7
    33d8:	8f 92       	push	r8
    33da:	9f 92       	push	r9
    33dc:	af 92       	push	r10
    33de:	bf 92       	push	r11
    33e0:	cf 92       	push	r12
    33e2:	df 92       	push	r13
    33e4:	ef 92       	push	r14
    33e6:	ff 92       	push	r15
    33e8:	0f 93       	push	r16
    33ea:	1f 93       	push	r17
    33ec:	2f 93       	push	r18
    33ee:	3f 93       	push	r19
    33f0:	4f 93       	push	r20
    33f2:	5f 93       	push	r21
    33f4:	6f 93       	push	r22
    33f6:	7f 93       	push	r23
    33f8:	8f 93       	push	r24
    33fa:	9f 93       	push	r25
    33fc:	af 93       	push	r26
    33fe:	bf 93       	push	r27
    3400:	cf 93       	push	r28
    3402:	df 93       	push	r29
    3404:	ef 93       	push	r30
    3406:	ff 93       	push	r31
    3408:	a0 91 a8 04 	lds	r26, 0x04A8
    340c:	b0 91 a9 04 	lds	r27, 0x04A9
    3410:	0d b6       	in	r0, 0x3d	; 61
    3412:	0d 92       	st	X+, r0
    3414:	0e b6       	in	r0, 0x3e	; 62
    3416:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3418:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    341c:	a0 91 a8 04 	lds	r26, 0x04A8
    3420:	b0 91 a9 04 	lds	r27, 0x04A9
    3424:	cd 91       	ld	r28, X+
    3426:	cd bf       	out	0x3d, r28	; 61
    3428:	dd 91       	ld	r29, X+
    342a:	de bf       	out	0x3e, r29	; 62
    342c:	ff 91       	pop	r31
    342e:	ef 91       	pop	r30
    3430:	df 91       	pop	r29
    3432:	cf 91       	pop	r28
    3434:	bf 91       	pop	r27
    3436:	af 91       	pop	r26
    3438:	9f 91       	pop	r25
    343a:	8f 91       	pop	r24
    343c:	7f 91       	pop	r23
    343e:	6f 91       	pop	r22
    3440:	5f 91       	pop	r21
    3442:	4f 91       	pop	r20
    3444:	3f 91       	pop	r19
    3446:	2f 91       	pop	r18
    3448:	1f 91       	pop	r17
    344a:	0f 91       	pop	r16
    344c:	ff 90       	pop	r15
    344e:	ef 90       	pop	r14
    3450:	df 90       	pop	r13
    3452:	cf 90       	pop	r12
    3454:	bf 90       	pop	r11
    3456:	af 90       	pop	r10
    3458:	9f 90       	pop	r9
    345a:	8f 90       	pop	r8
    345c:	7f 90       	pop	r7
    345e:	6f 90       	pop	r6
    3460:	5f 90       	pop	r5
    3462:	4f 90       	pop	r4
    3464:	3f 90       	pop	r3
    3466:	2f 90       	pop	r2
    3468:	1f 90       	pop	r1
    346a:	0f 90       	pop	r0
    346c:	0f be       	out	0x3f, r0	; 63
    346e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3470:	08 95       	ret

00003472 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3472:	0f 92       	push	r0
    3474:	0f b6       	in	r0, 0x3f	; 63
    3476:	f8 94       	cli
    3478:	0f 92       	push	r0
    347a:	1f 92       	push	r1
    347c:	11 24       	eor	r1, r1
    347e:	2f 92       	push	r2
    3480:	3f 92       	push	r3
    3482:	4f 92       	push	r4
    3484:	5f 92       	push	r5
    3486:	6f 92       	push	r6
    3488:	7f 92       	push	r7
    348a:	8f 92       	push	r8
    348c:	9f 92       	push	r9
    348e:	af 92       	push	r10
    3490:	bf 92       	push	r11
    3492:	cf 92       	push	r12
    3494:	df 92       	push	r13
    3496:	ef 92       	push	r14
    3498:	ff 92       	push	r15
    349a:	0f 93       	push	r16
    349c:	1f 93       	push	r17
    349e:	2f 93       	push	r18
    34a0:	3f 93       	push	r19
    34a2:	4f 93       	push	r20
    34a4:	5f 93       	push	r21
    34a6:	6f 93       	push	r22
    34a8:	7f 93       	push	r23
    34aa:	8f 93       	push	r24
    34ac:	9f 93       	push	r25
    34ae:	af 93       	push	r26
    34b0:	bf 93       	push	r27
    34b2:	cf 93       	push	r28
    34b4:	df 93       	push	r29
    34b6:	ef 93       	push	r30
    34b8:	ff 93       	push	r31
    34ba:	a0 91 a8 04 	lds	r26, 0x04A8
    34be:	b0 91 a9 04 	lds	r27, 0x04A9
    34c2:	0d b6       	in	r0, 0x3d	; 61
    34c4:	0d 92       	st	X+, r0
    34c6:	0e b6       	in	r0, 0x3e	; 62
    34c8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    34ca:	0e 94 9a 22 	call	0x4534	; 0x4534 <vTaskIncrementTick>
	vTaskSwitchContext();
    34ce:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    34d2:	a0 91 a8 04 	lds	r26, 0x04A8
    34d6:	b0 91 a9 04 	lds	r27, 0x04A9
    34da:	cd 91       	ld	r28, X+
    34dc:	cd bf       	out	0x3d, r28	; 61
    34de:	dd 91       	ld	r29, X+
    34e0:	de bf       	out	0x3e, r29	; 62
    34e2:	ff 91       	pop	r31
    34e4:	ef 91       	pop	r30
    34e6:	df 91       	pop	r29
    34e8:	cf 91       	pop	r28
    34ea:	bf 91       	pop	r27
    34ec:	af 91       	pop	r26
    34ee:	9f 91       	pop	r25
    34f0:	8f 91       	pop	r24
    34f2:	7f 91       	pop	r23
    34f4:	6f 91       	pop	r22
    34f6:	5f 91       	pop	r21
    34f8:	4f 91       	pop	r20
    34fa:	3f 91       	pop	r19
    34fc:	2f 91       	pop	r18
    34fe:	1f 91       	pop	r17
    3500:	0f 91       	pop	r16
    3502:	ff 90       	pop	r15
    3504:	ef 90       	pop	r14
    3506:	df 90       	pop	r13
    3508:	cf 90       	pop	r12
    350a:	bf 90       	pop	r11
    350c:	af 90       	pop	r10
    350e:	9f 90       	pop	r9
    3510:	8f 90       	pop	r8
    3512:	7f 90       	pop	r7
    3514:	6f 90       	pop	r6
    3516:	5f 90       	pop	r5
    3518:	4f 90       	pop	r4
    351a:	3f 90       	pop	r3
    351c:	2f 90       	pop	r2
    351e:	1f 90       	pop	r1
    3520:	0f 90       	pop	r0
    3522:	0f be       	out	0x3f, r0	; 63
    3524:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3526:	08 95       	ret

00003528 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3528:	df 93       	push	r29
    352a:	cf 93       	push	r28
    352c:	00 d0       	rcall	.+0      	; 0x352e <prvSetupTimerInterrupt+0x6>
    352e:	00 d0       	rcall	.+0      	; 0x3530 <prvSetupTimerInterrupt+0x8>
    3530:	00 d0       	rcall	.+0      	; 0x3532 <prvSetupTimerInterrupt+0xa>
    3532:	cd b7       	in	r28, 0x3d	; 61
    3534:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3536:	80 e8       	ldi	r24, 0x80	; 128
    3538:	9e e3       	ldi	r25, 0x3E	; 62
    353a:	a0 e0       	ldi	r26, 0x00	; 0
    353c:	b0 e0       	ldi	r27, 0x00	; 0
    353e:	8b 83       	std	Y+3, r24	; 0x03
    3540:	9c 83       	std	Y+4, r25	; 0x04
    3542:	ad 83       	std	Y+5, r26	; 0x05
    3544:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3546:	8b 81       	ldd	r24, Y+3	; 0x03
    3548:	9c 81       	ldd	r25, Y+4	; 0x04
    354a:	ad 81       	ldd	r26, Y+5	; 0x05
    354c:	be 81       	ldd	r27, Y+6	; 0x06
    354e:	68 94       	set
    3550:	15 f8       	bld	r1, 5
    3552:	b6 95       	lsr	r27
    3554:	a7 95       	ror	r26
    3556:	97 95       	ror	r25
    3558:	87 95       	ror	r24
    355a:	16 94       	lsr	r1
    355c:	d1 f7       	brne	.-12     	; 0x3552 <prvSetupTimerInterrupt+0x2a>
    355e:	8b 83       	std	Y+3, r24	; 0x03
    3560:	9c 83       	std	Y+4, r25	; 0x04
    3562:	ad 83       	std	Y+5, r26	; 0x05
    3564:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3566:	8b 81       	ldd	r24, Y+3	; 0x03
    3568:	9c 81       	ldd	r25, Y+4	; 0x04
    356a:	ad 81       	ldd	r26, Y+5	; 0x05
    356c:	be 81       	ldd	r27, Y+6	; 0x06
    356e:	01 97       	sbiw	r24, 0x01	; 1
    3570:	a1 09       	sbc	r26, r1
    3572:	b1 09       	sbc	r27, r1
    3574:	8b 83       	std	Y+3, r24	; 0x03
    3576:	9c 83       	std	Y+4, r25	; 0x04
    3578:	ad 83       	std	Y+5, r26	; 0x05
    357a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    357c:	8b 81       	ldd	r24, Y+3	; 0x03
    357e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3580:	8b 81       	ldd	r24, Y+3	; 0x03
    3582:	9c 81       	ldd	r25, Y+4	; 0x04
    3584:	ad 81       	ldd	r26, Y+5	; 0x05
    3586:	be 81       	ldd	r27, Y+6	; 0x06
    3588:	89 2f       	mov	r24, r25
    358a:	9a 2f       	mov	r25, r26
    358c:	ab 2f       	mov	r26, r27
    358e:	bb 27       	eor	r27, r27
    3590:	8b 83       	std	Y+3, r24	; 0x03
    3592:	9c 83       	std	Y+4, r25	; 0x04
    3594:	ad 83       	std	Y+5, r26	; 0x05
    3596:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3598:	8b 81       	ldd	r24, Y+3	; 0x03
    359a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    359c:	eb e4       	ldi	r30, 0x4B	; 75
    359e:	f0 e0       	ldi	r31, 0x00	; 0
    35a0:	8a 81       	ldd	r24, Y+2	; 0x02
    35a2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    35a4:	ea e4       	ldi	r30, 0x4A	; 74
    35a6:	f0 e0       	ldi	r31, 0x00	; 0
    35a8:	89 81       	ldd	r24, Y+1	; 0x01
    35aa:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    35ac:	8b e0       	ldi	r24, 0x0B	; 11
    35ae:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    35b0:	ee e4       	ldi	r30, 0x4E	; 78
    35b2:	f0 e0       	ldi	r31, 0x00	; 0
    35b4:	89 81       	ldd	r24, Y+1	; 0x01
    35b6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    35b8:	e9 e5       	ldi	r30, 0x59	; 89
    35ba:	f0 e0       	ldi	r31, 0x00	; 0
    35bc:	80 81       	ld	r24, Z
    35be:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    35c0:	89 81       	ldd	r24, Y+1	; 0x01
    35c2:	80 61       	ori	r24, 0x10	; 16
    35c4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    35c6:	e9 e5       	ldi	r30, 0x59	; 89
    35c8:	f0 e0       	ldi	r31, 0x00	; 0
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	80 83       	st	Z, r24
}
    35ce:	26 96       	adiw	r28, 0x06	; 6
    35d0:	0f b6       	in	r0, 0x3f	; 63
    35d2:	f8 94       	cli
    35d4:	de bf       	out	0x3e, r29	; 62
    35d6:	0f be       	out	0x3f, r0	; 63
    35d8:	cd bf       	out	0x3d, r28	; 61
    35da:	cf 91       	pop	r28
    35dc:	df 91       	pop	r29
    35de:	08 95       	ret

000035e0 <__vector_6>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    35e0:	0e 94 39 1a 	call	0x3472	; 0x3472 <vPortYieldFromTick>
		asm volatile ( "reti" );
    35e4:	18 95       	reti

000035e6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    35e6:	df 93       	push	r29
    35e8:	cf 93       	push	r28
    35ea:	cd b7       	in	r28, 0x3d	; 61
    35ec:	de b7       	in	r29, 0x3e	; 62
    35ee:	28 97       	sbiw	r28, 0x08	; 8
    35f0:	0f b6       	in	r0, 0x3f	; 63
    35f2:	f8 94       	cli
    35f4:	de bf       	out	0x3e, r29	; 62
    35f6:	0f be       	out	0x3f, r0	; 63
    35f8:	cd bf       	out	0x3d, r28	; 61
    35fa:	8f 83       	std	Y+7, r24	; 0x07
    35fc:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    35fe:	1a 82       	std	Y+2, r1	; 0x02
    3600:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3602:	8f 81       	ldd	r24, Y+7	; 0x07
    3604:	88 23       	and	r24, r24
    3606:	09 f4       	brne	.+2      	; 0x360a <xQueueCreate+0x24>
    3608:	8c c0       	rjmp	.+280    	; 0x3722 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    360a:	8f e1       	ldi	r24, 0x1F	; 31
    360c:	90 e0       	ldi	r25, 0x00	; 0
    360e:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <pvPortMalloc>
    3612:	9e 83       	std	Y+6, r25	; 0x06
    3614:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3616:	8d 81       	ldd	r24, Y+5	; 0x05
    3618:	9e 81       	ldd	r25, Y+6	; 0x06
    361a:	00 97       	sbiw	r24, 0x00	; 0
    361c:	09 f4       	brne	.+2      	; 0x3620 <xQueueCreate+0x3a>
    361e:	81 c0       	rjmp	.+258    	; 0x3722 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3620:	8f 81       	ldd	r24, Y+7	; 0x07
    3622:	28 2f       	mov	r18, r24
    3624:	30 e0       	ldi	r19, 0x00	; 0
    3626:	88 85       	ldd	r24, Y+8	; 0x08
    3628:	88 2f       	mov	r24, r24
    362a:	90 e0       	ldi	r25, 0x00	; 0
    362c:	ac 01       	movw	r20, r24
    362e:	24 9f       	mul	r18, r20
    3630:	c0 01       	movw	r24, r0
    3632:	25 9f       	mul	r18, r21
    3634:	90 0d       	add	r25, r0
    3636:	34 9f       	mul	r19, r20
    3638:	90 0d       	add	r25, r0
    363a:	11 24       	eor	r1, r1
    363c:	01 96       	adiw	r24, 0x01	; 1
    363e:	9c 83       	std	Y+4, r25	; 0x04
    3640:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3642:	8b 81       	ldd	r24, Y+3	; 0x03
    3644:	9c 81       	ldd	r25, Y+4	; 0x04
    3646:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <pvPortMalloc>
    364a:	ed 81       	ldd	r30, Y+5	; 0x05
    364c:	fe 81       	ldd	r31, Y+6	; 0x06
    364e:	91 83       	std	Z+1, r25	; 0x01
    3650:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3652:	ed 81       	ldd	r30, Y+5	; 0x05
    3654:	fe 81       	ldd	r31, Y+6	; 0x06
    3656:	80 81       	ld	r24, Z
    3658:	91 81       	ldd	r25, Z+1	; 0x01
    365a:	00 97       	sbiw	r24, 0x00	; 0
    365c:	09 f4       	brne	.+2      	; 0x3660 <xQueueCreate+0x7a>
    365e:	5d c0       	rjmp	.+186    	; 0x371a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    3660:	ed 81       	ldd	r30, Y+5	; 0x05
    3662:	fe 81       	ldd	r31, Y+6	; 0x06
    3664:	40 81       	ld	r20, Z
    3666:	51 81       	ldd	r21, Z+1	; 0x01
    3668:	8f 81       	ldd	r24, Y+7	; 0x07
    366a:	28 2f       	mov	r18, r24
    366c:	30 e0       	ldi	r19, 0x00	; 0
    366e:	88 85       	ldd	r24, Y+8	; 0x08
    3670:	88 2f       	mov	r24, r24
    3672:	90 e0       	ldi	r25, 0x00	; 0
    3674:	bc 01       	movw	r22, r24
    3676:	26 9f       	mul	r18, r22
    3678:	c0 01       	movw	r24, r0
    367a:	27 9f       	mul	r18, r23
    367c:	90 0d       	add	r25, r0
    367e:	36 9f       	mul	r19, r22
    3680:	90 0d       	add	r25, r0
    3682:	11 24       	eor	r1, r1
    3684:	84 0f       	add	r24, r20
    3686:	95 1f       	adc	r25, r21
    3688:	ed 81       	ldd	r30, Y+5	; 0x05
    368a:	fe 81       	ldd	r31, Y+6	; 0x06
    368c:	93 83       	std	Z+3, r25	; 0x03
    368e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3690:	ed 81       	ldd	r30, Y+5	; 0x05
    3692:	fe 81       	ldd	r31, Y+6	; 0x06
    3694:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3696:	ed 81       	ldd	r30, Y+5	; 0x05
    3698:	fe 81       	ldd	r31, Y+6	; 0x06
    369a:	80 81       	ld	r24, Z
    369c:	91 81       	ldd	r25, Z+1	; 0x01
    369e:	ed 81       	ldd	r30, Y+5	; 0x05
    36a0:	fe 81       	ldd	r31, Y+6	; 0x06
    36a2:	95 83       	std	Z+5, r25	; 0x05
    36a4:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    36a6:	ed 81       	ldd	r30, Y+5	; 0x05
    36a8:	fe 81       	ldd	r31, Y+6	; 0x06
    36aa:	40 81       	ld	r20, Z
    36ac:	51 81       	ldd	r21, Z+1	; 0x01
    36ae:	8f 81       	ldd	r24, Y+7	; 0x07
    36b0:	88 2f       	mov	r24, r24
    36b2:	90 e0       	ldi	r25, 0x00	; 0
    36b4:	9c 01       	movw	r18, r24
    36b6:	21 50       	subi	r18, 0x01	; 1
    36b8:	30 40       	sbci	r19, 0x00	; 0
    36ba:	88 85       	ldd	r24, Y+8	; 0x08
    36bc:	88 2f       	mov	r24, r24
    36be:	90 e0       	ldi	r25, 0x00	; 0
    36c0:	bc 01       	movw	r22, r24
    36c2:	26 9f       	mul	r18, r22
    36c4:	c0 01       	movw	r24, r0
    36c6:	27 9f       	mul	r18, r23
    36c8:	90 0d       	add	r25, r0
    36ca:	36 9f       	mul	r19, r22
    36cc:	90 0d       	add	r25, r0
    36ce:	11 24       	eor	r1, r1
    36d0:	84 0f       	add	r24, r20
    36d2:	95 1f       	adc	r25, r21
    36d4:	ed 81       	ldd	r30, Y+5	; 0x05
    36d6:	fe 81       	ldd	r31, Y+6	; 0x06
    36d8:	97 83       	std	Z+7, r25	; 0x07
    36da:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    36dc:	ed 81       	ldd	r30, Y+5	; 0x05
    36de:	fe 81       	ldd	r31, Y+6	; 0x06
    36e0:	8f 81       	ldd	r24, Y+7	; 0x07
    36e2:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    36e4:	ed 81       	ldd	r30, Y+5	; 0x05
    36e6:	fe 81       	ldd	r31, Y+6	; 0x06
    36e8:	88 85       	ldd	r24, Y+8	; 0x08
    36ea:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    36ec:	ed 81       	ldd	r30, Y+5	; 0x05
    36ee:	fe 81       	ldd	r31, Y+6	; 0x06
    36f0:	8f ef       	ldi	r24, 0xFF	; 255
    36f2:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    36f4:	ed 81       	ldd	r30, Y+5	; 0x05
    36f6:	fe 81       	ldd	r31, Y+6	; 0x06
    36f8:	8f ef       	ldi	r24, 0xFF	; 255
    36fa:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    36fc:	8d 81       	ldd	r24, Y+5	; 0x05
    36fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3700:	08 96       	adiw	r24, 0x08	; 8
    3702:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3706:	8d 81       	ldd	r24, Y+5	; 0x05
    3708:	9e 81       	ldd	r25, Y+6	; 0x06
    370a:	41 96       	adiw	r24, 0x11	; 17
    370c:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3710:	8d 81       	ldd	r24, Y+5	; 0x05
    3712:	9e 81       	ldd	r25, Y+6	; 0x06
    3714:	9a 83       	std	Y+2, r25	; 0x02
    3716:	89 83       	std	Y+1, r24	; 0x01
    3718:	04 c0       	rjmp	.+8      	; 0x3722 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    371a:	8d 81       	ldd	r24, Y+5	; 0x05
    371c:	9e 81       	ldd	r25, Y+6	; 0x06
    371e:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3722:	89 81       	ldd	r24, Y+1	; 0x01
    3724:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3726:	28 96       	adiw	r28, 0x08	; 8
    3728:	0f b6       	in	r0, 0x3f	; 63
    372a:	f8 94       	cli
    372c:	de bf       	out	0x3e, r29	; 62
    372e:	0f be       	out	0x3f, r0	; 63
    3730:	cd bf       	out	0x3d, r28	; 61
    3732:	cf 91       	pop	r28
    3734:	df 91       	pop	r29
    3736:	08 95       	ret

00003738 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    3738:	df 93       	push	r29
    373a:	cf 93       	push	r28
    373c:	00 d0       	rcall	.+0      	; 0x373e <xQueueCreateCountingSemaphore+0x6>
    373e:	00 d0       	rcall	.+0      	; 0x3740 <xQueueCreateCountingSemaphore+0x8>
    3740:	cd b7       	in	r28, 0x3d	; 61
    3742:	de b7       	in	r29, 0x3e	; 62
    3744:	8b 83       	std	Y+3, r24	; 0x03
    3746:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    3748:	8b 81       	ldd	r24, Y+3	; 0x03
    374a:	60 e0       	ldi	r22, 0x00	; 0
    374c:	0e 94 f3 1a 	call	0x35e6	; 0x35e6 <xQueueCreate>
    3750:	9a 83       	std	Y+2, r25	; 0x02
    3752:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	9a 81       	ldd	r25, Y+2	; 0x02
    3758:	00 97       	sbiw	r24, 0x00	; 0
    375a:	21 f0       	breq	.+8      	; 0x3764 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    375c:	e9 81       	ldd	r30, Y+1	; 0x01
    375e:	fa 81       	ldd	r31, Y+2	; 0x02
    3760:	8c 81       	ldd	r24, Y+4	; 0x04
    3762:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    3764:	89 81       	ldd	r24, Y+1	; 0x01
    3766:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3768:	0f 90       	pop	r0
    376a:	0f 90       	pop	r0
    376c:	0f 90       	pop	r0
    376e:	0f 90       	pop	r0
    3770:	cf 91       	pop	r28
    3772:	df 91       	pop	r29
    3774:	08 95       	ret

00003776 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3776:	df 93       	push	r29
    3778:	cf 93       	push	r28
    377a:	cd b7       	in	r28, 0x3d	; 61
    377c:	de b7       	in	r29, 0x3e	; 62
    377e:	2c 97       	sbiw	r28, 0x0c	; 12
    3780:	0f b6       	in	r0, 0x3f	; 63
    3782:	f8 94       	cli
    3784:	de bf       	out	0x3e, r29	; 62
    3786:	0f be       	out	0x3f, r0	; 63
    3788:	cd bf       	out	0x3d, r28	; 61
    378a:	9e 83       	std	Y+6, r25	; 0x06
    378c:	8d 83       	std	Y+5, r24	; 0x05
    378e:	78 87       	std	Y+8, r23	; 0x08
    3790:	6f 83       	std	Y+7, r22	; 0x07
    3792:	5a 87       	std	Y+10, r21	; 0x0a
    3794:	49 87       	std	Y+9, r20	; 0x09
    3796:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3798:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    379a:	0f b6       	in	r0, 0x3f	; 63
    379c:	f8 94       	cli
    379e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    37a0:	ed 81       	ldd	r30, Y+5	; 0x05
    37a2:	fe 81       	ldd	r31, Y+6	; 0x06
    37a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    37a6:	ed 81       	ldd	r30, Y+5	; 0x05
    37a8:	fe 81       	ldd	r31, Y+6	; 0x06
    37aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    37ac:	98 17       	cp	r25, r24
    37ae:	d8 f4       	brcc	.+54     	; 0x37e6 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    37b0:	8d 81       	ldd	r24, Y+5	; 0x05
    37b2:	9e 81       	ldd	r25, Y+6	; 0x06
    37b4:	2f 81       	ldd	r18, Y+7	; 0x07
    37b6:	38 85       	ldd	r19, Y+8	; 0x08
    37b8:	b9 01       	movw	r22, r18
    37ba:	4b 85       	ldd	r20, Y+11	; 0x0b
    37bc:	0e 94 f6 1d 	call	0x3bec	; 0x3bec <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37c0:	ed 81       	ldd	r30, Y+5	; 0x05
    37c2:	fe 81       	ldd	r31, Y+6	; 0x06
    37c4:	81 89       	ldd	r24, Z+17	; 0x11
    37c6:	88 23       	and	r24, r24
    37c8:	49 f0       	breq	.+18     	; 0x37dc <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    37ca:	8d 81       	ldd	r24, Y+5	; 0x05
    37cc:	9e 81       	ldd	r25, Y+6	; 0x06
    37ce:	41 96       	adiw	r24, 0x11	; 17
    37d0:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    37d4:	81 30       	cpi	r24, 0x01	; 1
    37d6:	11 f4       	brne	.+4      	; 0x37dc <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    37d8:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    37dc:	0f 90       	pop	r0
    37de:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    37e0:	81 e0       	ldi	r24, 0x01	; 1
    37e2:	8c 87       	std	Y+12, r24	; 0x0c
    37e4:	5c c0       	rjmp	.+184    	; 0x389e <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    37e6:	89 85       	ldd	r24, Y+9	; 0x09
    37e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    37ea:	00 97       	sbiw	r24, 0x00	; 0
    37ec:	21 f4       	brne	.+8      	; 0x37f6 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    37ee:	0f 90       	pop	r0
    37f0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    37f2:	1c 86       	std	Y+12, r1	; 0x0c
    37f4:	54 c0       	rjmp	.+168    	; 0x389e <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    37f6:	89 81       	ldd	r24, Y+1	; 0x01
    37f8:	88 23       	and	r24, r24
    37fa:	31 f4       	brne	.+12     	; 0x3808 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    37fc:	ce 01       	movw	r24, r28
    37fe:	02 96       	adiw	r24, 0x02	; 2
    3800:	0e 94 73 24 	call	0x48e6	; 0x48e6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3804:	81 e0       	ldi	r24, 0x01	; 1
    3806:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3808:	0f 90       	pop	r0
    380a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    380c:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3810:	0f b6       	in	r0, 0x3f	; 63
    3812:	f8 94       	cli
    3814:	0f 92       	push	r0
    3816:	ed 81       	ldd	r30, Y+5	; 0x05
    3818:	fe 81       	ldd	r31, Y+6	; 0x06
    381a:	85 8d       	ldd	r24, Z+29	; 0x1d
    381c:	8f 3f       	cpi	r24, 0xFF	; 255
    381e:	19 f4       	brne	.+6      	; 0x3826 <xQueueGenericSend+0xb0>
    3820:	ed 81       	ldd	r30, Y+5	; 0x05
    3822:	fe 81       	ldd	r31, Y+6	; 0x06
    3824:	15 8e       	std	Z+29, r1	; 0x1d
    3826:	ed 81       	ldd	r30, Y+5	; 0x05
    3828:	fe 81       	ldd	r31, Y+6	; 0x06
    382a:	86 8d       	ldd	r24, Z+30	; 0x1e
    382c:	8f 3f       	cpi	r24, 0xFF	; 255
    382e:	19 f4       	brne	.+6      	; 0x3836 <xQueueGenericSend+0xc0>
    3830:	ed 81       	ldd	r30, Y+5	; 0x05
    3832:	fe 81       	ldd	r31, Y+6	; 0x06
    3834:	16 8e       	std	Z+30, r1	; 0x1e
    3836:	0f 90       	pop	r0
    3838:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    383a:	ce 01       	movw	r24, r28
    383c:	02 96       	adiw	r24, 0x02	; 2
    383e:	9e 01       	movw	r18, r28
    3840:	27 5f       	subi	r18, 0xF7	; 247
    3842:	3f 4f       	sbci	r19, 0xFF	; 255
    3844:	b9 01       	movw	r22, r18
    3846:	0e 94 8c 24 	call	0x4918	; 0x4918 <xTaskCheckForTimeOut>
    384a:	88 23       	and	r24, r24
    384c:	09 f5       	brne	.+66     	; 0x3890 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    384e:	8d 81       	ldd	r24, Y+5	; 0x05
    3850:	9e 81       	ldd	r25, Y+6	; 0x06
    3852:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <prvIsQueueFull>
    3856:	88 23       	and	r24, r24
    3858:	a1 f0       	breq	.+40     	; 0x3882 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    385a:	8d 81       	ldd	r24, Y+5	; 0x05
    385c:	9e 81       	ldd	r25, Y+6	; 0x06
    385e:	08 96       	adiw	r24, 0x08	; 8
    3860:	29 85       	ldd	r18, Y+9	; 0x09
    3862:	3a 85       	ldd	r19, Y+10	; 0x0a
    3864:	b9 01       	movw	r22, r18
    3866:	0e 94 d5 23 	call	0x47aa	; 0x47aa <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    386a:	8d 81       	ldd	r24, Y+5	; 0x05
    386c:	9e 81       	ldd	r25, Y+6	; 0x06
    386e:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3872:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    3876:	88 23       	and	r24, r24
    3878:	09 f0       	breq	.+2      	; 0x387c <xQueueGenericSend+0x106>
    387a:	8f cf       	rjmp	.-226    	; 0x379a <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    387c:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
    3880:	8c cf       	rjmp	.-232    	; 0x379a <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3882:	8d 81       	ldd	r24, Y+5	; 0x05
    3884:	9e 81       	ldd	r25, Y+6	; 0x06
    3886:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    388a:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    388e:	85 cf       	rjmp	.-246    	; 0x379a <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3890:	8d 81       	ldd	r24, Y+5	; 0x05
    3892:	9e 81       	ldd	r25, Y+6	; 0x06
    3894:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3898:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    389c:	1c 86       	std	Y+12, r1	; 0x0c
    389e:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    38a0:	2c 96       	adiw	r28, 0x0c	; 12
    38a2:	0f b6       	in	r0, 0x3f	; 63
    38a4:	f8 94       	cli
    38a6:	de bf       	out	0x3e, r29	; 62
    38a8:	0f be       	out	0x3f, r0	; 63
    38aa:	cd bf       	out	0x3d, r28	; 61
    38ac:	cf 91       	pop	r28
    38ae:	df 91       	pop	r29
    38b0:	08 95       	ret

000038b2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    38b2:	df 93       	push	r29
    38b4:	cf 93       	push	r28
    38b6:	cd b7       	in	r28, 0x3d	; 61
    38b8:	de b7       	in	r29, 0x3e	; 62
    38ba:	29 97       	sbiw	r28, 0x09	; 9
    38bc:	0f b6       	in	r0, 0x3f	; 63
    38be:	f8 94       	cli
    38c0:	de bf       	out	0x3e, r29	; 62
    38c2:	0f be       	out	0x3f, r0	; 63
    38c4:	cd bf       	out	0x3d, r28	; 61
    38c6:	9c 83       	std	Y+4, r25	; 0x04
    38c8:	8b 83       	std	Y+3, r24	; 0x03
    38ca:	7e 83       	std	Y+6, r23	; 0x06
    38cc:	6d 83       	std	Y+5, r22	; 0x05
    38ce:	58 87       	std	Y+8, r21	; 0x08
    38d0:	4f 83       	std	Y+7, r20	; 0x07
    38d2:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    38d4:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    38d6:	eb 81       	ldd	r30, Y+3	; 0x03
    38d8:	fc 81       	ldd	r31, Y+4	; 0x04
    38da:	92 8d       	ldd	r25, Z+26	; 0x1a
    38dc:	eb 81       	ldd	r30, Y+3	; 0x03
    38de:	fc 81       	ldd	r31, Y+4	; 0x04
    38e0:	83 8d       	ldd	r24, Z+27	; 0x1b
    38e2:	98 17       	cp	r25, r24
    38e4:	40 f5       	brcc	.+80     	; 0x3936 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    38e6:	8b 81       	ldd	r24, Y+3	; 0x03
    38e8:	9c 81       	ldd	r25, Y+4	; 0x04
    38ea:	2d 81       	ldd	r18, Y+5	; 0x05
    38ec:	3e 81       	ldd	r19, Y+6	; 0x06
    38ee:	b9 01       	movw	r22, r18
    38f0:	49 85       	ldd	r20, Y+9	; 0x09
    38f2:	0e 94 f6 1d 	call	0x3bec	; 0x3bec <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    38f6:	eb 81       	ldd	r30, Y+3	; 0x03
    38f8:	fc 81       	ldd	r31, Y+4	; 0x04
    38fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    38fc:	8f 3f       	cpi	r24, 0xFF	; 255
    38fe:	89 f4       	brne	.+34     	; 0x3922 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	81 89       	ldd	r24, Z+17	; 0x11
    3906:	88 23       	and	r24, r24
    3908:	99 f0       	breq	.+38     	; 0x3930 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    390a:	8b 81       	ldd	r24, Y+3	; 0x03
    390c:	9c 81       	ldd	r25, Y+4	; 0x04
    390e:	41 96       	adiw	r24, 0x11	; 17
    3910:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    3914:	88 23       	and	r24, r24
    3916:	61 f0       	breq	.+24     	; 0x3930 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3918:	ef 81       	ldd	r30, Y+7	; 0x07
    391a:	f8 85       	ldd	r31, Y+8	; 0x08
    391c:	81 e0       	ldi	r24, 0x01	; 1
    391e:	80 83       	st	Z, r24
    3920:	07 c0       	rjmp	.+14     	; 0x3930 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3922:	eb 81       	ldd	r30, Y+3	; 0x03
    3924:	fc 81       	ldd	r31, Y+4	; 0x04
    3926:	86 8d       	ldd	r24, Z+30	; 0x1e
    3928:	8f 5f       	subi	r24, 0xFF	; 255
    392a:	eb 81       	ldd	r30, Y+3	; 0x03
    392c:	fc 81       	ldd	r31, Y+4	; 0x04
    392e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3930:	81 e0       	ldi	r24, 0x01	; 1
    3932:	8a 83       	std	Y+2, r24	; 0x02
    3934:	01 c0       	rjmp	.+2      	; 0x3938 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3936:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3938:	8a 81       	ldd	r24, Y+2	; 0x02
}
    393a:	29 96       	adiw	r28, 0x09	; 9
    393c:	0f b6       	in	r0, 0x3f	; 63
    393e:	f8 94       	cli
    3940:	de bf       	out	0x3e, r29	; 62
    3942:	0f be       	out	0x3f, r0	; 63
    3944:	cd bf       	out	0x3d, r28	; 61
    3946:	cf 91       	pop	r28
    3948:	df 91       	pop	r29
    394a:	08 95       	ret

0000394c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	cd b7       	in	r28, 0x3d	; 61
    3952:	de b7       	in	r29, 0x3e	; 62
    3954:	2e 97       	sbiw	r28, 0x0e	; 14
    3956:	0f b6       	in	r0, 0x3f	; 63
    3958:	f8 94       	cli
    395a:	de bf       	out	0x3e, r29	; 62
    395c:	0f be       	out	0x3f, r0	; 63
    395e:	cd bf       	out	0x3d, r28	; 61
    3960:	98 87       	std	Y+8, r25	; 0x08
    3962:	8f 83       	std	Y+7, r24	; 0x07
    3964:	7a 87       	std	Y+10, r23	; 0x0a
    3966:	69 87       	std	Y+9, r22	; 0x09
    3968:	5c 87       	std	Y+12, r21	; 0x0c
    396a:	4b 87       	std	Y+11, r20	; 0x0b
    396c:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    396e:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3970:	0f b6       	in	r0, 0x3f	; 63
    3972:	f8 94       	cli
    3974:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3976:	ef 81       	ldd	r30, Y+7	; 0x07
    3978:	f8 85       	ldd	r31, Y+8	; 0x08
    397a:	82 8d       	ldd	r24, Z+26	; 0x1a
    397c:	88 23       	and	r24, r24
    397e:	09 f4       	brne	.+2      	; 0x3982 <xQueueGenericReceive+0x36>
    3980:	3f c0       	rjmp	.+126    	; 0x3a00 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3982:	ef 81       	ldd	r30, Y+7	; 0x07
    3984:	f8 85       	ldd	r31, Y+8	; 0x08
    3986:	86 81       	ldd	r24, Z+6	; 0x06
    3988:	97 81       	ldd	r25, Z+7	; 0x07
    398a:	9a 83       	std	Y+2, r25	; 0x02
    398c:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    398e:	8f 81       	ldd	r24, Y+7	; 0x07
    3990:	98 85       	ldd	r25, Y+8	; 0x08
    3992:	29 85       	ldd	r18, Y+9	; 0x09
    3994:	3a 85       	ldd	r19, Y+10	; 0x0a
    3996:	b9 01       	movw	r22, r18
    3998:	0e 94 8b 1e 	call	0x3d16	; 0x3d16 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    399c:	8d 85       	ldd	r24, Y+13	; 0x0d
    399e:	88 23       	and	r24, r24
    39a0:	b1 f4       	brne	.+44     	; 0x39ce <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    39a2:	ef 81       	ldd	r30, Y+7	; 0x07
    39a4:	f8 85       	ldd	r31, Y+8	; 0x08
    39a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    39a8:	81 50       	subi	r24, 0x01	; 1
    39aa:	ef 81       	ldd	r30, Y+7	; 0x07
    39ac:	f8 85       	ldd	r31, Y+8	; 0x08
    39ae:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39b0:	ef 81       	ldd	r30, Y+7	; 0x07
    39b2:	f8 85       	ldd	r31, Y+8	; 0x08
    39b4:	80 85       	ldd	r24, Z+8	; 0x08
    39b6:	88 23       	and	r24, r24
    39b8:	f1 f0       	breq	.+60     	; 0x39f6 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    39ba:	8f 81       	ldd	r24, Y+7	; 0x07
    39bc:	98 85       	ldd	r25, Y+8	; 0x08
    39be:	08 96       	adiw	r24, 0x08	; 8
    39c0:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    39c4:	81 30       	cpi	r24, 0x01	; 1
    39c6:	b9 f4       	brne	.+46     	; 0x39f6 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    39c8:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
    39cc:	14 c0       	rjmp	.+40     	; 0x39f6 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    39ce:	ef 81       	ldd	r30, Y+7	; 0x07
    39d0:	f8 85       	ldd	r31, Y+8	; 0x08
    39d2:	89 81       	ldd	r24, Y+1	; 0x01
    39d4:	9a 81       	ldd	r25, Y+2	; 0x02
    39d6:	97 83       	std	Z+7, r25	; 0x07
    39d8:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    39da:	ef 81       	ldd	r30, Y+7	; 0x07
    39dc:	f8 85       	ldd	r31, Y+8	; 0x08
    39de:	81 89       	ldd	r24, Z+17	; 0x11
    39e0:	88 23       	and	r24, r24
    39e2:	49 f0       	breq	.+18     	; 0x39f6 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    39e4:	8f 81       	ldd	r24, Y+7	; 0x07
    39e6:	98 85       	ldd	r25, Y+8	; 0x08
    39e8:	41 96       	adiw	r24, 0x11	; 17
    39ea:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    39ee:	88 23       	and	r24, r24
    39f0:	11 f0       	breq	.+4      	; 0x39f6 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    39f2:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    39f6:	0f 90       	pop	r0
    39f8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    39fa:	81 e0       	ldi	r24, 0x01	; 1
    39fc:	8e 87       	std	Y+14, r24	; 0x0e
    39fe:	5c c0       	rjmp	.+184    	; 0x3ab8 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3a00:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a02:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a04:	00 97       	sbiw	r24, 0x00	; 0
    3a06:	21 f4       	brne	.+8      	; 0x3a10 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3a08:	0f 90       	pop	r0
    3a0a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3a0c:	1e 86       	std	Y+14, r1	; 0x0e
    3a0e:	54 c0       	rjmp	.+168    	; 0x3ab8 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3a10:	8b 81       	ldd	r24, Y+3	; 0x03
    3a12:	88 23       	and	r24, r24
    3a14:	31 f4       	brne	.+12     	; 0x3a22 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3a16:	ce 01       	movw	r24, r28
    3a18:	04 96       	adiw	r24, 0x04	; 4
    3a1a:	0e 94 73 24 	call	0x48e6	; 0x48e6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3a1e:	81 e0       	ldi	r24, 0x01	; 1
    3a20:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3a22:	0f 90       	pop	r0
    3a24:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3a26:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3a2a:	0f b6       	in	r0, 0x3f	; 63
    3a2c:	f8 94       	cli
    3a2e:	0f 92       	push	r0
    3a30:	ef 81       	ldd	r30, Y+7	; 0x07
    3a32:	f8 85       	ldd	r31, Y+8	; 0x08
    3a34:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a36:	8f 3f       	cpi	r24, 0xFF	; 255
    3a38:	19 f4       	brne	.+6      	; 0x3a40 <xQueueGenericReceive+0xf4>
    3a3a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a3c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a3e:	15 8e       	std	Z+29, r1	; 0x1d
    3a40:	ef 81       	ldd	r30, Y+7	; 0x07
    3a42:	f8 85       	ldd	r31, Y+8	; 0x08
    3a44:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a46:	8f 3f       	cpi	r24, 0xFF	; 255
    3a48:	19 f4       	brne	.+6      	; 0x3a50 <xQueueGenericReceive+0x104>
    3a4a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a4c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a4e:	16 8e       	std	Z+30, r1	; 0x1e
    3a50:	0f 90       	pop	r0
    3a52:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a54:	ce 01       	movw	r24, r28
    3a56:	04 96       	adiw	r24, 0x04	; 4
    3a58:	9e 01       	movw	r18, r28
    3a5a:	25 5f       	subi	r18, 0xF5	; 245
    3a5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a5e:	b9 01       	movw	r22, r18
    3a60:	0e 94 8c 24 	call	0x4918	; 0x4918 <xTaskCheckForTimeOut>
    3a64:	88 23       	and	r24, r24
    3a66:	09 f5       	brne	.+66     	; 0x3aaa <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a68:	8f 81       	ldd	r24, Y+7	; 0x07
    3a6a:	98 85       	ldd	r25, Y+8	; 0x08
    3a6c:	0e 94 27 1f 	call	0x3e4e	; 0x3e4e <prvIsQueueEmpty>
    3a70:	88 23       	and	r24, r24
    3a72:	a1 f0       	breq	.+40     	; 0x3a9c <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3a74:	8f 81       	ldd	r24, Y+7	; 0x07
    3a76:	98 85       	ldd	r25, Y+8	; 0x08
    3a78:	41 96       	adiw	r24, 0x11	; 17
    3a7a:	2b 85       	ldd	r18, Y+11	; 0x0b
    3a7c:	3c 85       	ldd	r19, Y+12	; 0x0c
    3a7e:	b9 01       	movw	r22, r18
    3a80:	0e 94 d5 23 	call	0x47aa	; 0x47aa <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3a84:	8f 81       	ldd	r24, Y+7	; 0x07
    3a86:	98 85       	ldd	r25, Y+8	; 0x08
    3a88:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3a8c:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    3a90:	88 23       	and	r24, r24
    3a92:	09 f0       	breq	.+2      	; 0x3a96 <xQueueGenericReceive+0x14a>
    3a94:	6d cf       	rjmp	.-294    	; 0x3970 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3a96:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
    3a9a:	6a cf       	rjmp	.-300    	; 0x3970 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3a9c:	8f 81       	ldd	r24, Y+7	; 0x07
    3a9e:	98 85       	ldd	r25, Y+8	; 0x08
    3aa0:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3aa4:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    3aa8:	63 cf       	rjmp	.-314    	; 0x3970 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3aaa:	8f 81       	ldd	r24, Y+7	; 0x07
    3aac:	98 85       	ldd	r25, Y+8	; 0x08
    3aae:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3ab2:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3ab6:	1e 86       	std	Y+14, r1	; 0x0e
    3ab8:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3aba:	2e 96       	adiw	r28, 0x0e	; 14
    3abc:	0f b6       	in	r0, 0x3f	; 63
    3abe:	f8 94       	cli
    3ac0:	de bf       	out	0x3e, r29	; 62
    3ac2:	0f be       	out	0x3f, r0	; 63
    3ac4:	cd bf       	out	0x3d, r28	; 61
    3ac6:	cf 91       	pop	r28
    3ac8:	df 91       	pop	r29
    3aca:	08 95       	ret

00003acc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3acc:	df 93       	push	r29
    3ace:	cf 93       	push	r28
    3ad0:	cd b7       	in	r28, 0x3d	; 61
    3ad2:	de b7       	in	r29, 0x3e	; 62
    3ad4:	28 97       	sbiw	r28, 0x08	; 8
    3ad6:	0f b6       	in	r0, 0x3f	; 63
    3ad8:	f8 94       	cli
    3ada:	de bf       	out	0x3e, r29	; 62
    3adc:	0f be       	out	0x3f, r0	; 63
    3ade:	cd bf       	out	0x3d, r28	; 61
    3ae0:	9c 83       	std	Y+4, r25	; 0x04
    3ae2:	8b 83       	std	Y+3, r24	; 0x03
    3ae4:	7e 83       	std	Y+6, r23	; 0x06
    3ae6:	6d 83       	std	Y+5, r22	; 0x05
    3ae8:	58 87       	std	Y+8, r21	; 0x08
    3aea:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3aec:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3aee:	eb 81       	ldd	r30, Y+3	; 0x03
    3af0:	fc 81       	ldd	r31, Y+4	; 0x04
    3af2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3af4:	88 23       	and	r24, r24
    3af6:	71 f1       	breq	.+92     	; 0x3b54 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3af8:	8b 81       	ldd	r24, Y+3	; 0x03
    3afa:	9c 81       	ldd	r25, Y+4	; 0x04
    3afc:	2d 81       	ldd	r18, Y+5	; 0x05
    3afe:	3e 81       	ldd	r19, Y+6	; 0x06
    3b00:	b9 01       	movw	r22, r18
    3b02:	0e 94 8b 1e 	call	0x3d16	; 0x3d16 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3b06:	eb 81       	ldd	r30, Y+3	; 0x03
    3b08:	fc 81       	ldd	r31, Y+4	; 0x04
    3b0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b0c:	81 50       	subi	r24, 0x01	; 1
    3b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b10:	fc 81       	ldd	r31, Y+4	; 0x04
    3b12:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3b14:	eb 81       	ldd	r30, Y+3	; 0x03
    3b16:	fc 81       	ldd	r31, Y+4	; 0x04
    3b18:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b1a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b1c:	89 f4       	brne	.+34     	; 0x3b40 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b1e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b20:	fc 81       	ldd	r31, Y+4	; 0x04
    3b22:	80 85       	ldd	r24, Z+8	; 0x08
    3b24:	88 23       	and	r24, r24
    3b26:	99 f0       	breq	.+38     	; 0x3b4e <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b28:	8b 81       	ldd	r24, Y+3	; 0x03
    3b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b2c:	08 96       	adiw	r24, 0x08	; 8
    3b2e:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    3b32:	88 23       	and	r24, r24
    3b34:	61 f0       	breq	.+24     	; 0x3b4e <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3b36:	ef 81       	ldd	r30, Y+7	; 0x07
    3b38:	f8 85       	ldd	r31, Y+8	; 0x08
    3b3a:	81 e0       	ldi	r24, 0x01	; 1
    3b3c:	80 83       	st	Z, r24
    3b3e:	07 c0       	rjmp	.+14     	; 0x3b4e <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3b40:	eb 81       	ldd	r30, Y+3	; 0x03
    3b42:	fc 81       	ldd	r31, Y+4	; 0x04
    3b44:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b46:	8f 5f       	subi	r24, 0xFF	; 255
    3b48:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b4c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3b4e:	81 e0       	ldi	r24, 0x01	; 1
    3b50:	8a 83       	std	Y+2, r24	; 0x02
    3b52:	01 c0       	rjmp	.+2      	; 0x3b56 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3b54:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b56:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3b58:	28 96       	adiw	r28, 0x08	; 8
    3b5a:	0f b6       	in	r0, 0x3f	; 63
    3b5c:	f8 94       	cli
    3b5e:	de bf       	out	0x3e, r29	; 62
    3b60:	0f be       	out	0x3f, r0	; 63
    3b62:	cd bf       	out	0x3d, r28	; 61
    3b64:	cf 91       	pop	r28
    3b66:	df 91       	pop	r29
    3b68:	08 95       	ret

00003b6a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3b6a:	df 93       	push	r29
    3b6c:	cf 93       	push	r28
    3b6e:	00 d0       	rcall	.+0      	; 0x3b70 <uxQueueMessagesWaiting+0x6>
    3b70:	0f 92       	push	r0
    3b72:	cd b7       	in	r28, 0x3d	; 61
    3b74:	de b7       	in	r29, 0x3e	; 62
    3b76:	9b 83       	std	Y+3, r25	; 0x03
    3b78:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3b7a:	0f b6       	in	r0, 0x3f	; 63
    3b7c:	f8 94       	cli
    3b7e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3b80:	ea 81       	ldd	r30, Y+2	; 0x02
    3b82:	fb 81       	ldd	r31, Y+3	; 0x03
    3b84:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b86:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3b88:	0f 90       	pop	r0
    3b8a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3b8c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b8e:	0f 90       	pop	r0
    3b90:	0f 90       	pop	r0
    3b92:	0f 90       	pop	r0
    3b94:	cf 91       	pop	r28
    3b96:	df 91       	pop	r29
    3b98:	08 95       	ret

00003b9a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3b9a:	df 93       	push	r29
    3b9c:	cf 93       	push	r28
    3b9e:	00 d0       	rcall	.+0      	; 0x3ba0 <uxQueueMessagesWaitingFromISR+0x6>
    3ba0:	0f 92       	push	r0
    3ba2:	cd b7       	in	r28, 0x3d	; 61
    3ba4:	de b7       	in	r29, 0x3e	; 62
    3ba6:	9b 83       	std	Y+3, r25	; 0x03
    3ba8:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3baa:	ea 81       	ldd	r30, Y+2	; 0x02
    3bac:	fb 81       	ldd	r31, Y+3	; 0x03
    3bae:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bb0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3bb2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bb4:	0f 90       	pop	r0
    3bb6:	0f 90       	pop	r0
    3bb8:	0f 90       	pop	r0
    3bba:	cf 91       	pop	r28
    3bbc:	df 91       	pop	r29
    3bbe:	08 95       	ret

00003bc0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3bc0:	df 93       	push	r29
    3bc2:	cf 93       	push	r28
    3bc4:	00 d0       	rcall	.+0      	; 0x3bc6 <vQueueDelete+0x6>
    3bc6:	cd b7       	in	r28, 0x3d	; 61
    3bc8:	de b7       	in	r29, 0x3e	; 62
    3bca:	9a 83       	std	Y+2, r25	; 0x02
    3bcc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3bce:	e9 81       	ldd	r30, Y+1	; 0x01
    3bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    3bd2:	80 81       	ld	r24, Z
    3bd4:	91 81       	ldd	r25, Z+1	; 0x01
    3bd6:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <vPortFree>
	vPortFree( pxQueue );
    3bda:	89 81       	ldd	r24, Y+1	; 0x01
    3bdc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bde:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <vPortFree>
}
    3be2:	0f 90       	pop	r0
    3be4:	0f 90       	pop	r0
    3be6:	cf 91       	pop	r28
    3be8:	df 91       	pop	r29
    3bea:	08 95       	ret

00003bec <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3bec:	df 93       	push	r29
    3bee:	cf 93       	push	r28
    3bf0:	00 d0       	rcall	.+0      	; 0x3bf2 <prvCopyDataToQueue+0x6>
    3bf2:	00 d0       	rcall	.+0      	; 0x3bf4 <prvCopyDataToQueue+0x8>
    3bf4:	0f 92       	push	r0
    3bf6:	cd b7       	in	r28, 0x3d	; 61
    3bf8:	de b7       	in	r29, 0x3e	; 62
    3bfa:	9a 83       	std	Y+2, r25	; 0x02
    3bfc:	89 83       	std	Y+1, r24	; 0x01
    3bfe:	7c 83       	std	Y+4, r23	; 0x04
    3c00:	6b 83       	std	Y+3, r22	; 0x03
    3c02:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3c04:	e9 81       	ldd	r30, Y+1	; 0x01
    3c06:	fa 81       	ldd	r31, Y+2	; 0x02
    3c08:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c0a:	88 23       	and	r24, r24
    3c0c:	09 f4       	brne	.+2      	; 0x3c10 <prvCopyDataToQueue+0x24>
    3c0e:	74 c0       	rjmp	.+232    	; 0x3cf8 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3c10:	8d 81       	ldd	r24, Y+5	; 0x05
    3c12:	88 23       	and	r24, r24
    3c14:	99 f5       	brne	.+102    	; 0x3c7c <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3c16:	e9 81       	ldd	r30, Y+1	; 0x01
    3c18:	fa 81       	ldd	r31, Y+2	; 0x02
    3c1a:	64 81       	ldd	r22, Z+4	; 0x04
    3c1c:	75 81       	ldd	r23, Z+5	; 0x05
    3c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c20:	fa 81       	ldd	r31, Y+2	; 0x02
    3c22:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c24:	48 2f       	mov	r20, r24
    3c26:	50 e0       	ldi	r21, 0x00	; 0
    3c28:	2b 81       	ldd	r18, Y+3	; 0x03
    3c2a:	3c 81       	ldd	r19, Y+4	; 0x04
    3c2c:	cb 01       	movw	r24, r22
    3c2e:	b9 01       	movw	r22, r18
    3c30:	0e 94 3c 28 	call	0x5078	; 0x5078 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3c34:	e9 81       	ldd	r30, Y+1	; 0x01
    3c36:	fa 81       	ldd	r31, Y+2	; 0x02
    3c38:	24 81       	ldd	r18, Z+4	; 0x04
    3c3a:	35 81       	ldd	r19, Z+5	; 0x05
    3c3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c40:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c42:	88 2f       	mov	r24, r24
    3c44:	90 e0       	ldi	r25, 0x00	; 0
    3c46:	82 0f       	add	r24, r18
    3c48:	93 1f       	adc	r25, r19
    3c4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c4e:	95 83       	std	Z+5, r25	; 0x05
    3c50:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3c52:	e9 81       	ldd	r30, Y+1	; 0x01
    3c54:	fa 81       	ldd	r31, Y+2	; 0x02
    3c56:	24 81       	ldd	r18, Z+4	; 0x04
    3c58:	35 81       	ldd	r19, Z+5	; 0x05
    3c5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c5e:	82 81       	ldd	r24, Z+2	; 0x02
    3c60:	93 81       	ldd	r25, Z+3	; 0x03
    3c62:	28 17       	cp	r18, r24
    3c64:	39 07       	cpc	r19, r25
    3c66:	08 f4       	brcc	.+2      	; 0x3c6a <prvCopyDataToQueue+0x7e>
    3c68:	47 c0       	rjmp	.+142    	; 0x3cf8 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6e:	80 81       	ld	r24, Z
    3c70:	91 81       	ldd	r25, Z+1	; 0x01
    3c72:	e9 81       	ldd	r30, Y+1	; 0x01
    3c74:	fa 81       	ldd	r31, Y+2	; 0x02
    3c76:	95 83       	std	Z+5, r25	; 0x05
    3c78:	84 83       	std	Z+4, r24	; 0x04
    3c7a:	3e c0       	rjmp	.+124    	; 0x3cf8 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c80:	66 81       	ldd	r22, Z+6	; 0x06
    3c82:	77 81       	ldd	r23, Z+7	; 0x07
    3c84:	e9 81       	ldd	r30, Y+1	; 0x01
    3c86:	fa 81       	ldd	r31, Y+2	; 0x02
    3c88:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c8a:	48 2f       	mov	r20, r24
    3c8c:	50 e0       	ldi	r21, 0x00	; 0
    3c8e:	2b 81       	ldd	r18, Y+3	; 0x03
    3c90:	3c 81       	ldd	r19, Y+4	; 0x04
    3c92:	cb 01       	movw	r24, r22
    3c94:	b9 01       	movw	r22, r18
    3c96:	0e 94 3c 28 	call	0x5078	; 0x5078 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c9e:	26 81       	ldd	r18, Z+6	; 0x06
    3ca0:	37 81       	ldd	r19, Z+7	; 0x07
    3ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ca6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ca8:	88 2f       	mov	r24, r24
    3caa:	90 e0       	ldi	r25, 0x00	; 0
    3cac:	90 95       	com	r25
    3cae:	81 95       	neg	r24
    3cb0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cb2:	82 0f       	add	r24, r18
    3cb4:	93 1f       	adc	r25, r19
    3cb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3cb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cba:	97 83       	std	Z+7, r25	; 0x07
    3cbc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3cbe:	e9 81       	ldd	r30, Y+1	; 0x01
    3cc0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cc2:	26 81       	ldd	r18, Z+6	; 0x06
    3cc4:	37 81       	ldd	r19, Z+7	; 0x07
    3cc6:	e9 81       	ldd	r30, Y+1	; 0x01
    3cc8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cca:	80 81       	ld	r24, Z
    3ccc:	91 81       	ldd	r25, Z+1	; 0x01
    3cce:	28 17       	cp	r18, r24
    3cd0:	39 07       	cpc	r19, r25
    3cd2:	90 f4       	brcc	.+36     	; 0x3cf8 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3cd4:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd6:	fa 81       	ldd	r31, Y+2	; 0x02
    3cd8:	22 81       	ldd	r18, Z+2	; 0x02
    3cda:	33 81       	ldd	r19, Z+3	; 0x03
    3cdc:	e9 81       	ldd	r30, Y+1	; 0x01
    3cde:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ce2:	88 2f       	mov	r24, r24
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	90 95       	com	r25
    3ce8:	81 95       	neg	r24
    3cea:	9f 4f       	sbci	r25, 0xFF	; 255
    3cec:	82 0f       	add	r24, r18
    3cee:	93 1f       	adc	r25, r19
    3cf0:	e9 81       	ldd	r30, Y+1	; 0x01
    3cf2:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf4:	97 83       	std	Z+7, r25	; 0x07
    3cf6:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3cf8:	e9 81       	ldd	r30, Y+1	; 0x01
    3cfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3cfc:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cfe:	8f 5f       	subi	r24, 0xFF	; 255
    3d00:	e9 81       	ldd	r30, Y+1	; 0x01
    3d02:	fa 81       	ldd	r31, Y+2	; 0x02
    3d04:	82 8f       	std	Z+26, r24	; 0x1a
}
    3d06:	0f 90       	pop	r0
    3d08:	0f 90       	pop	r0
    3d0a:	0f 90       	pop	r0
    3d0c:	0f 90       	pop	r0
    3d0e:	0f 90       	pop	r0
    3d10:	cf 91       	pop	r28
    3d12:	df 91       	pop	r29
    3d14:	08 95       	ret

00003d16 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3d16:	df 93       	push	r29
    3d18:	cf 93       	push	r28
    3d1a:	00 d0       	rcall	.+0      	; 0x3d1c <prvCopyDataFromQueue+0x6>
    3d1c:	00 d0       	rcall	.+0      	; 0x3d1e <prvCopyDataFromQueue+0x8>
    3d1e:	cd b7       	in	r28, 0x3d	; 61
    3d20:	de b7       	in	r29, 0x3e	; 62
    3d22:	9a 83       	std	Y+2, r25	; 0x02
    3d24:	89 83       	std	Y+1, r24	; 0x01
    3d26:	7c 83       	std	Y+4, r23	; 0x04
    3d28:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d2e:	80 81       	ld	r24, Z
    3d30:	91 81       	ldd	r25, Z+1	; 0x01
    3d32:	00 97       	sbiw	r24, 0x00	; 0
    3d34:	89 f1       	breq	.+98     	; 0x3d98 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3d36:	e9 81       	ldd	r30, Y+1	; 0x01
    3d38:	fa 81       	ldd	r31, Y+2	; 0x02
    3d3a:	26 81       	ldd	r18, Z+6	; 0x06
    3d3c:	37 81       	ldd	r19, Z+7	; 0x07
    3d3e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d40:	fa 81       	ldd	r31, Y+2	; 0x02
    3d42:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d44:	88 2f       	mov	r24, r24
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	82 0f       	add	r24, r18
    3d4a:	93 1f       	adc	r25, r19
    3d4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d50:	97 83       	std	Z+7, r25	; 0x07
    3d52:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3d54:	e9 81       	ldd	r30, Y+1	; 0x01
    3d56:	fa 81       	ldd	r31, Y+2	; 0x02
    3d58:	26 81       	ldd	r18, Z+6	; 0x06
    3d5a:	37 81       	ldd	r19, Z+7	; 0x07
    3d5c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d5e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d60:	82 81       	ldd	r24, Z+2	; 0x02
    3d62:	93 81       	ldd	r25, Z+3	; 0x03
    3d64:	28 17       	cp	r18, r24
    3d66:	39 07       	cpc	r19, r25
    3d68:	40 f0       	brcs	.+16     	; 0x3d7a <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3d6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6e:	80 81       	ld	r24, Z
    3d70:	91 81       	ldd	r25, Z+1	; 0x01
    3d72:	e9 81       	ldd	r30, Y+1	; 0x01
    3d74:	fa 81       	ldd	r31, Y+2	; 0x02
    3d76:	97 83       	std	Z+7, r25	; 0x07
    3d78:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d7e:	46 81       	ldd	r20, Z+6	; 0x06
    3d80:	57 81       	ldd	r21, Z+7	; 0x07
    3d82:	e9 81       	ldd	r30, Y+1	; 0x01
    3d84:	fa 81       	ldd	r31, Y+2	; 0x02
    3d86:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d88:	28 2f       	mov	r18, r24
    3d8a:	30 e0       	ldi	r19, 0x00	; 0
    3d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d8e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d90:	ba 01       	movw	r22, r20
    3d92:	a9 01       	movw	r20, r18
    3d94:	0e 94 3c 28 	call	0x5078	; 0x5078 <memcpy>
	}
}
    3d98:	0f 90       	pop	r0
    3d9a:	0f 90       	pop	r0
    3d9c:	0f 90       	pop	r0
    3d9e:	0f 90       	pop	r0
    3da0:	cf 91       	pop	r28
    3da2:	df 91       	pop	r29
    3da4:	08 95       	ret

00003da6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    3da6:	df 93       	push	r29
    3da8:	cf 93       	push	r28
    3daa:	00 d0       	rcall	.+0      	; 0x3dac <prvUnlockQueue+0x6>
    3dac:	cd b7       	in	r28, 0x3d	; 61
    3dae:	de b7       	in	r29, 0x3e	; 62
    3db0:	9a 83       	std	Y+2, r25	; 0x02
    3db2:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3db4:	0f b6       	in	r0, 0x3f	; 63
    3db6:	f8 94       	cli
    3db8:	0f 92       	push	r0
    3dba:	15 c0       	rjmp	.+42     	; 0x3de6 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc0:	81 89       	ldd	r24, Z+17	; 0x11
    3dc2:	88 23       	and	r24, r24
    3dc4:	a9 f0       	breq	.+42     	; 0x3df0 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3dc6:	89 81       	ldd	r24, Y+1	; 0x01
    3dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dca:	41 96       	adiw	r24, 0x11	; 17
    3dcc:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    3dd0:	88 23       	and	r24, r24
    3dd2:	11 f0       	breq	.+4      	; 0x3dd8 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3dd4:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3dd8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dda:	fa 81       	ldd	r31, Y+2	; 0x02
    3ddc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dde:	81 50       	subi	r24, 0x01	; 1
    3de0:	e9 81       	ldd	r30, Y+1	; 0x01
    3de2:	fa 81       	ldd	r31, Y+2	; 0x02
    3de4:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3de6:	e9 81       	ldd	r30, Y+1	; 0x01
    3de8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dea:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dec:	18 16       	cp	r1, r24
    3dee:	34 f3       	brlt	.-52     	; 0x3dbc <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3df0:	e9 81       	ldd	r30, Y+1	; 0x01
    3df2:	fa 81       	ldd	r31, Y+2	; 0x02
    3df4:	8f ef       	ldi	r24, 0xFF	; 255
    3df6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3df8:	0f 90       	pop	r0
    3dfa:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3dfc:	0f b6       	in	r0, 0x3f	; 63
    3dfe:	f8 94       	cli
    3e00:	0f 92       	push	r0
    3e02:	15 c0       	rjmp	.+42     	; 0x3e2e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e04:	e9 81       	ldd	r30, Y+1	; 0x01
    3e06:	fa 81       	ldd	r31, Y+2	; 0x02
    3e08:	80 85       	ldd	r24, Z+8	; 0x08
    3e0a:	88 23       	and	r24, r24
    3e0c:	a9 f0       	breq	.+42     	; 0x3e38 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e0e:	89 81       	ldd	r24, Y+1	; 0x01
    3e10:	9a 81       	ldd	r25, Y+2	; 0x02
    3e12:	08 96       	adiw	r24, 0x08	; 8
    3e14:	0e 94 0b 24 	call	0x4816	; 0x4816 <xTaskRemoveFromEventList>
    3e18:	88 23       	and	r24, r24
    3e1a:	11 f0       	breq	.+4      	; 0x3e20 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3e1c:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3e20:	e9 81       	ldd	r30, Y+1	; 0x01
    3e22:	fa 81       	ldd	r31, Y+2	; 0x02
    3e24:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e26:	81 50       	subi	r24, 0x01	; 1
    3e28:	e9 81       	ldd	r30, Y+1	; 0x01
    3e2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e2c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e30:	fa 81       	ldd	r31, Y+2	; 0x02
    3e32:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e34:	18 16       	cp	r1, r24
    3e36:	34 f3       	brlt	.-52     	; 0x3e04 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3e38:	e9 81       	ldd	r30, Y+1	; 0x01
    3e3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e3c:	8f ef       	ldi	r24, 0xFF	; 255
    3e3e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3e40:	0f 90       	pop	r0
    3e42:	0f be       	out	0x3f, r0	; 63
}
    3e44:	0f 90       	pop	r0
    3e46:	0f 90       	pop	r0
    3e48:	cf 91       	pop	r28
    3e4a:	df 91       	pop	r29
    3e4c:	08 95       	ret

00003e4e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3e4e:	df 93       	push	r29
    3e50:	cf 93       	push	r28
    3e52:	00 d0       	rcall	.+0      	; 0x3e54 <prvIsQueueEmpty+0x6>
    3e54:	0f 92       	push	r0
    3e56:	cd b7       	in	r28, 0x3d	; 61
    3e58:	de b7       	in	r29, 0x3e	; 62
    3e5a:	9b 83       	std	Y+3, r25	; 0x03
    3e5c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3e5e:	0f b6       	in	r0, 0x3f	; 63
    3e60:	f8 94       	cli
    3e62:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3e64:	ea 81       	ldd	r30, Y+2	; 0x02
    3e66:	fb 81       	ldd	r31, Y+3	; 0x03
    3e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e6a:	19 82       	std	Y+1, r1	; 0x01
    3e6c:	88 23       	and	r24, r24
    3e6e:	11 f4       	brne	.+4      	; 0x3e74 <prvIsQueueEmpty+0x26>
    3e70:	81 e0       	ldi	r24, 0x01	; 1
    3e72:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3e74:	0f 90       	pop	r0
    3e76:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3e78:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e7a:	0f 90       	pop	r0
    3e7c:	0f 90       	pop	r0
    3e7e:	0f 90       	pop	r0
    3e80:	cf 91       	pop	r28
    3e82:	df 91       	pop	r29
    3e84:	08 95       	ret

00003e86 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    3e86:	df 93       	push	r29
    3e88:	cf 93       	push	r28
    3e8a:	00 d0       	rcall	.+0      	; 0x3e8c <xQueueIsQueueEmptyFromISR+0x6>
    3e8c:	0f 92       	push	r0
    3e8e:	cd b7       	in	r28, 0x3d	; 61
    3e90:	de b7       	in	r29, 0x3e	; 62
    3e92:	9b 83       	std	Y+3, r25	; 0x03
    3e94:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3e96:	ea 81       	ldd	r30, Y+2	; 0x02
    3e98:	fb 81       	ldd	r31, Y+3	; 0x03
    3e9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e9c:	19 82       	std	Y+1, r1	; 0x01
    3e9e:	88 23       	and	r24, r24
    3ea0:	11 f4       	brne	.+4      	; 0x3ea6 <xQueueIsQueueEmptyFromISR+0x20>
    3ea2:	81 e0       	ldi	r24, 0x01	; 1
    3ea4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3ea6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ea8:	0f 90       	pop	r0
    3eaa:	0f 90       	pop	r0
    3eac:	0f 90       	pop	r0
    3eae:	cf 91       	pop	r28
    3eb0:	df 91       	pop	r29
    3eb2:	08 95       	ret

00003eb4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    3eb4:	df 93       	push	r29
    3eb6:	cf 93       	push	r28
    3eb8:	00 d0       	rcall	.+0      	; 0x3eba <prvIsQueueFull+0x6>
    3eba:	0f 92       	push	r0
    3ebc:	cd b7       	in	r28, 0x3d	; 61
    3ebe:	de b7       	in	r29, 0x3e	; 62
    3ec0:	9b 83       	std	Y+3, r25	; 0x03
    3ec2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3ec4:	0f b6       	in	r0, 0x3f	; 63
    3ec6:	f8 94       	cli
    3ec8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3eca:	ea 81       	ldd	r30, Y+2	; 0x02
    3ecc:	fb 81       	ldd	r31, Y+3	; 0x03
    3ece:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ed0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ed2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ed4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ed6:	19 82       	std	Y+1, r1	; 0x01
    3ed8:	98 17       	cp	r25, r24
    3eda:	11 f4       	brne	.+4      	; 0x3ee0 <prvIsQueueFull+0x2c>
    3edc:	81 e0       	ldi	r24, 0x01	; 1
    3ede:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3ee0:	0f 90       	pop	r0
    3ee2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3ee4:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ee6:	0f 90       	pop	r0
    3ee8:	0f 90       	pop	r0
    3eea:	0f 90       	pop	r0
    3eec:	cf 91       	pop	r28
    3eee:	df 91       	pop	r29
    3ef0:	08 95       	ret

00003ef2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3ef2:	df 93       	push	r29
    3ef4:	cf 93       	push	r28
    3ef6:	00 d0       	rcall	.+0      	; 0x3ef8 <xQueueIsQueueFullFromISR+0x6>
    3ef8:	0f 92       	push	r0
    3efa:	cd b7       	in	r28, 0x3d	; 61
    3efc:	de b7       	in	r29, 0x3e	; 62
    3efe:	9b 83       	std	Y+3, r25	; 0x03
    3f00:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3f02:	ea 81       	ldd	r30, Y+2	; 0x02
    3f04:	fb 81       	ldd	r31, Y+3	; 0x03
    3f06:	92 8d       	ldd	r25, Z+26	; 0x1a
    3f08:	ea 81       	ldd	r30, Y+2	; 0x02
    3f0a:	fb 81       	ldd	r31, Y+3	; 0x03
    3f0c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f0e:	19 82       	std	Y+1, r1	; 0x01
    3f10:	98 17       	cp	r25, r24
    3f12:	11 f4       	brne	.+4      	; 0x3f18 <xQueueIsQueueFullFromISR+0x26>
    3f14:	81 e0       	ldi	r24, 0x01	; 1
    3f16:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3f18:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f1a:	0f 90       	pop	r0
    3f1c:	0f 90       	pop	r0
    3f1e:	0f 90       	pop	r0
    3f20:	cf 91       	pop	r28
    3f22:	df 91       	pop	r29
    3f24:	08 95       	ret

00003f26 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3f26:	af 92       	push	r10
    3f28:	bf 92       	push	r11
    3f2a:	cf 92       	push	r12
    3f2c:	df 92       	push	r13
    3f2e:	ef 92       	push	r14
    3f30:	ff 92       	push	r15
    3f32:	0f 93       	push	r16
    3f34:	1f 93       	push	r17
    3f36:	df 93       	push	r29
    3f38:	cf 93       	push	r28
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	64 97       	sbiw	r28, 0x14	; 20
    3f40:	0f b6       	in	r0, 0x3f	; 63
    3f42:	f8 94       	cli
    3f44:	de bf       	out	0x3e, r29	; 62
    3f46:	0f be       	out	0x3f, r0	; 63
    3f48:	cd bf       	out	0x3d, r28	; 61
    3f4a:	9f 83       	std	Y+7, r25	; 0x07
    3f4c:	8e 83       	std	Y+6, r24	; 0x06
    3f4e:	79 87       	std	Y+9, r23	; 0x09
    3f50:	68 87       	std	Y+8, r22	; 0x08
    3f52:	5b 87       	std	Y+11, r21	; 0x0b
    3f54:	4a 87       	std	Y+10, r20	; 0x0a
    3f56:	3d 87       	std	Y+13, r19	; 0x0d
    3f58:	2c 87       	std	Y+12, r18	; 0x0c
    3f5a:	0e 87       	std	Y+14, r16	; 0x0e
    3f5c:	f8 8a       	std	Y+16, r15	; 0x10
    3f5e:	ef 86       	std	Y+15, r14	; 0x0f
    3f60:	da 8a       	std	Y+18, r13	; 0x12
    3f62:	c9 8a       	std	Y+17, r12	; 0x11
    3f64:	bc 8a       	std	Y+20, r11	; 0x14
    3f66:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3f68:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f6c:	29 89       	ldd	r18, Y+17	; 0x11
    3f6e:	3a 89       	ldd	r19, Y+18	; 0x12
    3f70:	b9 01       	movw	r22, r18
    3f72:	0e 94 18 26 	call	0x4c30	; 0x4c30 <prvAllocateTCBAndStack>
    3f76:	9c 83       	std	Y+4, r25	; 0x04
    3f78:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f7e:	00 97       	sbiw	r24, 0x00	; 0
    3f80:	09 f4       	brne	.+2      	; 0x3f84 <xTaskGenericCreate+0x5e>
    3f82:	99 c0       	rjmp	.+306    	; 0x40b6 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    3f84:	eb 81       	ldd	r30, Y+3	; 0x03
    3f86:	fc 81       	ldd	r31, Y+4	; 0x04
    3f88:	27 89       	ldd	r18, Z+23	; 0x17
    3f8a:	30 8d       	ldd	r19, Z+24	; 0x18
    3f8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f8e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f90:	01 97       	sbiw	r24, 0x01	; 1
    3f92:	82 0f       	add	r24, r18
    3f94:	93 1f       	adc	r25, r19
    3f96:	9a 83       	std	Y+2, r25	; 0x02
    3f98:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    3f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9e:	28 85       	ldd	r18, Y+8	; 0x08
    3fa0:	39 85       	ldd	r19, Y+9	; 0x09
    3fa2:	eb 89       	ldd	r30, Y+19	; 0x13
    3fa4:	fc 89       	ldd	r31, Y+20	; 0x14
    3fa6:	aa 85       	ldd	r26, Y+10	; 0x0a
    3fa8:	bb 85       	ldd	r27, Y+11	; 0x0b
    3faa:	b9 01       	movw	r22, r18
    3fac:	4e 85       	ldd	r20, Y+14	; 0x0e
    3fae:	9f 01       	movw	r18, r30
    3fb0:	8d 01       	movw	r16, r26
    3fb2:	0e 94 fd 24 	call	0x49fa	; 0x49fa <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3fb6:	89 81       	ldd	r24, Y+1	; 0x01
    3fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3fba:	2e 81       	ldd	r18, Y+6	; 0x06
    3fbc:	3f 81       	ldd	r19, Y+7	; 0x07
    3fbe:	4c 85       	ldd	r20, Y+12	; 0x0c
    3fc0:	5d 85       	ldd	r21, Y+13	; 0x0d
    3fc2:	b9 01       	movw	r22, r18
    3fc4:	0e 94 21 18 	call	0x3042	; 0x3042 <pxPortInitialiseStack>
    3fc8:	eb 81       	ldd	r30, Y+3	; 0x03
    3fca:	fc 81       	ldd	r31, Y+4	; 0x04
    3fcc:	91 83       	std	Z+1, r25	; 0x01
    3fce:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    3fd0:	8f 85       	ldd	r24, Y+15	; 0x0f
    3fd2:	98 89       	ldd	r25, Y+16	; 0x10
    3fd4:	00 97       	sbiw	r24, 0x00	; 0
    3fd6:	31 f0       	breq	.+12     	; 0x3fe4 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3fd8:	ef 85       	ldd	r30, Y+15	; 0x0f
    3fda:	f8 89       	ldd	r31, Y+16	; 0x10
    3fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3fde:	9c 81       	ldd	r25, Y+4	; 0x04
    3fe0:	91 83       	std	Z+1, r25	; 0x01
    3fe2:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    3fe4:	0f b6       	in	r0, 0x3f	; 63
    3fe6:	f8 94       	cli
    3fe8:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3fea:	80 91 ab 04 	lds	r24, 0x04AB
    3fee:	8f 5f       	subi	r24, 0xFF	; 255
    3ff0:	80 93 ab 04 	sts	0x04AB, r24
			if( pxCurrentTCB == NULL )
    3ff4:	80 91 a8 04 	lds	r24, 0x04A8
    3ff8:	90 91 a9 04 	lds	r25, 0x04A9
    3ffc:	00 97       	sbiw	r24, 0x00	; 0
    3ffe:	69 f4       	brne	.+26     	; 0x401a <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4000:	8b 81       	ldd	r24, Y+3	; 0x03
    4002:	9c 81       	ldd	r25, Y+4	; 0x04
    4004:	90 93 a9 04 	sts	0x04A9, r25
    4008:	80 93 a8 04 	sts	0x04A8, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    400c:	80 91 ab 04 	lds	r24, 0x04AB
    4010:	81 30       	cpi	r24, 0x01	; 1
    4012:	a9 f4       	brne	.+42     	; 0x403e <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4014:	0e 94 54 25 	call	0x4aa8	; 0x4aa8 <prvInitialiseTaskLists>
    4018:	12 c0       	rjmp	.+36     	; 0x403e <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    401a:	80 91 b0 04 	lds	r24, 0x04B0
    401e:	88 23       	and	r24, r24
    4020:	71 f4       	brne	.+28     	; 0x403e <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4022:	e0 91 a8 04 	lds	r30, 0x04A8
    4026:	f0 91 a9 04 	lds	r31, 0x04A9
    402a:	96 89       	ldd	r25, Z+22	; 0x16
    402c:	8e 85       	ldd	r24, Y+14	; 0x0e
    402e:	89 17       	cp	r24, r25
    4030:	30 f0       	brcs	.+12     	; 0x403e <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4032:	8b 81       	ldd	r24, Y+3	; 0x03
    4034:	9c 81       	ldd	r25, Y+4	; 0x04
    4036:	90 93 a9 04 	sts	0x04A9, r25
    403a:	80 93 a8 04 	sts	0x04A8, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    403e:	eb 81       	ldd	r30, Y+3	; 0x03
    4040:	fc 81       	ldd	r31, Y+4	; 0x04
    4042:	96 89       	ldd	r25, Z+22	; 0x16
    4044:	80 91 ae 04 	lds	r24, 0x04AE
    4048:	89 17       	cp	r24, r25
    404a:	28 f4       	brcc	.+10     	; 0x4056 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    404c:	eb 81       	ldd	r30, Y+3	; 0x03
    404e:	fc 81       	ldd	r31, Y+4	; 0x04
    4050:	86 89       	ldd	r24, Z+22	; 0x16
    4052:	80 93 ae 04 	sts	0x04AE, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    4056:	80 91 b5 04 	lds	r24, 0x04B5
    405a:	8f 5f       	subi	r24, 0xFF	; 255
    405c:	80 93 b5 04 	sts	0x04B5, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4060:	eb 81       	ldd	r30, Y+3	; 0x03
    4062:	fc 81       	ldd	r31, Y+4	; 0x04
    4064:	96 89       	ldd	r25, Z+22	; 0x16
    4066:	80 91 af 04 	lds	r24, 0x04AF
    406a:	89 17       	cp	r24, r25
    406c:	28 f4       	brcc	.+10     	; 0x4078 <xTaskGenericCreate+0x152>
    406e:	eb 81       	ldd	r30, Y+3	; 0x03
    4070:	fc 81       	ldd	r31, Y+4	; 0x04
    4072:	86 89       	ldd	r24, Z+22	; 0x16
    4074:	80 93 af 04 	sts	0x04AF, r24
    4078:	eb 81       	ldd	r30, Y+3	; 0x03
    407a:	fc 81       	ldd	r31, Y+4	; 0x04
    407c:	86 89       	ldd	r24, Z+22	; 0x16
    407e:	28 2f       	mov	r18, r24
    4080:	30 e0       	ldi	r19, 0x00	; 0
    4082:	c9 01       	movw	r24, r18
    4084:	88 0f       	add	r24, r24
    4086:	99 1f       	adc	r25, r25
    4088:	88 0f       	add	r24, r24
    408a:	99 1f       	adc	r25, r25
    408c:	88 0f       	add	r24, r24
    408e:	99 1f       	adc	r25, r25
    4090:	82 0f       	add	r24, r18
    4092:	93 1f       	adc	r25, r19
    4094:	ac 01       	movw	r20, r24
    4096:	4a 54       	subi	r20, 0x4A	; 74
    4098:	5b 4f       	sbci	r21, 0xFB	; 251
    409a:	8b 81       	ldd	r24, Y+3	; 0x03
    409c:	9c 81       	ldd	r25, Y+4	; 0x04
    409e:	9c 01       	movw	r18, r24
    40a0:	2e 5f       	subi	r18, 0xFE	; 254
    40a2:	3f 4f       	sbci	r19, 0xFF	; 255
    40a4:	ca 01       	movw	r24, r20
    40a6:	b9 01       	movw	r22, r18
    40a8:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>

			xReturn = pdPASS;
    40ac:	81 e0       	ldi	r24, 0x01	; 1
    40ae:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    40b0:	0f 90       	pop	r0
    40b2:	0f be       	out	0x3f, r0	; 63
    40b4:	02 c0       	rjmp	.+4      	; 0x40ba <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    40b6:	8f ef       	ldi	r24, 0xFF	; 255
    40b8:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    40ba:	8d 81       	ldd	r24, Y+5	; 0x05
    40bc:	81 30       	cpi	r24, 0x01	; 1
    40be:	71 f4       	brne	.+28     	; 0x40dc <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    40c0:	80 91 b0 04 	lds	r24, 0x04B0
    40c4:	88 23       	and	r24, r24
    40c6:	51 f0       	breq	.+20     	; 0x40dc <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    40c8:	e0 91 a8 04 	lds	r30, 0x04A8
    40cc:	f0 91 a9 04 	lds	r31, 0x04A9
    40d0:	96 89       	ldd	r25, Z+22	; 0x16
    40d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    40d4:	98 17       	cp	r25, r24
    40d6:	10 f4       	brcc	.+4      	; 0x40dc <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    40d8:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
			}
		}
	}

	return xReturn;
    40dc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    40de:	64 96       	adiw	r28, 0x14	; 20
    40e0:	0f b6       	in	r0, 0x3f	; 63
    40e2:	f8 94       	cli
    40e4:	de bf       	out	0x3e, r29	; 62
    40e6:	0f be       	out	0x3f, r0	; 63
    40e8:	cd bf       	out	0x3d, r28	; 61
    40ea:	cf 91       	pop	r28
    40ec:	df 91       	pop	r29
    40ee:	1f 91       	pop	r17
    40f0:	0f 91       	pop	r16
    40f2:	ff 90       	pop	r15
    40f4:	ef 90       	pop	r14
    40f6:	df 90       	pop	r13
    40f8:	cf 90       	pop	r12
    40fa:	bf 90       	pop	r11
    40fc:	af 90       	pop	r10
    40fe:	08 95       	ret

00004100 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4100:	df 93       	push	r29
    4102:	cf 93       	push	r28
    4104:	00 d0       	rcall	.+0      	; 0x4106 <vTaskDelete+0x6>
    4106:	00 d0       	rcall	.+0      	; 0x4108 <vTaskDelete+0x8>
    4108:	00 d0       	rcall	.+0      	; 0x410a <vTaskDelete+0xa>
    410a:	cd b7       	in	r28, 0x3d	; 61
    410c:	de b7       	in	r29, 0x3e	; 62
    410e:	9c 83       	std	Y+4, r25	; 0x04
    4110:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4112:	0f b6       	in	r0, 0x3f	; 63
    4114:	f8 94       	cli
    4116:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4118:	20 91 a8 04 	lds	r18, 0x04A8
    411c:	30 91 a9 04 	lds	r19, 0x04A9
    4120:	8b 81       	ldd	r24, Y+3	; 0x03
    4122:	9c 81       	ldd	r25, Y+4	; 0x04
    4124:	82 17       	cp	r24, r18
    4126:	93 07       	cpc	r25, r19
    4128:	11 f4       	brne	.+4      	; 0x412e <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    412a:	1c 82       	std	Y+4, r1	; 0x04
    412c:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    412e:	8b 81       	ldd	r24, Y+3	; 0x03
    4130:	9c 81       	ldd	r25, Y+4	; 0x04
    4132:	00 97       	sbiw	r24, 0x00	; 0
    4134:	39 f4       	brne	.+14     	; 0x4144 <vTaskDelete+0x44>
    4136:	80 91 a8 04 	lds	r24, 0x04A8
    413a:	90 91 a9 04 	lds	r25, 0x04A9
    413e:	9e 83       	std	Y+6, r25	; 0x06
    4140:	8d 83       	std	Y+5, r24	; 0x05
    4142:	04 c0       	rjmp	.+8      	; 0x414c <vTaskDelete+0x4c>
    4144:	8b 81       	ldd	r24, Y+3	; 0x03
    4146:	9c 81       	ldd	r25, Y+4	; 0x04
    4148:	9e 83       	std	Y+6, r25	; 0x06
    414a:	8d 83       	std	Y+5, r24	; 0x05
    414c:	8d 81       	ldd	r24, Y+5	; 0x05
    414e:	9e 81       	ldd	r25, Y+6	; 0x06
    4150:	9a 83       	std	Y+2, r25	; 0x02
    4152:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4154:	89 81       	ldd	r24, Y+1	; 0x01
    4156:	9a 81       	ldd	r25, Y+2	; 0x02
    4158:	02 96       	adiw	r24, 0x02	; 2
    415a:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    415e:	e9 81       	ldd	r30, Y+1	; 0x01
    4160:	fa 81       	ldd	r31, Y+2	; 0x02
    4162:	84 89       	ldd	r24, Z+20	; 0x14
    4164:	95 89       	ldd	r25, Z+21	; 0x15
    4166:	00 97       	sbiw	r24, 0x00	; 0
    4168:	29 f0       	breq	.+10     	; 0x4174 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    416a:	89 81       	ldd	r24, Y+1	; 0x01
    416c:	9a 81       	ldd	r25, Y+2	; 0x02
    416e:	0c 96       	adiw	r24, 0x0c	; 12
    4170:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4174:	89 81       	ldd	r24, Y+1	; 0x01
    4176:	9a 81       	ldd	r25, Y+2	; 0x02
    4178:	9c 01       	movw	r18, r24
    417a:	2e 5f       	subi	r18, 0xFE	; 254
    417c:	3f 4f       	sbci	r19, 0xFF	; 255
    417e:	82 e0       	ldi	r24, 0x02	; 2
    4180:	95 e0       	ldi	r25, 0x05	; 5
    4182:	b9 01       	movw	r22, r18
    4184:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4188:	80 91 aa 04 	lds	r24, 0x04AA
    418c:	8f 5f       	subi	r24, 0xFF	; 255
    418e:	80 93 aa 04 	sts	0x04AA, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4192:	80 91 b5 04 	lds	r24, 0x04B5
    4196:	8f 5f       	subi	r24, 0xFF	; 255
    4198:	80 93 b5 04 	sts	0x04B5, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    419c:	0f 90       	pop	r0
    419e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    41a0:	80 91 b0 04 	lds	r24, 0x04B0
    41a4:	88 23       	and	r24, r24
    41a6:	31 f0       	breq	.+12     	; 0x41b4 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    41a8:	8b 81       	ldd	r24, Y+3	; 0x03
    41aa:	9c 81       	ldd	r25, Y+4	; 0x04
    41ac:	00 97       	sbiw	r24, 0x00	; 0
    41ae:	11 f4       	brne	.+4      	; 0x41b4 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    41b0:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
			}
		}
	}
    41b4:	26 96       	adiw	r28, 0x06	; 6
    41b6:	0f b6       	in	r0, 0x3f	; 63
    41b8:	f8 94       	cli
    41ba:	de bf       	out	0x3e, r29	; 62
    41bc:	0f be       	out	0x3f, r0	; 63
    41be:	cd bf       	out	0x3d, r28	; 61
    41c0:	cf 91       	pop	r28
    41c2:	df 91       	pop	r29
    41c4:	08 95       	ret

000041c6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    41c6:	df 93       	push	r29
    41c8:	cf 93       	push	r28
    41ca:	cd b7       	in	r28, 0x3d	; 61
    41cc:	de b7       	in	r29, 0x3e	; 62
    41ce:	28 97       	sbiw	r28, 0x08	; 8
    41d0:	0f b6       	in	r0, 0x3f	; 63
    41d2:	f8 94       	cli
    41d4:	de bf       	out	0x3e, r29	; 62
    41d6:	0f be       	out	0x3f, r0	; 63
    41d8:	cd bf       	out	0x3d, r28	; 61
    41da:	9e 83       	std	Y+6, r25	; 0x06
    41dc:	8d 83       	std	Y+5, r24	; 0x05
    41de:	78 87       	std	Y+8, r23	; 0x08
    41e0:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    41e2:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    41e4:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    41e8:	ed 81       	ldd	r30, Y+5	; 0x05
    41ea:	fe 81       	ldd	r31, Y+6	; 0x06
    41ec:	20 81       	ld	r18, Z
    41ee:	31 81       	ldd	r19, Z+1	; 0x01
    41f0:	8f 81       	ldd	r24, Y+7	; 0x07
    41f2:	98 85       	ldd	r25, Y+8	; 0x08
    41f4:	82 0f       	add	r24, r18
    41f6:	93 1f       	adc	r25, r19
    41f8:	9c 83       	std	Y+4, r25	; 0x04
    41fa:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    41fc:	ed 81       	ldd	r30, Y+5	; 0x05
    41fe:	fe 81       	ldd	r31, Y+6	; 0x06
    4200:	20 81       	ld	r18, Z
    4202:	31 81       	ldd	r19, Z+1	; 0x01
    4204:	80 91 ac 04 	lds	r24, 0x04AC
    4208:	90 91 ad 04 	lds	r25, 0x04AD
    420c:	82 17       	cp	r24, r18
    420e:	93 07       	cpc	r25, r19
    4210:	a8 f4       	brcc	.+42     	; 0x423c <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4212:	ed 81       	ldd	r30, Y+5	; 0x05
    4214:	fe 81       	ldd	r31, Y+6	; 0x06
    4216:	20 81       	ld	r18, Z
    4218:	31 81       	ldd	r19, Z+1	; 0x01
    421a:	8b 81       	ldd	r24, Y+3	; 0x03
    421c:	9c 81       	ldd	r25, Y+4	; 0x04
    421e:	82 17       	cp	r24, r18
    4220:	93 07       	cpc	r25, r19
    4222:	00 f5       	brcc	.+64     	; 0x4264 <vTaskDelayUntil+0x9e>
    4224:	20 91 ac 04 	lds	r18, 0x04AC
    4228:	30 91 ad 04 	lds	r19, 0x04AD
    422c:	8b 81       	ldd	r24, Y+3	; 0x03
    422e:	9c 81       	ldd	r25, Y+4	; 0x04
    4230:	28 17       	cp	r18, r24
    4232:	39 07       	cpc	r19, r25
    4234:	b8 f4       	brcc	.+46     	; 0x4264 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4236:	81 e0       	ldi	r24, 0x01	; 1
    4238:	89 83       	std	Y+1, r24	; 0x01
    423a:	14 c0       	rjmp	.+40     	; 0x4264 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    423c:	ed 81       	ldd	r30, Y+5	; 0x05
    423e:	fe 81       	ldd	r31, Y+6	; 0x06
    4240:	20 81       	ld	r18, Z
    4242:	31 81       	ldd	r19, Z+1	; 0x01
    4244:	8b 81       	ldd	r24, Y+3	; 0x03
    4246:	9c 81       	ldd	r25, Y+4	; 0x04
    4248:	82 17       	cp	r24, r18
    424a:	93 07       	cpc	r25, r19
    424c:	48 f0       	brcs	.+18     	; 0x4260 <vTaskDelayUntil+0x9a>
    424e:	20 91 ac 04 	lds	r18, 0x04AC
    4252:	30 91 ad 04 	lds	r19, 0x04AD
    4256:	8b 81       	ldd	r24, Y+3	; 0x03
    4258:	9c 81       	ldd	r25, Y+4	; 0x04
    425a:	28 17       	cp	r18, r24
    425c:	39 07       	cpc	r19, r25
    425e:	10 f4       	brcc	.+4      	; 0x4264 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4260:	81 e0       	ldi	r24, 0x01	; 1
    4262:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4264:	ed 81       	ldd	r30, Y+5	; 0x05
    4266:	fe 81       	ldd	r31, Y+6	; 0x06
    4268:	8b 81       	ldd	r24, Y+3	; 0x03
    426a:	9c 81       	ldd	r25, Y+4	; 0x04
    426c:	91 83       	std	Z+1, r25	; 0x01
    426e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4270:	89 81       	ldd	r24, Y+1	; 0x01
    4272:	88 23       	and	r24, r24
    4274:	59 f0       	breq	.+22     	; 0x428c <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4276:	80 91 a8 04 	lds	r24, 0x04A8
    427a:	90 91 a9 04 	lds	r25, 0x04A9
    427e:	02 96       	adiw	r24, 0x02	; 2
    4280:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4284:	8b 81       	ldd	r24, Y+3	; 0x03
    4286:	9c 81       	ldd	r25, Y+4	; 0x04
    4288:	0e 94 cf 25 	call	0x4b9e	; 0x4b9e <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    428c:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    4290:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4292:	8a 81       	ldd	r24, Y+2	; 0x02
    4294:	88 23       	and	r24, r24
    4296:	11 f4       	brne	.+4      	; 0x429c <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    4298:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
		}
	}
    429c:	28 96       	adiw	r28, 0x08	; 8
    429e:	0f b6       	in	r0, 0x3f	; 63
    42a0:	f8 94       	cli
    42a2:	de bf       	out	0x3e, r29	; 62
    42a4:	0f be       	out	0x3f, r0	; 63
    42a6:	cd bf       	out	0x3d, r28	; 61
    42a8:	cf 91       	pop	r28
    42aa:	df 91       	pop	r29
    42ac:	08 95       	ret

000042ae <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    42ae:	df 93       	push	r29
    42b0:	cf 93       	push	r28
    42b2:	00 d0       	rcall	.+0      	; 0x42b4 <vTaskDelay+0x6>
    42b4:	00 d0       	rcall	.+0      	; 0x42b6 <vTaskDelay+0x8>
    42b6:	0f 92       	push	r0
    42b8:	cd b7       	in	r28, 0x3d	; 61
    42ba:	de b7       	in	r29, 0x3e	; 62
    42bc:	9d 83       	std	Y+5, r25	; 0x05
    42be:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    42c0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    42c2:	8c 81       	ldd	r24, Y+4	; 0x04
    42c4:	9d 81       	ldd	r25, Y+5	; 0x05
    42c6:	00 97       	sbiw	r24, 0x00	; 0
    42c8:	d1 f0       	breq	.+52     	; 0x42fe <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    42ca:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    42ce:	20 91 ac 04 	lds	r18, 0x04AC
    42d2:	30 91 ad 04 	lds	r19, 0x04AD
    42d6:	8c 81       	ldd	r24, Y+4	; 0x04
    42d8:	9d 81       	ldd	r25, Y+5	; 0x05
    42da:	82 0f       	add	r24, r18
    42dc:	93 1f       	adc	r25, r19
    42de:	9b 83       	std	Y+3, r25	; 0x03
    42e0:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    42e2:	80 91 a8 04 	lds	r24, 0x04A8
    42e6:	90 91 a9 04 	lds	r25, 0x04A9
    42ea:	02 96       	adiw	r24, 0x02	; 2
    42ec:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    42f0:	8a 81       	ldd	r24, Y+2	; 0x02
    42f2:	9b 81       	ldd	r25, Y+3	; 0x03
    42f4:	0e 94 cf 25 	call	0x4b9e	; 0x4b9e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    42f8:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    42fc:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    42fe:	89 81       	ldd	r24, Y+1	; 0x01
    4300:	88 23       	and	r24, r24
    4302:	11 f4       	brne	.+4      	; 0x4308 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4304:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
		}
	}
    4308:	0f 90       	pop	r0
    430a:	0f 90       	pop	r0
    430c:	0f 90       	pop	r0
    430e:	0f 90       	pop	r0
    4310:	0f 90       	pop	r0
    4312:	cf 91       	pop	r28
    4314:	df 91       	pop	r29
    4316:	08 95       	ret

00004318 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4318:	af 92       	push	r10
    431a:	bf 92       	push	r11
    431c:	cf 92       	push	r12
    431e:	df 92       	push	r13
    4320:	ef 92       	push	r14
    4322:	ff 92       	push	r15
    4324:	0f 93       	push	r16
    4326:	df 93       	push	r29
    4328:	cf 93       	push	r28
    432a:	0f 92       	push	r0
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4330:	20 e6       	ldi	r18, 0x60	; 96
    4332:	30 e0       	ldi	r19, 0x00	; 0
    4334:	83 ef       	ldi	r24, 0xF3	; 243
    4336:	94 e2       	ldi	r25, 0x24	; 36
    4338:	b9 01       	movw	r22, r18
    433a:	44 e6       	ldi	r20, 0x64	; 100
    433c:	50 e0       	ldi	r21, 0x00	; 0
    433e:	20 e0       	ldi	r18, 0x00	; 0
    4340:	30 e0       	ldi	r19, 0x00	; 0
    4342:	00 e0       	ldi	r16, 0x00	; 0
    4344:	ee 24       	eor	r14, r14
    4346:	ff 24       	eor	r15, r15
    4348:	cc 24       	eor	r12, r12
    434a:	dd 24       	eor	r13, r13
    434c:	aa 24       	eor	r10, r10
    434e:	bb 24       	eor	r11, r11
    4350:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <xTaskGenericCreate>
    4354:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4356:	89 81       	ldd	r24, Y+1	; 0x01
    4358:	81 30       	cpi	r24, 0x01	; 1
    435a:	51 f4       	brne	.+20     	; 0x4370 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    435c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    435e:	81 e0       	ldi	r24, 0x01	; 1
    4360:	80 93 b0 04 	sts	0x04B0, r24
		xTickCount = ( portTickType ) 0U;
    4364:	10 92 ad 04 	sts	0x04AD, r1
    4368:	10 92 ac 04 	sts	0x04AC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    436c:	0e 94 a4 19 	call	0x3348	; 0x3348 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4370:	0f 90       	pop	r0
    4372:	cf 91       	pop	r28
    4374:	df 91       	pop	r29
    4376:	0f 91       	pop	r16
    4378:	ff 90       	pop	r15
    437a:	ef 90       	pop	r14
    437c:	df 90       	pop	r13
    437e:	cf 90       	pop	r12
    4380:	bf 90       	pop	r11
    4382:	af 90       	pop	r10
    4384:	08 95       	ret

00004386 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4386:	df 93       	push	r29
    4388:	cf 93       	push	r28
    438a:	cd b7       	in	r28, 0x3d	; 61
    438c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    438e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4390:	10 92 b0 04 	sts	0x04B0, r1
	vPortEndScheduler();
    4394:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <vPortEndScheduler>
}
    4398:	cf 91       	pop	r28
    439a:	df 91       	pop	r29
    439c:	08 95       	ret

0000439e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    439e:	df 93       	push	r29
    43a0:	cf 93       	push	r28
    43a2:	cd b7       	in	r28, 0x3d	; 61
    43a4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    43a6:	80 91 b1 04 	lds	r24, 0x04B1
    43aa:	8f 5f       	subi	r24, 0xFF	; 255
    43ac:	80 93 b1 04 	sts	0x04B1, r24
}
    43b0:	cf 91       	pop	r28
    43b2:	df 91       	pop	r29
    43b4:	08 95       	ret

000043b6 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	00 d0       	rcall	.+0      	; 0x43bc <xTaskResumeAll+0x6>
    43bc:	00 d0       	rcall	.+0      	; 0x43be <xTaskResumeAll+0x8>
    43be:	cd b7       	in	r28, 0x3d	; 61
    43c0:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    43c2:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    43c4:	0f b6       	in	r0, 0x3f	; 63
    43c6:	f8 94       	cli
    43c8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    43ca:	80 91 b1 04 	lds	r24, 0x04B1
    43ce:	81 50       	subi	r24, 0x01	; 1
    43d0:	80 93 b1 04 	sts	0x04B1, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    43d4:	80 91 b1 04 	lds	r24, 0x04B1
    43d8:	88 23       	and	r24, r24
    43da:	09 f0       	breq	.+2      	; 0x43de <xTaskResumeAll+0x28>
    43dc:	6c c0       	rjmp	.+216    	; 0x44b6 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    43de:	80 91 ab 04 	lds	r24, 0x04AB
    43e2:	88 23       	and	r24, r24
    43e4:	09 f4       	brne	.+2      	; 0x43e8 <xTaskResumeAll+0x32>
    43e6:	67 c0       	rjmp	.+206    	; 0x44b6 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    43e8:	19 82       	std	Y+1, r1	; 0x01
    43ea:	41 c0       	rjmp	.+130    	; 0x446e <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    43ec:	e0 91 fe 04 	lds	r30, 0x04FE
    43f0:	f0 91 ff 04 	lds	r31, 0x04FF
    43f4:	86 81       	ldd	r24, Z+6	; 0x06
    43f6:	97 81       	ldd	r25, Z+7	; 0x07
    43f8:	9c 83       	std	Y+4, r25	; 0x04
    43fa:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    43fc:	8b 81       	ldd	r24, Y+3	; 0x03
    43fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4400:	0c 96       	adiw	r24, 0x0c	; 12
    4402:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4406:	8b 81       	ldd	r24, Y+3	; 0x03
    4408:	9c 81       	ldd	r25, Y+4	; 0x04
    440a:	02 96       	adiw	r24, 0x02	; 2
    440c:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4410:	eb 81       	ldd	r30, Y+3	; 0x03
    4412:	fc 81       	ldd	r31, Y+4	; 0x04
    4414:	96 89       	ldd	r25, Z+22	; 0x16
    4416:	80 91 af 04 	lds	r24, 0x04AF
    441a:	89 17       	cp	r24, r25
    441c:	28 f4       	brcc	.+10     	; 0x4428 <xTaskResumeAll+0x72>
    441e:	eb 81       	ldd	r30, Y+3	; 0x03
    4420:	fc 81       	ldd	r31, Y+4	; 0x04
    4422:	86 89       	ldd	r24, Z+22	; 0x16
    4424:	80 93 af 04 	sts	0x04AF, r24
    4428:	eb 81       	ldd	r30, Y+3	; 0x03
    442a:	fc 81       	ldd	r31, Y+4	; 0x04
    442c:	86 89       	ldd	r24, Z+22	; 0x16
    442e:	28 2f       	mov	r18, r24
    4430:	30 e0       	ldi	r19, 0x00	; 0
    4432:	c9 01       	movw	r24, r18
    4434:	88 0f       	add	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	88 0f       	add	r24, r24
    443a:	99 1f       	adc	r25, r25
    443c:	88 0f       	add	r24, r24
    443e:	99 1f       	adc	r25, r25
    4440:	82 0f       	add	r24, r18
    4442:	93 1f       	adc	r25, r19
    4444:	8a 54       	subi	r24, 0x4A	; 74
    4446:	9b 4f       	sbci	r25, 0xFB	; 251
    4448:	2b 81       	ldd	r18, Y+3	; 0x03
    444a:	3c 81       	ldd	r19, Y+4	; 0x04
    444c:	2e 5f       	subi	r18, 0xFE	; 254
    444e:	3f 4f       	sbci	r19, 0xFF	; 255
    4450:	b9 01       	movw	r22, r18
    4452:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4456:	eb 81       	ldd	r30, Y+3	; 0x03
    4458:	fc 81       	ldd	r31, Y+4	; 0x04
    445a:	96 89       	ldd	r25, Z+22	; 0x16
    445c:	e0 91 a8 04 	lds	r30, 0x04A8
    4460:	f0 91 a9 04 	lds	r31, 0x04A9
    4464:	86 89       	ldd	r24, Z+22	; 0x16
    4466:	98 17       	cp	r25, r24
    4468:	10 f0       	brcs	.+4      	; 0x446e <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    446a:	81 e0       	ldi	r24, 0x01	; 1
    446c:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    446e:	80 91 f9 04 	lds	r24, 0x04F9
    4472:	88 23       	and	r24, r24
    4474:	09 f0       	breq	.+2      	; 0x4478 <xTaskResumeAll+0xc2>
    4476:	ba cf       	rjmp	.-140    	; 0x43ec <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4478:	80 91 b2 04 	lds	r24, 0x04B2
    447c:	88 23       	and	r24, r24
    447e:	71 f0       	breq	.+28     	; 0x449c <xTaskResumeAll+0xe6>
    4480:	07 c0       	rjmp	.+14     	; 0x4490 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4482:	0e 94 9a 22 	call	0x4534	; 0x4534 <vTaskIncrementTick>
						--uxMissedTicks;
    4486:	80 91 b2 04 	lds	r24, 0x04B2
    448a:	81 50       	subi	r24, 0x01	; 1
    448c:	80 93 b2 04 	sts	0x04B2, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4490:	80 91 b2 04 	lds	r24, 0x04B2
    4494:	88 23       	and	r24, r24
    4496:	a9 f7       	brne	.-22     	; 0x4482 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4498:	81 e0       	ldi	r24, 0x01	; 1
    449a:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    449c:	89 81       	ldd	r24, Y+1	; 0x01
    449e:	81 30       	cpi	r24, 0x01	; 1
    44a0:	21 f0       	breq	.+8      	; 0x44aa <xTaskResumeAll+0xf4>
    44a2:	80 91 b3 04 	lds	r24, 0x04B3
    44a6:	81 30       	cpi	r24, 0x01	; 1
    44a8:	31 f4       	brne	.+12     	; 0x44b6 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    44aa:	81 e0       	ldi	r24, 0x01	; 1
    44ac:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    44ae:	10 92 b3 04 	sts	0x04B3, r1
					portYIELD_WITHIN_API();
    44b2:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    44b6:	0f 90       	pop	r0
    44b8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    44ba:	8a 81       	ldd	r24, Y+2	; 0x02
}
    44bc:	0f 90       	pop	r0
    44be:	0f 90       	pop	r0
    44c0:	0f 90       	pop	r0
    44c2:	0f 90       	pop	r0
    44c4:	cf 91       	pop	r28
    44c6:	df 91       	pop	r29
    44c8:	08 95       	ret

000044ca <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    44ca:	df 93       	push	r29
    44cc:	cf 93       	push	r28
    44ce:	00 d0       	rcall	.+0      	; 0x44d0 <xTaskGetTickCount+0x6>
    44d0:	cd b7       	in	r28, 0x3d	; 61
    44d2:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    44d4:	0f b6       	in	r0, 0x3f	; 63
    44d6:	f8 94       	cli
    44d8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    44da:	80 91 ac 04 	lds	r24, 0x04AC
    44de:	90 91 ad 04 	lds	r25, 0x04AD
    44e2:	9a 83       	std	Y+2, r25	; 0x02
    44e4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    44e6:	0f 90       	pop	r0
    44e8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    44ea:	89 81       	ldd	r24, Y+1	; 0x01
    44ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    44ee:	0f 90       	pop	r0
    44f0:	0f 90       	pop	r0
    44f2:	cf 91       	pop	r28
    44f4:	df 91       	pop	r29
    44f6:	08 95       	ret

000044f8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    44f8:	df 93       	push	r29
    44fa:	cf 93       	push	r28
    44fc:	00 d0       	rcall	.+0      	; 0x44fe <xTaskGetTickCountFromISR+0x6>
    44fe:	0f 92       	push	r0
    4500:	cd b7       	in	r28, 0x3d	; 61
    4502:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4504:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4506:	80 91 ac 04 	lds	r24, 0x04AC
    450a:	90 91 ad 04 	lds	r25, 0x04AD
    450e:	9b 83       	std	Y+3, r25	; 0x03
    4510:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4512:	8a 81       	ldd	r24, Y+2	; 0x02
    4514:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4516:	0f 90       	pop	r0
    4518:	0f 90       	pop	r0
    451a:	0f 90       	pop	r0
    451c:	cf 91       	pop	r28
    451e:	df 91       	pop	r29
    4520:	08 95       	ret

00004522 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4522:	df 93       	push	r29
    4524:	cf 93       	push	r28
    4526:	cd b7       	in	r28, 0x3d	; 61
    4528:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    452a:	80 91 ab 04 	lds	r24, 0x04AB
}
    452e:	cf 91       	pop	r28
    4530:	df 91       	pop	r29
    4532:	08 95       	ret

00004534 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4534:	df 93       	push	r29
    4536:	cf 93       	push	r28
    4538:	00 d0       	rcall	.+0      	; 0x453a <vTaskIncrementTick+0x6>
    453a:	00 d0       	rcall	.+0      	; 0x453c <vTaskIncrementTick+0x8>
    453c:	00 d0       	rcall	.+0      	; 0x453e <vTaskIncrementTick+0xa>
    453e:	cd b7       	in	r28, 0x3d	; 61
    4540:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4542:	80 91 b1 04 	lds	r24, 0x04B1
    4546:	88 23       	and	r24, r24
    4548:	09 f0       	breq	.+2      	; 0x454c <vTaskIncrementTick+0x18>
    454a:	bb c0       	rjmp	.+374    	; 0x46c2 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    454c:	80 91 ac 04 	lds	r24, 0x04AC
    4550:	90 91 ad 04 	lds	r25, 0x04AD
    4554:	01 96       	adiw	r24, 0x01	; 1
    4556:	90 93 ad 04 	sts	0x04AD, r25
    455a:	80 93 ac 04 	sts	0x04AC, r24
		if( xTickCount == ( portTickType ) 0U )
    455e:	80 91 ac 04 	lds	r24, 0x04AC
    4562:	90 91 ad 04 	lds	r25, 0x04AD
    4566:	00 97       	sbiw	r24, 0x00	; 0
    4568:	d1 f5       	brne	.+116    	; 0x45de <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    456a:	80 91 f5 04 	lds	r24, 0x04F5
    456e:	90 91 f6 04 	lds	r25, 0x04F6
    4572:	9c 83       	std	Y+4, r25	; 0x04
    4574:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4576:	80 91 f7 04 	lds	r24, 0x04F7
    457a:	90 91 f8 04 	lds	r25, 0x04F8
    457e:	90 93 f6 04 	sts	0x04F6, r25
    4582:	80 93 f5 04 	sts	0x04F5, r24
			pxOverflowDelayedTaskList = pxTemp;
    4586:	8b 81       	ldd	r24, Y+3	; 0x03
    4588:	9c 81       	ldd	r25, Y+4	; 0x04
    458a:	90 93 f8 04 	sts	0x04F8, r25
    458e:	80 93 f7 04 	sts	0x04F7, r24
			xNumOfOverflows++;
    4592:	80 91 b4 04 	lds	r24, 0x04B4
    4596:	8f 5f       	subi	r24, 0xFF	; 255
    4598:	80 93 b4 04 	sts	0x04B4, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    459c:	e0 91 f5 04 	lds	r30, 0x04F5
    45a0:	f0 91 f6 04 	lds	r31, 0x04F6
    45a4:	80 81       	ld	r24, Z
    45a6:	88 23       	and	r24, r24
    45a8:	39 f4       	brne	.+14     	; 0x45b8 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    45aa:	8f ef       	ldi	r24, 0xFF	; 255
    45ac:	9f ef       	ldi	r25, 0xFF	; 255
    45ae:	90 93 82 00 	sts	0x0082, r25
    45b2:	80 93 81 00 	sts	0x0081, r24
    45b6:	13 c0       	rjmp	.+38     	; 0x45de <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    45b8:	e0 91 f5 04 	lds	r30, 0x04F5
    45bc:	f0 91 f6 04 	lds	r31, 0x04F6
    45c0:	05 80       	ldd	r0, Z+5	; 0x05
    45c2:	f6 81       	ldd	r31, Z+6	; 0x06
    45c4:	e0 2d       	mov	r30, r0
    45c6:	86 81       	ldd	r24, Z+6	; 0x06
    45c8:	97 81       	ldd	r25, Z+7	; 0x07
    45ca:	9e 83       	std	Y+6, r25	; 0x06
    45cc:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    45ce:	ed 81       	ldd	r30, Y+5	; 0x05
    45d0:	fe 81       	ldd	r31, Y+6	; 0x06
    45d2:	82 81       	ldd	r24, Z+2	; 0x02
    45d4:	93 81       	ldd	r25, Z+3	; 0x03
    45d6:	90 93 82 00 	sts	0x0082, r25
    45da:	80 93 81 00 	sts	0x0081, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    45de:	20 91 ac 04 	lds	r18, 0x04AC
    45e2:	30 91 ad 04 	lds	r19, 0x04AD
    45e6:	80 91 81 00 	lds	r24, 0x0081
    45ea:	90 91 82 00 	lds	r25, 0x0082
    45ee:	28 17       	cp	r18, r24
    45f0:	39 07       	cpc	r19, r25
    45f2:	08 f4       	brcc	.+2      	; 0x45f6 <vTaskIncrementTick+0xc2>
    45f4:	6b c0       	rjmp	.+214    	; 0x46cc <vTaskIncrementTick+0x198>
    45f6:	e0 91 f5 04 	lds	r30, 0x04F5
    45fa:	f0 91 f6 04 	lds	r31, 0x04F6
    45fe:	80 81       	ld	r24, Z
    4600:	88 23       	and	r24, r24
    4602:	39 f4       	brne	.+14     	; 0x4612 <vTaskIncrementTick+0xde>
    4604:	8f ef       	ldi	r24, 0xFF	; 255
    4606:	9f ef       	ldi	r25, 0xFF	; 255
    4608:	90 93 82 00 	sts	0x0082, r25
    460c:	80 93 81 00 	sts	0x0081, r24
    4610:	5d c0       	rjmp	.+186    	; 0x46cc <vTaskIncrementTick+0x198>
    4612:	e0 91 f5 04 	lds	r30, 0x04F5
    4616:	f0 91 f6 04 	lds	r31, 0x04F6
    461a:	05 80       	ldd	r0, Z+5	; 0x05
    461c:	f6 81       	ldd	r31, Z+6	; 0x06
    461e:	e0 2d       	mov	r30, r0
    4620:	86 81       	ldd	r24, Z+6	; 0x06
    4622:	97 81       	ldd	r25, Z+7	; 0x07
    4624:	9e 83       	std	Y+6, r25	; 0x06
    4626:	8d 83       	std	Y+5, r24	; 0x05
    4628:	ed 81       	ldd	r30, Y+5	; 0x05
    462a:	fe 81       	ldd	r31, Y+6	; 0x06
    462c:	82 81       	ldd	r24, Z+2	; 0x02
    462e:	93 81       	ldd	r25, Z+3	; 0x03
    4630:	9a 83       	std	Y+2, r25	; 0x02
    4632:	89 83       	std	Y+1, r24	; 0x01
    4634:	20 91 ac 04 	lds	r18, 0x04AC
    4638:	30 91 ad 04 	lds	r19, 0x04AD
    463c:	89 81       	ldd	r24, Y+1	; 0x01
    463e:	9a 81       	ldd	r25, Y+2	; 0x02
    4640:	28 17       	cp	r18, r24
    4642:	39 07       	cpc	r19, r25
    4644:	38 f4       	brcc	.+14     	; 0x4654 <vTaskIncrementTick+0x120>
    4646:	89 81       	ldd	r24, Y+1	; 0x01
    4648:	9a 81       	ldd	r25, Y+2	; 0x02
    464a:	90 93 82 00 	sts	0x0082, r25
    464e:	80 93 81 00 	sts	0x0081, r24
    4652:	3c c0       	rjmp	.+120    	; 0x46cc <vTaskIncrementTick+0x198>
    4654:	8d 81       	ldd	r24, Y+5	; 0x05
    4656:	9e 81       	ldd	r25, Y+6	; 0x06
    4658:	02 96       	adiw	r24, 0x02	; 2
    465a:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
    465e:	ed 81       	ldd	r30, Y+5	; 0x05
    4660:	fe 81       	ldd	r31, Y+6	; 0x06
    4662:	84 89       	ldd	r24, Z+20	; 0x14
    4664:	95 89       	ldd	r25, Z+21	; 0x15
    4666:	00 97       	sbiw	r24, 0x00	; 0
    4668:	29 f0       	breq	.+10     	; 0x4674 <vTaskIncrementTick+0x140>
    466a:	8d 81       	ldd	r24, Y+5	; 0x05
    466c:	9e 81       	ldd	r25, Y+6	; 0x06
    466e:	0c 96       	adiw	r24, 0x0c	; 12
    4670:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
    4674:	ed 81       	ldd	r30, Y+5	; 0x05
    4676:	fe 81       	ldd	r31, Y+6	; 0x06
    4678:	96 89       	ldd	r25, Z+22	; 0x16
    467a:	80 91 af 04 	lds	r24, 0x04AF
    467e:	89 17       	cp	r24, r25
    4680:	28 f4       	brcc	.+10     	; 0x468c <vTaskIncrementTick+0x158>
    4682:	ed 81       	ldd	r30, Y+5	; 0x05
    4684:	fe 81       	ldd	r31, Y+6	; 0x06
    4686:	86 89       	ldd	r24, Z+22	; 0x16
    4688:	80 93 af 04 	sts	0x04AF, r24
    468c:	ed 81       	ldd	r30, Y+5	; 0x05
    468e:	fe 81       	ldd	r31, Y+6	; 0x06
    4690:	86 89       	ldd	r24, Z+22	; 0x16
    4692:	28 2f       	mov	r18, r24
    4694:	30 e0       	ldi	r19, 0x00	; 0
    4696:	c9 01       	movw	r24, r18
    4698:	88 0f       	add	r24, r24
    469a:	99 1f       	adc	r25, r25
    469c:	88 0f       	add	r24, r24
    469e:	99 1f       	adc	r25, r25
    46a0:	88 0f       	add	r24, r24
    46a2:	99 1f       	adc	r25, r25
    46a4:	82 0f       	add	r24, r18
    46a6:	93 1f       	adc	r25, r19
    46a8:	ac 01       	movw	r20, r24
    46aa:	4a 54       	subi	r20, 0x4A	; 74
    46ac:	5b 4f       	sbci	r21, 0xFB	; 251
    46ae:	8d 81       	ldd	r24, Y+5	; 0x05
    46b0:	9e 81       	ldd	r25, Y+6	; 0x06
    46b2:	9c 01       	movw	r18, r24
    46b4:	2e 5f       	subi	r18, 0xFE	; 254
    46b6:	3f 4f       	sbci	r19, 0xFF	; 255
    46b8:	ca 01       	movw	r24, r20
    46ba:	b9 01       	movw	r22, r18
    46bc:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>
    46c0:	9a cf       	rjmp	.-204    	; 0x45f6 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    46c2:	80 91 b2 04 	lds	r24, 0x04B2
    46c6:	8f 5f       	subi	r24, 0xFF	; 255
    46c8:	80 93 b2 04 	sts	0x04B2, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    46cc:	26 96       	adiw	r28, 0x06	; 6
    46ce:	0f b6       	in	r0, 0x3f	; 63
    46d0:	f8 94       	cli
    46d2:	de bf       	out	0x3e, r29	; 62
    46d4:	0f be       	out	0x3f, r0	; 63
    46d6:	cd bf       	out	0x3d, r28	; 61
    46d8:	cf 91       	pop	r28
    46da:	df 91       	pop	r29
    46dc:	08 95       	ret

000046de <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    46de:	df 93       	push	r29
    46e0:	cf 93       	push	r28
    46e2:	00 d0       	rcall	.+0      	; 0x46e4 <vTaskSwitchContext+0x6>
    46e4:	cd b7       	in	r28, 0x3d	; 61
    46e6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    46e8:	80 91 b1 04 	lds	r24, 0x04B1
    46ec:	88 23       	and	r24, r24
    46ee:	49 f0       	breq	.+18     	; 0x4702 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    46f0:	81 e0       	ldi	r24, 0x01	; 1
    46f2:	80 93 b3 04 	sts	0x04B3, r24
    46f6:	54 c0       	rjmp	.+168    	; 0x47a0 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    46f8:	80 91 af 04 	lds	r24, 0x04AF
    46fc:	81 50       	subi	r24, 0x01	; 1
    46fe:	80 93 af 04 	sts	0x04AF, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4702:	80 91 af 04 	lds	r24, 0x04AF
    4706:	28 2f       	mov	r18, r24
    4708:	30 e0       	ldi	r19, 0x00	; 0
    470a:	c9 01       	movw	r24, r18
    470c:	88 0f       	add	r24, r24
    470e:	99 1f       	adc	r25, r25
    4710:	88 0f       	add	r24, r24
    4712:	99 1f       	adc	r25, r25
    4714:	88 0f       	add	r24, r24
    4716:	99 1f       	adc	r25, r25
    4718:	82 0f       	add	r24, r18
    471a:	93 1f       	adc	r25, r19
    471c:	fc 01       	movw	r30, r24
    471e:	ea 54       	subi	r30, 0x4A	; 74
    4720:	fb 4f       	sbci	r31, 0xFB	; 251
    4722:	80 81       	ld	r24, Z
    4724:	88 23       	and	r24, r24
    4726:	41 f3       	breq	.-48     	; 0x46f8 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4728:	80 91 af 04 	lds	r24, 0x04AF
    472c:	28 2f       	mov	r18, r24
    472e:	30 e0       	ldi	r19, 0x00	; 0
    4730:	c9 01       	movw	r24, r18
    4732:	88 0f       	add	r24, r24
    4734:	99 1f       	adc	r25, r25
    4736:	88 0f       	add	r24, r24
    4738:	99 1f       	adc	r25, r25
    473a:	88 0f       	add	r24, r24
    473c:	99 1f       	adc	r25, r25
    473e:	82 0f       	add	r24, r18
    4740:	93 1f       	adc	r25, r19
    4742:	8a 54       	subi	r24, 0x4A	; 74
    4744:	9b 4f       	sbci	r25, 0xFB	; 251
    4746:	9a 83       	std	Y+2, r25	; 0x02
    4748:	89 83       	std	Y+1, r24	; 0x01
    474a:	e9 81       	ldd	r30, Y+1	; 0x01
    474c:	fa 81       	ldd	r31, Y+2	; 0x02
    474e:	01 80       	ldd	r0, Z+1	; 0x01
    4750:	f2 81       	ldd	r31, Z+2	; 0x02
    4752:	e0 2d       	mov	r30, r0
    4754:	82 81       	ldd	r24, Z+2	; 0x02
    4756:	93 81       	ldd	r25, Z+3	; 0x03
    4758:	e9 81       	ldd	r30, Y+1	; 0x01
    475a:	fa 81       	ldd	r31, Y+2	; 0x02
    475c:	92 83       	std	Z+2, r25	; 0x02
    475e:	81 83       	std	Z+1, r24	; 0x01
    4760:	e9 81       	ldd	r30, Y+1	; 0x01
    4762:	fa 81       	ldd	r31, Y+2	; 0x02
    4764:	21 81       	ldd	r18, Z+1	; 0x01
    4766:	32 81       	ldd	r19, Z+2	; 0x02
    4768:	89 81       	ldd	r24, Y+1	; 0x01
    476a:	9a 81       	ldd	r25, Y+2	; 0x02
    476c:	03 96       	adiw	r24, 0x03	; 3
    476e:	28 17       	cp	r18, r24
    4770:	39 07       	cpc	r19, r25
    4772:	59 f4       	brne	.+22     	; 0x478a <vTaskSwitchContext+0xac>
    4774:	e9 81       	ldd	r30, Y+1	; 0x01
    4776:	fa 81       	ldd	r31, Y+2	; 0x02
    4778:	01 80       	ldd	r0, Z+1	; 0x01
    477a:	f2 81       	ldd	r31, Z+2	; 0x02
    477c:	e0 2d       	mov	r30, r0
    477e:	82 81       	ldd	r24, Z+2	; 0x02
    4780:	93 81       	ldd	r25, Z+3	; 0x03
    4782:	e9 81       	ldd	r30, Y+1	; 0x01
    4784:	fa 81       	ldd	r31, Y+2	; 0x02
    4786:	92 83       	std	Z+2, r25	; 0x02
    4788:	81 83       	std	Z+1, r24	; 0x01
    478a:	e9 81       	ldd	r30, Y+1	; 0x01
    478c:	fa 81       	ldd	r31, Y+2	; 0x02
    478e:	01 80       	ldd	r0, Z+1	; 0x01
    4790:	f2 81       	ldd	r31, Z+2	; 0x02
    4792:	e0 2d       	mov	r30, r0
    4794:	86 81       	ldd	r24, Z+6	; 0x06
    4796:	97 81       	ldd	r25, Z+7	; 0x07
    4798:	90 93 a9 04 	sts	0x04A9, r25
    479c:	80 93 a8 04 	sts	0x04A8, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    47a0:	0f 90       	pop	r0
    47a2:	0f 90       	pop	r0
    47a4:	cf 91       	pop	r28
    47a6:	df 91       	pop	r29
    47a8:	08 95       	ret

000047aa <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    47aa:	df 93       	push	r29
    47ac:	cf 93       	push	r28
    47ae:	00 d0       	rcall	.+0      	; 0x47b0 <vTaskPlaceOnEventList+0x6>
    47b0:	00 d0       	rcall	.+0      	; 0x47b2 <vTaskPlaceOnEventList+0x8>
    47b2:	00 d0       	rcall	.+0      	; 0x47b4 <vTaskPlaceOnEventList+0xa>
    47b4:	cd b7       	in	r28, 0x3d	; 61
    47b6:	de b7       	in	r29, 0x3e	; 62
    47b8:	9c 83       	std	Y+4, r25	; 0x04
    47ba:	8b 83       	std	Y+3, r24	; 0x03
    47bc:	7e 83       	std	Y+6, r23	; 0x06
    47be:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    47c0:	4b 81       	ldd	r20, Y+3	; 0x03
    47c2:	5c 81       	ldd	r21, Y+4	; 0x04
    47c4:	80 91 a8 04 	lds	r24, 0x04A8
    47c8:	90 91 a9 04 	lds	r25, 0x04A9
    47cc:	9c 01       	movw	r18, r24
    47ce:	24 5f       	subi	r18, 0xF4	; 244
    47d0:	3f 4f       	sbci	r19, 0xFF	; 255
    47d2:	ca 01       	movw	r24, r20
    47d4:	b9 01       	movw	r22, r18
    47d6:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    47da:	80 91 a8 04 	lds	r24, 0x04A8
    47de:	90 91 a9 04 	lds	r25, 0x04A9
    47e2:	02 96       	adiw	r24, 0x02	; 2
    47e4:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    47e8:	20 91 ac 04 	lds	r18, 0x04AC
    47ec:	30 91 ad 04 	lds	r19, 0x04AD
    47f0:	8d 81       	ldd	r24, Y+5	; 0x05
    47f2:	9e 81       	ldd	r25, Y+6	; 0x06
    47f4:	82 0f       	add	r24, r18
    47f6:	93 1f       	adc	r25, r19
    47f8:	9a 83       	std	Y+2, r25	; 0x02
    47fa:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    47fc:	89 81       	ldd	r24, Y+1	; 0x01
    47fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4800:	0e 94 cf 25 	call	0x4b9e	; 0x4b9e <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4804:	26 96       	adiw	r28, 0x06	; 6
    4806:	0f b6       	in	r0, 0x3f	; 63
    4808:	f8 94       	cli
    480a:	de bf       	out	0x3e, r29	; 62
    480c:	0f be       	out	0x3f, r0	; 63
    480e:	cd bf       	out	0x3d, r28	; 61
    4810:	cf 91       	pop	r28
    4812:	df 91       	pop	r29
    4814:	08 95       	ret

00004816 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4816:	df 93       	push	r29
    4818:	cf 93       	push	r28
    481a:	00 d0       	rcall	.+0      	; 0x481c <xTaskRemoveFromEventList+0x6>
    481c:	00 d0       	rcall	.+0      	; 0x481e <xTaskRemoveFromEventList+0x8>
    481e:	0f 92       	push	r0
    4820:	cd b7       	in	r28, 0x3d	; 61
    4822:	de b7       	in	r29, 0x3e	; 62
    4824:	9d 83       	std	Y+5, r25	; 0x05
    4826:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4828:	ec 81       	ldd	r30, Y+4	; 0x04
    482a:	fd 81       	ldd	r31, Y+5	; 0x05
    482c:	05 80       	ldd	r0, Z+5	; 0x05
    482e:	f6 81       	ldd	r31, Z+6	; 0x06
    4830:	e0 2d       	mov	r30, r0
    4832:	86 81       	ldd	r24, Z+6	; 0x06
    4834:	97 81       	ldd	r25, Z+7	; 0x07
    4836:	9b 83       	std	Y+3, r25	; 0x03
    4838:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    483a:	8a 81       	ldd	r24, Y+2	; 0x02
    483c:	9b 81       	ldd	r25, Y+3	; 0x03
    483e:	0c 96       	adiw	r24, 0x0c	; 12
    4840:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4844:	80 91 b1 04 	lds	r24, 0x04B1
    4848:	88 23       	and	r24, r24
    484a:	61 f5       	brne	.+88     	; 0x48a4 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    484c:	8a 81       	ldd	r24, Y+2	; 0x02
    484e:	9b 81       	ldd	r25, Y+3	; 0x03
    4850:	02 96       	adiw	r24, 0x02	; 2
    4852:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4856:	ea 81       	ldd	r30, Y+2	; 0x02
    4858:	fb 81       	ldd	r31, Y+3	; 0x03
    485a:	96 89       	ldd	r25, Z+22	; 0x16
    485c:	80 91 af 04 	lds	r24, 0x04AF
    4860:	89 17       	cp	r24, r25
    4862:	28 f4       	brcc	.+10     	; 0x486e <xTaskRemoveFromEventList+0x58>
    4864:	ea 81       	ldd	r30, Y+2	; 0x02
    4866:	fb 81       	ldd	r31, Y+3	; 0x03
    4868:	86 89       	ldd	r24, Z+22	; 0x16
    486a:	80 93 af 04 	sts	0x04AF, r24
    486e:	ea 81       	ldd	r30, Y+2	; 0x02
    4870:	fb 81       	ldd	r31, Y+3	; 0x03
    4872:	86 89       	ldd	r24, Z+22	; 0x16
    4874:	28 2f       	mov	r18, r24
    4876:	30 e0       	ldi	r19, 0x00	; 0
    4878:	c9 01       	movw	r24, r18
    487a:	88 0f       	add	r24, r24
    487c:	99 1f       	adc	r25, r25
    487e:	88 0f       	add	r24, r24
    4880:	99 1f       	adc	r25, r25
    4882:	88 0f       	add	r24, r24
    4884:	99 1f       	adc	r25, r25
    4886:	82 0f       	add	r24, r18
    4888:	93 1f       	adc	r25, r19
    488a:	ac 01       	movw	r20, r24
    488c:	4a 54       	subi	r20, 0x4A	; 74
    488e:	5b 4f       	sbci	r21, 0xFB	; 251
    4890:	8a 81       	ldd	r24, Y+2	; 0x02
    4892:	9b 81       	ldd	r25, Y+3	; 0x03
    4894:	9c 01       	movw	r18, r24
    4896:	2e 5f       	subi	r18, 0xFE	; 254
    4898:	3f 4f       	sbci	r19, 0xFF	; 255
    489a:	ca 01       	movw	r24, r20
    489c:	b9 01       	movw	r22, r18
    489e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>
    48a2:	0a c0       	rjmp	.+20     	; 0x48b8 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    48a4:	8a 81       	ldd	r24, Y+2	; 0x02
    48a6:	9b 81       	ldd	r25, Y+3	; 0x03
    48a8:	9c 01       	movw	r18, r24
    48aa:	24 5f       	subi	r18, 0xF4	; 244
    48ac:	3f 4f       	sbci	r19, 0xFF	; 255
    48ae:	89 ef       	ldi	r24, 0xF9	; 249
    48b0:	94 e0       	ldi	r25, 0x04	; 4
    48b2:	b9 01       	movw	r22, r18
    48b4:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    48b8:	ea 81       	ldd	r30, Y+2	; 0x02
    48ba:	fb 81       	ldd	r31, Y+3	; 0x03
    48bc:	96 89       	ldd	r25, Z+22	; 0x16
    48be:	e0 91 a8 04 	lds	r30, 0x04A8
    48c2:	f0 91 a9 04 	lds	r31, 0x04A9
    48c6:	86 89       	ldd	r24, Z+22	; 0x16
    48c8:	98 17       	cp	r25, r24
    48ca:	18 f0       	brcs	.+6      	; 0x48d2 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    48cc:	81 e0       	ldi	r24, 0x01	; 1
    48ce:	89 83       	std	Y+1, r24	; 0x01
    48d0:	01 c0       	rjmp	.+2      	; 0x48d4 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    48d2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    48d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    48d6:	0f 90       	pop	r0
    48d8:	0f 90       	pop	r0
    48da:	0f 90       	pop	r0
    48dc:	0f 90       	pop	r0
    48de:	0f 90       	pop	r0
    48e0:	cf 91       	pop	r28
    48e2:	df 91       	pop	r29
    48e4:	08 95       	ret

000048e6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    48e6:	df 93       	push	r29
    48e8:	cf 93       	push	r28
    48ea:	00 d0       	rcall	.+0      	; 0x48ec <vTaskSetTimeOutState+0x6>
    48ec:	cd b7       	in	r28, 0x3d	; 61
    48ee:	de b7       	in	r29, 0x3e	; 62
    48f0:	9a 83       	std	Y+2, r25	; 0x02
    48f2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    48f4:	80 91 b4 04 	lds	r24, 0x04B4
    48f8:	e9 81       	ldd	r30, Y+1	; 0x01
    48fa:	fa 81       	ldd	r31, Y+2	; 0x02
    48fc:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    48fe:	80 91 ac 04 	lds	r24, 0x04AC
    4902:	90 91 ad 04 	lds	r25, 0x04AD
    4906:	e9 81       	ldd	r30, Y+1	; 0x01
    4908:	fa 81       	ldd	r31, Y+2	; 0x02
    490a:	92 83       	std	Z+2, r25	; 0x02
    490c:	81 83       	std	Z+1, r24	; 0x01
}
    490e:	0f 90       	pop	r0
    4910:	0f 90       	pop	r0
    4912:	cf 91       	pop	r28
    4914:	df 91       	pop	r29
    4916:	08 95       	ret

00004918 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4918:	df 93       	push	r29
    491a:	cf 93       	push	r28
    491c:	00 d0       	rcall	.+0      	; 0x491e <xTaskCheckForTimeOut+0x6>
    491e:	00 d0       	rcall	.+0      	; 0x4920 <xTaskCheckForTimeOut+0x8>
    4920:	0f 92       	push	r0
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
    4926:	9b 83       	std	Y+3, r25	; 0x03
    4928:	8a 83       	std	Y+2, r24	; 0x02
    492a:	7d 83       	std	Y+5, r23	; 0x05
    492c:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    492e:	0f b6       	in	r0, 0x3f	; 63
    4930:	f8 94       	cli
    4932:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4934:	ea 81       	ldd	r30, Y+2	; 0x02
    4936:	fb 81       	ldd	r31, Y+3	; 0x03
    4938:	90 81       	ld	r25, Z
    493a:	80 91 b4 04 	lds	r24, 0x04B4
    493e:	98 17       	cp	r25, r24
    4940:	71 f0       	breq	.+28     	; 0x495e <xTaskCheckForTimeOut+0x46>
    4942:	ea 81       	ldd	r30, Y+2	; 0x02
    4944:	fb 81       	ldd	r31, Y+3	; 0x03
    4946:	21 81       	ldd	r18, Z+1	; 0x01
    4948:	32 81       	ldd	r19, Z+2	; 0x02
    494a:	80 91 ac 04 	lds	r24, 0x04AC
    494e:	90 91 ad 04 	lds	r25, 0x04AD
    4952:	82 17       	cp	r24, r18
    4954:	93 07       	cpc	r25, r19
    4956:	18 f0       	brcs	.+6      	; 0x495e <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4958:	81 e0       	ldi	r24, 0x01	; 1
    495a:	89 83       	std	Y+1, r24	; 0x01
    495c:	2f c0       	rjmp	.+94     	; 0x49bc <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    495e:	20 91 ac 04 	lds	r18, 0x04AC
    4962:	30 91 ad 04 	lds	r19, 0x04AD
    4966:	ea 81       	ldd	r30, Y+2	; 0x02
    4968:	fb 81       	ldd	r31, Y+3	; 0x03
    496a:	81 81       	ldd	r24, Z+1	; 0x01
    496c:	92 81       	ldd	r25, Z+2	; 0x02
    496e:	28 1b       	sub	r18, r24
    4970:	39 0b       	sbc	r19, r25
    4972:	ec 81       	ldd	r30, Y+4	; 0x04
    4974:	fd 81       	ldd	r31, Y+5	; 0x05
    4976:	80 81       	ld	r24, Z
    4978:	91 81       	ldd	r25, Z+1	; 0x01
    497a:	28 17       	cp	r18, r24
    497c:	39 07       	cpc	r19, r25
    497e:	e0 f4       	brcc	.+56     	; 0x49b8 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4980:	ec 81       	ldd	r30, Y+4	; 0x04
    4982:	fd 81       	ldd	r31, Y+5	; 0x05
    4984:	40 81       	ld	r20, Z
    4986:	51 81       	ldd	r21, Z+1	; 0x01
    4988:	ea 81       	ldd	r30, Y+2	; 0x02
    498a:	fb 81       	ldd	r31, Y+3	; 0x03
    498c:	21 81       	ldd	r18, Z+1	; 0x01
    498e:	32 81       	ldd	r19, Z+2	; 0x02
    4990:	80 91 ac 04 	lds	r24, 0x04AC
    4994:	90 91 ad 04 	lds	r25, 0x04AD
    4998:	b9 01       	movw	r22, r18
    499a:	68 1b       	sub	r22, r24
    499c:	79 0b       	sbc	r23, r25
    499e:	cb 01       	movw	r24, r22
    49a0:	84 0f       	add	r24, r20
    49a2:	95 1f       	adc	r25, r21
    49a4:	ec 81       	ldd	r30, Y+4	; 0x04
    49a6:	fd 81       	ldd	r31, Y+5	; 0x05
    49a8:	91 83       	std	Z+1, r25	; 0x01
    49aa:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    49ac:	8a 81       	ldd	r24, Y+2	; 0x02
    49ae:	9b 81       	ldd	r25, Y+3	; 0x03
    49b0:	0e 94 73 24 	call	0x48e6	; 0x48e6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    49b4:	19 82       	std	Y+1, r1	; 0x01
    49b6:	02 c0       	rjmp	.+4      	; 0x49bc <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    49bc:	0f 90       	pop	r0
    49be:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    49c0:	89 81       	ldd	r24, Y+1	; 0x01
}
    49c2:	0f 90       	pop	r0
    49c4:	0f 90       	pop	r0
    49c6:	0f 90       	pop	r0
    49c8:	0f 90       	pop	r0
    49ca:	0f 90       	pop	r0
    49cc:	cf 91       	pop	r28
    49ce:	df 91       	pop	r29
    49d0:	08 95       	ret

000049d2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    49d2:	df 93       	push	r29
    49d4:	cf 93       	push	r28
    49d6:	cd b7       	in	r28, 0x3d	; 61
    49d8:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    49da:	81 e0       	ldi	r24, 0x01	; 1
    49dc:	80 93 b3 04 	sts	0x04B3, r24
}
    49e0:	cf 91       	pop	r28
    49e2:	df 91       	pop	r29
    49e4:	08 95       	ret

000049e6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    49e6:	df 93       	push	r29
    49e8:	cf 93       	push	r28
    49ea:	00 d0       	rcall	.+0      	; 0x49ec <prvIdleTask+0x6>
    49ec:	cd b7       	in	r28, 0x3d	; 61
    49ee:	de b7       	in	r29, 0x3e	; 62
    49f0:	9a 83       	std	Y+2, r25	; 0x02
    49f2:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    49f4:	0e 94 91 25 	call	0x4b22	; 0x4b22 <prvCheckTasksWaitingTermination>
    49f8:	fd cf       	rjmp	.-6      	; 0x49f4 <prvIdleTask+0xe>

000049fa <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    49fa:	0f 93       	push	r16
    49fc:	1f 93       	push	r17
    49fe:	df 93       	push	r29
    4a00:	cf 93       	push	r28
    4a02:	cd b7       	in	r28, 0x3d	; 61
    4a04:	de b7       	in	r29, 0x3e	; 62
    4a06:	29 97       	sbiw	r28, 0x09	; 9
    4a08:	0f b6       	in	r0, 0x3f	; 63
    4a0a:	f8 94       	cli
    4a0c:	de bf       	out	0x3e, r29	; 62
    4a0e:	0f be       	out	0x3f, r0	; 63
    4a10:	cd bf       	out	0x3d, r28	; 61
    4a12:	9a 83       	std	Y+2, r25	; 0x02
    4a14:	89 83       	std	Y+1, r24	; 0x01
    4a16:	7c 83       	std	Y+4, r23	; 0x04
    4a18:	6b 83       	std	Y+3, r22	; 0x03
    4a1a:	4d 83       	std	Y+5, r20	; 0x05
    4a1c:	3f 83       	std	Y+7, r19	; 0x07
    4a1e:	2e 83       	std	Y+6, r18	; 0x06
    4a20:	19 87       	std	Y+9, r17	; 0x09
    4a22:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4a24:	89 81       	ldd	r24, Y+1	; 0x01
    4a26:	9a 81       	ldd	r25, Y+2	; 0x02
    4a28:	49 96       	adiw	r24, 0x19	; 25
    4a2a:	2b 81       	ldd	r18, Y+3	; 0x03
    4a2c:	3c 81       	ldd	r19, Y+4	; 0x04
    4a2e:	b9 01       	movw	r22, r18
    4a30:	48 e0       	ldi	r20, 0x08	; 8
    4a32:	50 e0       	ldi	r21, 0x00	; 0
    4a34:	0e 94 4c 28 	call	0x5098	; 0x5098 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4a38:	e9 81       	ldd	r30, Y+1	; 0x01
    4a3a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a3c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4a3e:	8d 81       	ldd	r24, Y+5	; 0x05
    4a40:	85 30       	cpi	r24, 0x05	; 5
    4a42:	10 f0       	brcs	.+4      	; 0x4a48 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4a44:	84 e0       	ldi	r24, 0x04	; 4
    4a46:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4a48:	e9 81       	ldd	r30, Y+1	; 0x01
    4a4a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a4c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a4e:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4a50:	89 81       	ldd	r24, Y+1	; 0x01
    4a52:	9a 81       	ldd	r25, Y+2	; 0x02
    4a54:	02 96       	adiw	r24, 0x02	; 2
    4a56:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4a5a:	89 81       	ldd	r24, Y+1	; 0x01
    4a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a5e:	0c 96       	adiw	r24, 0x0c	; 12
    4a60:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4a64:	e9 81       	ldd	r30, Y+1	; 0x01
    4a66:	fa 81       	ldd	r31, Y+2	; 0x02
    4a68:	89 81       	ldd	r24, Y+1	; 0x01
    4a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a6c:	91 87       	std	Z+9, r25	; 0x09
    4a6e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4a70:	8d 81       	ldd	r24, Y+5	; 0x05
    4a72:	28 2f       	mov	r18, r24
    4a74:	30 e0       	ldi	r19, 0x00	; 0
    4a76:	85 e0       	ldi	r24, 0x05	; 5
    4a78:	90 e0       	ldi	r25, 0x00	; 0
    4a7a:	82 1b       	sub	r24, r18
    4a7c:	93 0b       	sbc	r25, r19
    4a7e:	e9 81       	ldd	r30, Y+1	; 0x01
    4a80:	fa 81       	ldd	r31, Y+2	; 0x02
    4a82:	95 87       	std	Z+13, r25	; 0x0d
    4a84:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4a86:	e9 81       	ldd	r30, Y+1	; 0x01
    4a88:	fa 81       	ldd	r31, Y+2	; 0x02
    4a8a:	89 81       	ldd	r24, Y+1	; 0x01
    4a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a8e:	93 8b       	std	Z+19, r25	; 0x13
    4a90:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4a92:	29 96       	adiw	r28, 0x09	; 9
    4a94:	0f b6       	in	r0, 0x3f	; 63
    4a96:	f8 94       	cli
    4a98:	de bf       	out	0x3e, r29	; 62
    4a9a:	0f be       	out	0x3f, r0	; 63
    4a9c:	cd bf       	out	0x3d, r28	; 61
    4a9e:	cf 91       	pop	r28
    4aa0:	df 91       	pop	r29
    4aa2:	1f 91       	pop	r17
    4aa4:	0f 91       	pop	r16
    4aa6:	08 95       	ret

00004aa8 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4aa8:	df 93       	push	r29
    4aaa:	cf 93       	push	r28
    4aac:	0f 92       	push	r0
    4aae:	cd b7       	in	r28, 0x3d	; 61
    4ab0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4ab2:	19 82       	std	Y+1, r1	; 0x01
    4ab4:	13 c0       	rjmp	.+38     	; 0x4adc <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4ab6:	89 81       	ldd	r24, Y+1	; 0x01
    4ab8:	28 2f       	mov	r18, r24
    4aba:	30 e0       	ldi	r19, 0x00	; 0
    4abc:	c9 01       	movw	r24, r18
    4abe:	88 0f       	add	r24, r24
    4ac0:	99 1f       	adc	r25, r25
    4ac2:	88 0f       	add	r24, r24
    4ac4:	99 1f       	adc	r25, r25
    4ac6:	88 0f       	add	r24, r24
    4ac8:	99 1f       	adc	r25, r25
    4aca:	82 0f       	add	r24, r18
    4acc:	93 1f       	adc	r25, r19
    4ace:	8a 54       	subi	r24, 0x4A	; 74
    4ad0:	9b 4f       	sbci	r25, 0xFB	; 251
    4ad2:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4ad6:	89 81       	ldd	r24, Y+1	; 0x01
    4ad8:	8f 5f       	subi	r24, 0xFF	; 255
    4ada:	89 83       	std	Y+1, r24	; 0x01
    4adc:	89 81       	ldd	r24, Y+1	; 0x01
    4ade:	85 30       	cpi	r24, 0x05	; 5
    4ae0:	50 f3       	brcs	.-44     	; 0x4ab6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4ae2:	83 ee       	ldi	r24, 0xE3	; 227
    4ae4:	94 e0       	ldi	r25, 0x04	; 4
    4ae6:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4aea:	8c ee       	ldi	r24, 0xEC	; 236
    4aec:	94 e0       	ldi	r25, 0x04	; 4
    4aee:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4af2:	89 ef       	ldi	r24, 0xF9	; 249
    4af4:	94 e0       	ldi	r25, 0x04	; 4
    4af6:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4afa:	82 e0       	ldi	r24, 0x02	; 2
    4afc:	95 e0       	ldi	r25, 0x05	; 5
    4afe:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4b02:	83 ee       	ldi	r24, 0xE3	; 227
    4b04:	94 e0       	ldi	r25, 0x04	; 4
    4b06:	90 93 f6 04 	sts	0x04F6, r25
    4b0a:	80 93 f5 04 	sts	0x04F5, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4b0e:	8c ee       	ldi	r24, 0xEC	; 236
    4b10:	94 e0       	ldi	r25, 0x04	; 4
    4b12:	90 93 f8 04 	sts	0x04F8, r25
    4b16:	80 93 f7 04 	sts	0x04F7, r24
}
    4b1a:	0f 90       	pop	r0
    4b1c:	cf 91       	pop	r28
    4b1e:	df 91       	pop	r29
    4b20:	08 95       	ret

00004b22 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4b22:	df 93       	push	r29
    4b24:	cf 93       	push	r28
    4b26:	00 d0       	rcall	.+0      	; 0x4b28 <prvCheckTasksWaitingTermination+0x6>
    4b28:	0f 92       	push	r0
    4b2a:	cd b7       	in	r28, 0x3d	; 61
    4b2c:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4b2e:	80 91 aa 04 	lds	r24, 0x04AA
    4b32:	88 23       	and	r24, r24
    4b34:	71 f1       	breq	.+92     	; 0x4b92 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4b36:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4b3a:	80 91 02 05 	lds	r24, 0x0502
    4b3e:	1b 82       	std	Y+3, r1	; 0x03
    4b40:	88 23       	and	r24, r24
    4b42:	11 f4       	brne	.+4      	; 0x4b48 <prvCheckTasksWaitingTermination+0x26>
    4b44:	81 e0       	ldi	r24, 0x01	; 1
    4b46:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4b48:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b4e:	88 23       	and	r24, r24
    4b50:	01 f5       	brne	.+64     	; 0x4b92 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4b52:	0f b6       	in	r0, 0x3f	; 63
    4b54:	f8 94       	cli
    4b56:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4b58:	e0 91 07 05 	lds	r30, 0x0507
    4b5c:	f0 91 08 05 	lds	r31, 0x0508
    4b60:	86 81       	ldd	r24, Z+6	; 0x06
    4b62:	97 81       	ldd	r25, Z+7	; 0x07
    4b64:	9a 83       	std	Y+2, r25	; 0x02
    4b66:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4b68:	89 81       	ldd	r24, Y+1	; 0x01
    4b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b6c:	02 96       	adiw	r24, 0x02	; 2
    4b6e:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <vListRemove>
					--uxCurrentNumberOfTasks;
    4b72:	80 91 ab 04 	lds	r24, 0x04AB
    4b76:	81 50       	subi	r24, 0x01	; 1
    4b78:	80 93 ab 04 	sts	0x04AB, r24
					--uxTasksDeleted;
    4b7c:	80 91 aa 04 	lds	r24, 0x04AA
    4b80:	81 50       	subi	r24, 0x01	; 1
    4b82:	80 93 aa 04 	sts	0x04AA, r24
				}
				taskEXIT_CRITICAL();
    4b86:	0f 90       	pop	r0
    4b88:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4b8a:	89 81       	ldd	r24, Y+1	; 0x01
    4b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b8e:	0e 94 68 26 	call	0x4cd0	; 0x4cd0 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4b92:	0f 90       	pop	r0
    4b94:	0f 90       	pop	r0
    4b96:	0f 90       	pop	r0
    4b98:	cf 91       	pop	r28
    4b9a:	df 91       	pop	r29
    4b9c:	08 95       	ret

00004b9e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4b9e:	df 93       	push	r29
    4ba0:	cf 93       	push	r28
    4ba2:	00 d0       	rcall	.+0      	; 0x4ba4 <prvAddCurrentTaskToDelayedList+0x6>
    4ba4:	cd b7       	in	r28, 0x3d	; 61
    4ba6:	de b7       	in	r29, 0x3e	; 62
    4ba8:	9a 83       	std	Y+2, r25	; 0x02
    4baa:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4bac:	e0 91 a8 04 	lds	r30, 0x04A8
    4bb0:	f0 91 a9 04 	lds	r31, 0x04A9
    4bb4:	89 81       	ldd	r24, Y+1	; 0x01
    4bb6:	9a 81       	ldd	r25, Y+2	; 0x02
    4bb8:	93 83       	std	Z+3, r25	; 0x03
    4bba:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4bbc:	20 91 ac 04 	lds	r18, 0x04AC
    4bc0:	30 91 ad 04 	lds	r19, 0x04AD
    4bc4:	89 81       	ldd	r24, Y+1	; 0x01
    4bc6:	9a 81       	ldd	r25, Y+2	; 0x02
    4bc8:	82 17       	cp	r24, r18
    4bca:	93 07       	cpc	r25, r19
    4bcc:	70 f4       	brcc	.+28     	; 0x4bea <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4bce:	80 91 f7 04 	lds	r24, 0x04F7
    4bd2:	90 91 f8 04 	lds	r25, 0x04F8
    4bd6:	20 91 a8 04 	lds	r18, 0x04A8
    4bda:	30 91 a9 04 	lds	r19, 0x04A9
    4bde:	2e 5f       	subi	r18, 0xFE	; 254
    4be0:	3f 4f       	sbci	r19, 0xFF	; 255
    4be2:	b9 01       	movw	r22, r18
    4be4:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vListInsert>
    4be8:	1e c0       	rjmp	.+60     	; 0x4c26 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4bea:	40 91 f5 04 	lds	r20, 0x04F5
    4bee:	50 91 f6 04 	lds	r21, 0x04F6
    4bf2:	80 91 a8 04 	lds	r24, 0x04A8
    4bf6:	90 91 a9 04 	lds	r25, 0x04A9
    4bfa:	9c 01       	movw	r18, r24
    4bfc:	2e 5f       	subi	r18, 0xFE	; 254
    4bfe:	3f 4f       	sbci	r19, 0xFF	; 255
    4c00:	ca 01       	movw	r24, r20
    4c02:	b9 01       	movw	r22, r18
    4c04:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4c08:	20 91 81 00 	lds	r18, 0x0081
    4c0c:	30 91 82 00 	lds	r19, 0x0082
    4c10:	89 81       	ldd	r24, Y+1	; 0x01
    4c12:	9a 81       	ldd	r25, Y+2	; 0x02
    4c14:	82 17       	cp	r24, r18
    4c16:	93 07       	cpc	r25, r19
    4c18:	30 f4       	brcc	.+12     	; 0x4c26 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4c1a:	89 81       	ldd	r24, Y+1	; 0x01
    4c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c1e:	90 93 82 00 	sts	0x0082, r25
    4c22:	80 93 81 00 	sts	0x0081, r24
		}
	}
}
    4c26:	0f 90       	pop	r0
    4c28:	0f 90       	pop	r0
    4c2a:	cf 91       	pop	r28
    4c2c:	df 91       	pop	r29
    4c2e:	08 95       	ret

00004c30 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4c30:	df 93       	push	r29
    4c32:	cf 93       	push	r28
    4c34:	cd b7       	in	r28, 0x3d	; 61
    4c36:	de b7       	in	r29, 0x3e	; 62
    4c38:	28 97       	sbiw	r28, 0x08	; 8
    4c3a:	0f b6       	in	r0, 0x3f	; 63
    4c3c:	f8 94       	cli
    4c3e:	de bf       	out	0x3e, r29	; 62
    4c40:	0f be       	out	0x3f, r0	; 63
    4c42:	cd bf       	out	0x3d, r28	; 61
    4c44:	9c 83       	std	Y+4, r25	; 0x04
    4c46:	8b 83       	std	Y+3, r24	; 0x03
    4c48:	7e 83       	std	Y+6, r23	; 0x06
    4c4a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4c4c:	81 e2       	ldi	r24, 0x21	; 33
    4c4e:	90 e0       	ldi	r25, 0x00	; 0
    4c50:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <pvPortMalloc>
    4c54:	9a 83       	std	Y+2, r25	; 0x02
    4c56:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    4c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c5c:	00 97       	sbiw	r24, 0x00	; 0
    4c5e:	69 f1       	breq	.+90     	; 0x4cba <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4c60:	8d 81       	ldd	r24, Y+5	; 0x05
    4c62:	9e 81       	ldd	r25, Y+6	; 0x06
    4c64:	00 97       	sbiw	r24, 0x00	; 0
    4c66:	39 f4       	brne	.+14     	; 0x4c76 <prvAllocateTCBAndStack+0x46>
    4c68:	8b 81       	ldd	r24, Y+3	; 0x03
    4c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c6c:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <pvPortMalloc>
    4c70:	98 87       	std	Y+8, r25	; 0x08
    4c72:	8f 83       	std	Y+7, r24	; 0x07
    4c74:	04 c0       	rjmp	.+8      	; 0x4c7e <prvAllocateTCBAndStack+0x4e>
    4c76:	8d 81       	ldd	r24, Y+5	; 0x05
    4c78:	9e 81       	ldd	r25, Y+6	; 0x06
    4c7a:	98 87       	std	Y+8, r25	; 0x08
    4c7c:	8f 83       	std	Y+7, r24	; 0x07
    4c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c80:	fa 81       	ldd	r31, Y+2	; 0x02
    4c82:	8f 81       	ldd	r24, Y+7	; 0x07
    4c84:	98 85       	ldd	r25, Y+8	; 0x08
    4c86:	90 8f       	std	Z+24, r25	; 0x18
    4c88:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    4c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    4c8e:	87 89       	ldd	r24, Z+23	; 0x17
    4c90:	90 8d       	ldd	r25, Z+24	; 0x18
    4c92:	00 97       	sbiw	r24, 0x00	; 0
    4c94:	39 f4       	brne	.+14     	; 0x4ca4 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4c96:	89 81       	ldd	r24, Y+1	; 0x01
    4c98:	9a 81       	ldd	r25, Y+2	; 0x02
    4c9a:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <vPortFree>
			pxNewTCB = NULL;
    4c9e:	1a 82       	std	Y+2, r1	; 0x02
    4ca0:	19 82       	std	Y+1, r1	; 0x01
    4ca2:	0b c0       	rjmp	.+22     	; 0x4cba <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ca8:	87 89       	ldd	r24, Z+23	; 0x17
    4caa:	90 8d       	ldd	r25, Z+24	; 0x18
    4cac:	2b 81       	ldd	r18, Y+3	; 0x03
    4cae:	3c 81       	ldd	r19, Y+4	; 0x04
    4cb0:	65 ea       	ldi	r22, 0xA5	; 165
    4cb2:	70 e0       	ldi	r23, 0x00	; 0
    4cb4:	a9 01       	movw	r20, r18
    4cb6:	0e 94 45 28 	call	0x508a	; 0x508a <memset>
		}
	}

	return pxNewTCB;
    4cba:	89 81       	ldd	r24, Y+1	; 0x01
    4cbc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4cbe:	28 96       	adiw	r28, 0x08	; 8
    4cc0:	0f b6       	in	r0, 0x3f	; 63
    4cc2:	f8 94       	cli
    4cc4:	de bf       	out	0x3e, r29	; 62
    4cc6:	0f be       	out	0x3f, r0	; 63
    4cc8:	cd bf       	out	0x3d, r28	; 61
    4cca:	cf 91       	pop	r28
    4ccc:	df 91       	pop	r29
    4cce:	08 95       	ret

00004cd0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4cd0:	df 93       	push	r29
    4cd2:	cf 93       	push	r28
    4cd4:	00 d0       	rcall	.+0      	; 0x4cd6 <prvDeleteTCB+0x6>
    4cd6:	cd b7       	in	r28, 0x3d	; 61
    4cd8:	de b7       	in	r29, 0x3e	; 62
    4cda:	9a 83       	std	Y+2, r25	; 0x02
    4cdc:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4cde:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ce2:	87 89       	ldd	r24, Z+23	; 0x17
    4ce4:	90 8d       	ldd	r25, Z+24	; 0x18
    4ce6:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <vPortFree>
		vPortFree( pxTCB );
    4cea:	89 81       	ldd	r24, Y+1	; 0x01
    4cec:	9a 81       	ldd	r25, Y+2	; 0x02
    4cee:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <vPortFree>
	}
    4cf2:	0f 90       	pop	r0
    4cf4:	0f 90       	pop	r0
    4cf6:	cf 91       	pop	r28
    4cf8:	df 91       	pop	r29
    4cfa:	08 95       	ret

00004cfc <main>:
void APP_LCD_Display(void*pv);
void APP_ADC_Task(void*pv);
u32 ADC_Value=0;
xSemaphoreHandle ADCSem;
int main(void)
{
    4cfc:	af 92       	push	r10
    4cfe:	bf 92       	push	r11
    4d00:	cf 92       	push	r12
    4d02:	df 92       	push	r13
    4d04:	ef 92       	push	r14
    4d06:	ff 92       	push	r15
    4d08:	0f 93       	push	r16
    4d0a:	df 93       	push	r29
    4d0c:	cf 93       	push	r28
    4d0e:	cd b7       	in	r28, 0x3d	; 61
    4d10:	de b7       	in	r29, 0x3e	; 62
    4d12:	2e 97       	sbiw	r28, 0x0e	; 14
    4d14:	0f b6       	in	r0, 0x3f	; 63
    4d16:	f8 94       	cli
    4d18:	de bf       	out	0x3e, r29	; 62
    4d1a:	0f be       	out	0x3f, r0	; 63
    4d1c:	cd bf       	out	0x3d, r28	; 61
	HCLCD_Vid4Bits_Init();
    4d1e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <HCLCD_Vid4Bits_Init>
	HCLCD_VidWriteString_4Bits("Welcome...");
    4d22:	85 e6       	ldi	r24, 0x65	; 101
    4d24:	90 e0       	ldi	r25, 0x00	; 0
    4d26:	0e 94 c3 12 	call	0x2586	; 0x2586 <HCLCD_VidWriteString_4Bits>
    4d2a:	80 e0       	ldi	r24, 0x00	; 0
    4d2c:	90 e0       	ldi	r25, 0x00	; 0
    4d2e:	aa e7       	ldi	r26, 0x7A	; 122
    4d30:	b4 e4       	ldi	r27, 0x44	; 68
    4d32:	8b 87       	std	Y+11, r24	; 0x0b
    4d34:	9c 87       	std	Y+12, r25	; 0x0c
    4d36:	ad 87       	std	Y+13, r26	; 0x0d
    4d38:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4d3a:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d3c:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d40:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d42:	20 e0       	ldi	r18, 0x00	; 0
    4d44:	30 e0       	ldi	r19, 0x00	; 0
    4d46:	4a e7       	ldi	r20, 0x7A	; 122
    4d48:	53 e4       	ldi	r21, 0x43	; 67
    4d4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d4e:	dc 01       	movw	r26, r24
    4d50:	cb 01       	movw	r24, r22
    4d52:	8f 83       	std	Y+7, r24	; 0x07
    4d54:	98 87       	std	Y+8, r25	; 0x08
    4d56:	a9 87       	std	Y+9, r26	; 0x09
    4d58:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4d5a:	6f 81       	ldd	r22, Y+7	; 0x07
    4d5c:	78 85       	ldd	r23, Y+8	; 0x08
    4d5e:	89 85       	ldd	r24, Y+9	; 0x09
    4d60:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d62:	20 e0       	ldi	r18, 0x00	; 0
    4d64:	30 e0       	ldi	r19, 0x00	; 0
    4d66:	40 e8       	ldi	r20, 0x80	; 128
    4d68:	5f e3       	ldi	r21, 0x3F	; 63
    4d6a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4d6e:	88 23       	and	r24, r24
    4d70:	2c f4       	brge	.+10     	; 0x4d7c <main+0x80>
		__ticks = 1;
    4d72:	81 e0       	ldi	r24, 0x01	; 1
    4d74:	90 e0       	ldi	r25, 0x00	; 0
    4d76:	9e 83       	std	Y+6, r25	; 0x06
    4d78:	8d 83       	std	Y+5, r24	; 0x05
    4d7a:	3f c0       	rjmp	.+126    	; 0x4dfa <main+0xfe>
	else if (__tmp > 65535)
    4d7c:	6f 81       	ldd	r22, Y+7	; 0x07
    4d7e:	78 85       	ldd	r23, Y+8	; 0x08
    4d80:	89 85       	ldd	r24, Y+9	; 0x09
    4d82:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d84:	20 e0       	ldi	r18, 0x00	; 0
    4d86:	3f ef       	ldi	r19, 0xFF	; 255
    4d88:	4f e7       	ldi	r20, 0x7F	; 127
    4d8a:	57 e4       	ldi	r21, 0x47	; 71
    4d8c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4d90:	18 16       	cp	r1, r24
    4d92:	4c f5       	brge	.+82     	; 0x4de6 <main+0xea>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d94:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d96:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d98:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d9a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d9c:	20 e0       	ldi	r18, 0x00	; 0
    4d9e:	30 e0       	ldi	r19, 0x00	; 0
    4da0:	40 e2       	ldi	r20, 0x20	; 32
    4da2:	51 e4       	ldi	r21, 0x41	; 65
    4da4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4da8:	dc 01       	movw	r26, r24
    4daa:	cb 01       	movw	r24, r22
    4dac:	bc 01       	movw	r22, r24
    4dae:	cd 01       	movw	r24, r26
    4db0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4db4:	dc 01       	movw	r26, r24
    4db6:	cb 01       	movw	r24, r22
    4db8:	9e 83       	std	Y+6, r25	; 0x06
    4dba:	8d 83       	std	Y+5, r24	; 0x05
    4dbc:	0f c0       	rjmp	.+30     	; 0x4ddc <main+0xe0>
    4dbe:	89 e1       	ldi	r24, 0x19	; 25
    4dc0:	90 e0       	ldi	r25, 0x00	; 0
    4dc2:	9c 83       	std	Y+4, r25	; 0x04
    4dc4:	8b 83       	std	Y+3, r24	; 0x03
    4dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    4dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dca:	01 97       	sbiw	r24, 0x01	; 1
    4dcc:	f1 f7       	brne	.-4      	; 0x4dca <main+0xce>
    4dce:	9c 83       	std	Y+4, r25	; 0x04
    4dd0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4dd2:	8d 81       	ldd	r24, Y+5	; 0x05
    4dd4:	9e 81       	ldd	r25, Y+6	; 0x06
    4dd6:	01 97       	sbiw	r24, 0x01	; 1
    4dd8:	9e 83       	std	Y+6, r25	; 0x06
    4dda:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ddc:	8d 81       	ldd	r24, Y+5	; 0x05
    4dde:	9e 81       	ldd	r25, Y+6	; 0x06
    4de0:	00 97       	sbiw	r24, 0x00	; 0
    4de2:	69 f7       	brne	.-38     	; 0x4dbe <main+0xc2>
    4de4:	14 c0       	rjmp	.+40     	; 0x4e0e <main+0x112>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4de6:	6f 81       	ldd	r22, Y+7	; 0x07
    4de8:	78 85       	ldd	r23, Y+8	; 0x08
    4dea:	89 85       	ldd	r24, Y+9	; 0x09
    4dec:	9a 85       	ldd	r25, Y+10	; 0x0a
    4dee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4df2:	dc 01       	movw	r26, r24
    4df4:	cb 01       	movw	r24, r22
    4df6:	9e 83       	std	Y+6, r25	; 0x06
    4df8:	8d 83       	std	Y+5, r24	; 0x05
    4dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    4dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    4dfe:	9a 83       	std	Y+2, r25	; 0x02
    4e00:	89 83       	std	Y+1, r24	; 0x01
    4e02:	89 81       	ldd	r24, Y+1	; 0x01
    4e04:	9a 81       	ldd	r25, Y+2	; 0x02
    4e06:	01 97       	sbiw	r24, 0x01	; 1
    4e08:	f1 f7       	brne	.-4      	; 0x4e06 <main+0x10a>
    4e0a:	9a 83       	std	Y+2, r25	; 0x02
    4e0c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
	HCLCD_VidWriteCommand_4Bits(0x01>>4);
    4e0e:	80 e0       	ldi	r24, 0x00	; 0
    4e10:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(0x01);
    4e14:	81 e0       	ldi	r24, 0x01	; 1
    4e16:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <HCLCD_VidWriteCommand_4Bits>

	ADCSem=xSemaphoreCreateCounting(1,0);
    4e1a:	81 e0       	ldi	r24, 0x01	; 1
    4e1c:	60 e0       	ldi	r22, 0x00	; 0
    4e1e:	0e 94 9c 1b 	call	0x3738	; 0x3738 <xQueueCreateCountingSemaphore>
    4e22:	90 93 12 05 	sts	0x0512, r25
    4e26:	80 93 11 05 	sts	0x0511, r24

	xTaskCreate(APP_ADC_Task,NULL,100,NULL,0,NULL);
    4e2a:	84 e7       	ldi	r24, 0x74	; 116
    4e2c:	97 e2       	ldi	r25, 0x27	; 39
    4e2e:	60 e0       	ldi	r22, 0x00	; 0
    4e30:	70 e0       	ldi	r23, 0x00	; 0
    4e32:	44 e6       	ldi	r20, 0x64	; 100
    4e34:	50 e0       	ldi	r21, 0x00	; 0
    4e36:	20 e0       	ldi	r18, 0x00	; 0
    4e38:	30 e0       	ldi	r19, 0x00	; 0
    4e3a:	00 e0       	ldi	r16, 0x00	; 0
    4e3c:	ee 24       	eor	r14, r14
    4e3e:	ff 24       	eor	r15, r15
    4e40:	cc 24       	eor	r12, r12
    4e42:	dd 24       	eor	r13, r13
    4e44:	aa 24       	eor	r10, r10
    4e46:	bb 24       	eor	r11, r11
    4e48:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <xTaskGenericCreate>
	xTaskCreate(APP_LCD_Display,NULL,250,NULL,1,NULL);
    4e4c:	8c e4       	ldi	r24, 0x4C	; 76
    4e4e:	97 e2       	ldi	r25, 0x27	; 39
    4e50:	60 e0       	ldi	r22, 0x00	; 0
    4e52:	70 e0       	ldi	r23, 0x00	; 0
    4e54:	4a ef       	ldi	r20, 0xFA	; 250
    4e56:	50 e0       	ldi	r21, 0x00	; 0
    4e58:	20 e0       	ldi	r18, 0x00	; 0
    4e5a:	30 e0       	ldi	r19, 0x00	; 0
    4e5c:	01 e0       	ldi	r16, 0x01	; 1
    4e5e:	ee 24       	eor	r14, r14
    4e60:	ff 24       	eor	r15, r15
    4e62:	cc 24       	eor	r12, r12
    4e64:	dd 24       	eor	r13, r13
    4e66:	aa 24       	eor	r10, r10
    4e68:	bb 24       	eor	r11, r11
    4e6a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <xTaskGenericCreate>

	vTaskStartScheduler();
    4e6e:	0e 94 8c 21 	call	0x4318	; 0x4318 <vTaskStartScheduler>
    4e72:	ff cf       	rjmp	.-2      	; 0x4e72 <main+0x176>

00004e74 <ADC_SetNotification>:

	}
	return 0;
}
void ADC_SetNotification(void)
{
    4e74:	df 93       	push	r29
    4e76:	cf 93       	push	r28
    4e78:	cd b7       	in	r28, 0x3d	; 61
    4e7a:	de b7       	in	r29, 0x3e	; 62
	xSemaphoreGive(ADCSem);
    4e7c:	80 91 11 05 	lds	r24, 0x0511
    4e80:	90 91 12 05 	lds	r25, 0x0512
    4e84:	60 e0       	ldi	r22, 0x00	; 0
    4e86:	70 e0       	ldi	r23, 0x00	; 0
    4e88:	40 e0       	ldi	r20, 0x00	; 0
    4e8a:	50 e0       	ldi	r21, 0x00	; 0
    4e8c:	20 e0       	ldi	r18, 0x00	; 0
    4e8e:	0e 94 bb 1b 	call	0x3776	; 0x3776 <xQueueGenericSend>
}
    4e92:	cf 91       	pop	r28
    4e94:	df 91       	pop	r29
    4e96:	08 95       	ret

00004e98 <APP_LCD_Display>:
void APP_LCD_Display(void*pv)
{
    4e98:	df 93       	push	r29
    4e9a:	cf 93       	push	r28
    4e9c:	00 d0       	rcall	.+0      	; 0x4e9e <APP_LCD_Display+0x6>
    4e9e:	cd b7       	in	r28, 0x3d	; 61
    4ea0:	de b7       	in	r29, 0x3e	; 62
    4ea2:	9a 83       	std	Y+2, r25	; 0x02
    4ea4:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteString_4Bits("POT=");
    4ea6:	80 e7       	ldi	r24, 0x70	; 112
    4ea8:	90 e0       	ldi	r25, 0x00	; 0
    4eaa:	0e 94 c3 12 	call	0x2586	; 0x2586 <HCLCD_VidWriteString_4Bits>
	HCLCD_VidSetPosition_4BitsMode(1,10);
    4eae:	81 e0       	ldi	r24, 0x01	; 1
    4eb0:	6a e0       	ldi	r22, 0x0A	; 10
    4eb2:	0e 94 63 13 	call	0x26c6	; 0x26c6 <HCLCD_VidSetPosition_4BitsMode>
	HCLCD_VidWriteString_4Bits("Ohm");
    4eb6:	85 e7       	ldi	r24, 0x75	; 117
    4eb8:	90 e0       	ldi	r25, 0x00	; 0
    4eba:	0e 94 c3 12 	call	0x2586	; 0x2586 <HCLCD_VidWriteString_4Bits>
	while(1)
	{
		HCLCD_VidSetPosition_4BitsMode(1,5);
    4ebe:	81 e0       	ldi	r24, 0x01	; 1
    4ec0:	65 e0       	ldi	r22, 0x05	; 5
    4ec2:	0e 94 63 13 	call	0x26c6	; 0x26c6 <HCLCD_VidSetPosition_4BitsMode>
		HCLCD_VidWriteNumber_4Bits(ADC_Value);
    4ec6:	80 91 0b 05 	lds	r24, 0x050B
    4eca:	90 91 0c 05 	lds	r25, 0x050C
    4ece:	a0 91 0d 05 	lds	r26, 0x050D
    4ed2:	b0 91 0e 05 	lds	r27, 0x050E
    4ed6:	bc 01       	movw	r22, r24
    4ed8:	cd 01       	movw	r24, r26
    4eda:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <HCLCD_VidWriteNumber_4Bits>
		vTaskDelay(100);
    4ede:	84 e6       	ldi	r24, 0x64	; 100
    4ee0:	90 e0       	ldi	r25, 0x00	; 0
    4ee2:	0e 94 57 21 	call	0x42ae	; 0x42ae <vTaskDelay>
    4ee6:	eb cf       	rjmp	.-42     	; 0x4ebe <APP_LCD_Display+0x26>

00004ee8 <APP_ADC_Task>:
	}
}
void APP_ADC_Task(void*pv)
{
    4ee8:	df 93       	push	r29
    4eea:	cf 93       	push	r28
    4eec:	00 d0       	rcall	.+0      	; 0x4eee <APP_ADC_Task+0x6>
    4eee:	00 d0       	rcall	.+0      	; 0x4ef0 <APP_ADC_Task+0x8>
    4ef0:	0f 92       	push	r0
    4ef2:	cd b7       	in	r28, 0x3d	; 61
    4ef4:	de b7       	in	r29, 0x3e	; 62
    4ef6:	9d 83       	std	Y+5, r25	; 0x05
    4ef8:	8c 83       	std	Y+4, r24	; 0x04
	u8 ADC_SemState=0;
    4efa:	1b 82       	std	Y+3, r1	; 0x03
	u16 DigitalValue;

	MADC_VidSetCallBack(ADC_SetNotification);
    4efc:	8a e3       	ldi	r24, 0x3A	; 58
    4efe:	97 e2       	ldi	r25, 0x27	; 39
    4f00:	0e 94 46 0a 	call	0x148c	; 0x148c <MADC_VidSetCallBack>
	MADC_VidInit();
    4f04:	0e 94 a7 09 	call	0x134e	; 0x134e <MADC_VidInit>
	MADC_u16ADC_StartConversion_With_Interrupt(CHANNEL_0);
    4f08:	80 e0       	ldi	r24, 0x00	; 0
    4f0a:	0e 94 18 0a 	call	0x1430	; 0x1430 <MADC_u16ADC_StartConversion_With_Interrupt>
	MADC_VidADCInterruptEnable();
    4f0e:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <MADC_VidADCInterruptEnable>
	while(1)
	{
		ADC_SemState=xSemaphoreTake(ADCSem,10);
    4f12:	80 91 11 05 	lds	r24, 0x0511
    4f16:	90 91 12 05 	lds	r25, 0x0512
    4f1a:	60 e0       	ldi	r22, 0x00	; 0
    4f1c:	70 e0       	ldi	r23, 0x00	; 0
    4f1e:	4a e0       	ldi	r20, 0x0A	; 10
    4f20:	50 e0       	ldi	r21, 0x00	; 0
    4f22:	20 e0       	ldi	r18, 0x00	; 0
    4f24:	0e 94 a6 1c 	call	0x394c	; 0x394c <xQueueGenericReceive>
    4f28:	8b 83       	std	Y+3, r24	; 0x03
		if(ADC_SemState==pdPASS)
    4f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    4f2c:	81 30       	cpi	r24, 0x01	; 1
    4f2e:	39 f5       	brne	.+78     	; 0x4f7e <APP_ADC_Task+0x96>
		{
			DigitalValue=MADC_u16ADCRead();
    4f30:	0e 94 3b 0a 	call	0x1476	; 0x1476 <MADC_u16ADCRead>
    4f34:	9a 83       	std	Y+2, r25	; 0x02
    4f36:	89 83       	std	Y+1, r24	; 0x01
			ADC_Value=((DigitalValue*5000UL)/1024);
    4f38:	89 81       	ldd	r24, Y+1	; 0x01
    4f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f3c:	cc 01       	movw	r24, r24
    4f3e:	a0 e0       	ldi	r26, 0x00	; 0
    4f40:	b0 e0       	ldi	r27, 0x00	; 0
    4f42:	28 e8       	ldi	r18, 0x88	; 136
    4f44:	33 e1       	ldi	r19, 0x13	; 19
    4f46:	40 e0       	ldi	r20, 0x00	; 0
    4f48:	50 e0       	ldi	r21, 0x00	; 0
    4f4a:	bc 01       	movw	r22, r24
    4f4c:	cd 01       	movw	r24, r26
    4f4e:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <__mulsi3>
    4f52:	dc 01       	movw	r26, r24
    4f54:	cb 01       	movw	r24, r22
    4f56:	07 2e       	mov	r0, r23
    4f58:	7a e0       	ldi	r23, 0x0A	; 10
    4f5a:	b6 95       	lsr	r27
    4f5c:	a7 95       	ror	r26
    4f5e:	97 95       	ror	r25
    4f60:	87 95       	ror	r24
    4f62:	7a 95       	dec	r23
    4f64:	d1 f7       	brne	.-12     	; 0x4f5a <APP_ADC_Task+0x72>
    4f66:	70 2d       	mov	r23, r0
    4f68:	80 93 0b 05 	sts	0x050B, r24
    4f6c:	90 93 0c 05 	sts	0x050C, r25
    4f70:	a0 93 0d 05 	sts	0x050D, r26
    4f74:	b0 93 0e 05 	sts	0x050E, r27
			MADC_u16ADC_StartConversion_With_Interrupt(CHANNEL_0);
    4f78:	80 e0       	ldi	r24, 0x00	; 0
    4f7a:	0e 94 18 0a 	call	0x1430	; 0x1430 <MADC_u16ADC_StartConversion_With_Interrupt>
		}
		vTaskDelay(10);
    4f7e:	8a e0       	ldi	r24, 0x0A	; 10
    4f80:	90 e0       	ldi	r25, 0x00	; 0
    4f82:	0e 94 57 21 	call	0x42ae	; 0x42ae <vTaskDelay>
    4f86:	c5 cf       	rjmp	.-118    	; 0x4f12 <APP_ADC_Task+0x2a>

00004f88 <__mulsi3>:
    4f88:	62 9f       	mul	r22, r18
    4f8a:	d0 01       	movw	r26, r0
    4f8c:	73 9f       	mul	r23, r19
    4f8e:	f0 01       	movw	r30, r0
    4f90:	82 9f       	mul	r24, r18
    4f92:	e0 0d       	add	r30, r0
    4f94:	f1 1d       	adc	r31, r1
    4f96:	64 9f       	mul	r22, r20
    4f98:	e0 0d       	add	r30, r0
    4f9a:	f1 1d       	adc	r31, r1
    4f9c:	92 9f       	mul	r25, r18
    4f9e:	f0 0d       	add	r31, r0
    4fa0:	83 9f       	mul	r24, r19
    4fa2:	f0 0d       	add	r31, r0
    4fa4:	74 9f       	mul	r23, r20
    4fa6:	f0 0d       	add	r31, r0
    4fa8:	65 9f       	mul	r22, r21
    4faa:	f0 0d       	add	r31, r0
    4fac:	99 27       	eor	r25, r25
    4fae:	72 9f       	mul	r23, r18
    4fb0:	b0 0d       	add	r27, r0
    4fb2:	e1 1d       	adc	r30, r1
    4fb4:	f9 1f       	adc	r31, r25
    4fb6:	63 9f       	mul	r22, r19
    4fb8:	b0 0d       	add	r27, r0
    4fba:	e1 1d       	adc	r30, r1
    4fbc:	f9 1f       	adc	r31, r25
    4fbe:	bd 01       	movw	r22, r26
    4fc0:	cf 01       	movw	r24, r30
    4fc2:	11 24       	eor	r1, r1
    4fc4:	08 95       	ret

00004fc6 <__udivmodsi4>:
    4fc6:	a1 e2       	ldi	r26, 0x21	; 33
    4fc8:	1a 2e       	mov	r1, r26
    4fca:	aa 1b       	sub	r26, r26
    4fcc:	bb 1b       	sub	r27, r27
    4fce:	fd 01       	movw	r30, r26
    4fd0:	0d c0       	rjmp	.+26     	; 0x4fec <__udivmodsi4_ep>

00004fd2 <__udivmodsi4_loop>:
    4fd2:	aa 1f       	adc	r26, r26
    4fd4:	bb 1f       	adc	r27, r27
    4fd6:	ee 1f       	adc	r30, r30
    4fd8:	ff 1f       	adc	r31, r31
    4fda:	a2 17       	cp	r26, r18
    4fdc:	b3 07       	cpc	r27, r19
    4fde:	e4 07       	cpc	r30, r20
    4fe0:	f5 07       	cpc	r31, r21
    4fe2:	20 f0       	brcs	.+8      	; 0x4fec <__udivmodsi4_ep>
    4fe4:	a2 1b       	sub	r26, r18
    4fe6:	b3 0b       	sbc	r27, r19
    4fe8:	e4 0b       	sbc	r30, r20
    4fea:	f5 0b       	sbc	r31, r21

00004fec <__udivmodsi4_ep>:
    4fec:	66 1f       	adc	r22, r22
    4fee:	77 1f       	adc	r23, r23
    4ff0:	88 1f       	adc	r24, r24
    4ff2:	99 1f       	adc	r25, r25
    4ff4:	1a 94       	dec	r1
    4ff6:	69 f7       	brne	.-38     	; 0x4fd2 <__udivmodsi4_loop>
    4ff8:	60 95       	com	r22
    4ffa:	70 95       	com	r23
    4ffc:	80 95       	com	r24
    4ffe:	90 95       	com	r25
    5000:	9b 01       	movw	r18, r22
    5002:	ac 01       	movw	r20, r24
    5004:	bd 01       	movw	r22, r26
    5006:	cf 01       	movw	r24, r30
    5008:	08 95       	ret

0000500a <__prologue_saves__>:
    500a:	2f 92       	push	r2
    500c:	3f 92       	push	r3
    500e:	4f 92       	push	r4
    5010:	5f 92       	push	r5
    5012:	6f 92       	push	r6
    5014:	7f 92       	push	r7
    5016:	8f 92       	push	r8
    5018:	9f 92       	push	r9
    501a:	af 92       	push	r10
    501c:	bf 92       	push	r11
    501e:	cf 92       	push	r12
    5020:	df 92       	push	r13
    5022:	ef 92       	push	r14
    5024:	ff 92       	push	r15
    5026:	0f 93       	push	r16
    5028:	1f 93       	push	r17
    502a:	cf 93       	push	r28
    502c:	df 93       	push	r29
    502e:	cd b7       	in	r28, 0x3d	; 61
    5030:	de b7       	in	r29, 0x3e	; 62
    5032:	ca 1b       	sub	r28, r26
    5034:	db 0b       	sbc	r29, r27
    5036:	0f b6       	in	r0, 0x3f	; 63
    5038:	f8 94       	cli
    503a:	de bf       	out	0x3e, r29	; 62
    503c:	0f be       	out	0x3f, r0	; 63
    503e:	cd bf       	out	0x3d, r28	; 61
    5040:	09 94       	ijmp

00005042 <__epilogue_restores__>:
    5042:	2a 88       	ldd	r2, Y+18	; 0x12
    5044:	39 88       	ldd	r3, Y+17	; 0x11
    5046:	48 88       	ldd	r4, Y+16	; 0x10
    5048:	5f 84       	ldd	r5, Y+15	; 0x0f
    504a:	6e 84       	ldd	r6, Y+14	; 0x0e
    504c:	7d 84       	ldd	r7, Y+13	; 0x0d
    504e:	8c 84       	ldd	r8, Y+12	; 0x0c
    5050:	9b 84       	ldd	r9, Y+11	; 0x0b
    5052:	aa 84       	ldd	r10, Y+10	; 0x0a
    5054:	b9 84       	ldd	r11, Y+9	; 0x09
    5056:	c8 84       	ldd	r12, Y+8	; 0x08
    5058:	df 80       	ldd	r13, Y+7	; 0x07
    505a:	ee 80       	ldd	r14, Y+6	; 0x06
    505c:	fd 80       	ldd	r15, Y+5	; 0x05
    505e:	0c 81       	ldd	r16, Y+4	; 0x04
    5060:	1b 81       	ldd	r17, Y+3	; 0x03
    5062:	aa 81       	ldd	r26, Y+2	; 0x02
    5064:	b9 81       	ldd	r27, Y+1	; 0x01
    5066:	ce 0f       	add	r28, r30
    5068:	d1 1d       	adc	r29, r1
    506a:	0f b6       	in	r0, 0x3f	; 63
    506c:	f8 94       	cli
    506e:	de bf       	out	0x3e, r29	; 62
    5070:	0f be       	out	0x3f, r0	; 63
    5072:	cd bf       	out	0x3d, r28	; 61
    5074:	ed 01       	movw	r28, r26
    5076:	08 95       	ret

00005078 <memcpy>:
    5078:	fb 01       	movw	r30, r22
    507a:	dc 01       	movw	r26, r24
    507c:	02 c0       	rjmp	.+4      	; 0x5082 <memcpy+0xa>
    507e:	01 90       	ld	r0, Z+
    5080:	0d 92       	st	X+, r0
    5082:	41 50       	subi	r20, 0x01	; 1
    5084:	50 40       	sbci	r21, 0x00	; 0
    5086:	d8 f7       	brcc	.-10     	; 0x507e <memcpy+0x6>
    5088:	08 95       	ret

0000508a <memset>:
    508a:	dc 01       	movw	r26, r24
    508c:	01 c0       	rjmp	.+2      	; 0x5090 <memset+0x6>
    508e:	6d 93       	st	X+, r22
    5090:	41 50       	subi	r20, 0x01	; 1
    5092:	50 40       	sbci	r21, 0x00	; 0
    5094:	e0 f7       	brcc	.-8      	; 0x508e <memset+0x4>
    5096:	08 95       	ret

00005098 <strncpy>:
    5098:	fb 01       	movw	r30, r22
    509a:	dc 01       	movw	r26, r24
    509c:	41 50       	subi	r20, 0x01	; 1
    509e:	50 40       	sbci	r21, 0x00	; 0
    50a0:	48 f0       	brcs	.+18     	; 0x50b4 <strncpy+0x1c>
    50a2:	01 90       	ld	r0, Z+
    50a4:	0d 92       	st	X+, r0
    50a6:	00 20       	and	r0, r0
    50a8:	c9 f7       	brne	.-14     	; 0x509c <strncpy+0x4>
    50aa:	01 c0       	rjmp	.+2      	; 0x50ae <strncpy+0x16>
    50ac:	1d 92       	st	X+, r1
    50ae:	41 50       	subi	r20, 0x01	; 1
    50b0:	50 40       	sbci	r21, 0x00	; 0
    50b2:	e0 f7       	brcc	.-8      	; 0x50ac <strncpy+0x14>
    50b4:	08 95       	ret

000050b6 <_exit>:
    50b6:	f8 94       	cli

000050b8 <__stop_program>:
    50b8:	ff cf       	rjmp	.-2      	; 0x50b8 <__stop_program>
